const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/app-Bw1Ba-jV.js","assets/main.CzEw2R-H.js","assets/app-D3TxLTK-.css"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _tags, _levelString, _errorHandler, _ConsoleLogger_instances, levelValue_get, _getDocumentModelModule, _drives, _ReadModeService_instances, parseGraphQLErrors_fn, fetchDrive_fn, _a, _ServiceWorkerManager_instances, handleServiceWorkerMessage_fn, handleServiceWorker_fn;
import { _ as __vitePreload } from "./main.CzEw2R-H.js";
import { jsx, jsxs } from "react/jsx-runtime";
import { useState, useEffect, Suspense, lazy } from "react";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
class DocumentEditorDebugTools {
  constructor(document) {
    __publicField(this, "document");
    __publicField(this, "operations", []);
    if (document) {
      this.document = document;
    }
  }
  operationsToTableObject(operations) {
    return operations.map((op) => ({
      ...op,
      input: JSON.stringify(op.input)
    }));
  }
  setDocument(document) {
    this.document = document;
  }
  getDocument() {
    return this.document;
  }
  getOperations() {
    return this.operations;
  }
  pushOperation(operation) {
    this.operations.push(operation);
  }
  operationsTable() {
    var _a2;
    if (!this.document) {
      console.warn("No document");
    }
    const ops = Object.values(((_a2 = this.document) == null ? void 0 : _a2.operations) || {}).flatMap((array) => array).sort((a, b) => a.index - b.index);
    console.table(this.operationsToTableObject(ops));
  }
  scopeOperationsTable(scope) {
    var _a2;
    if (!this.document) {
      console.warn("No document");
    }
    const ops = ((_a2 = this.document) == null ? void 0 : _a2.operations[scope]) || [];
    console.table(this.operationsToTableObject(ops));
  }
  operationsLog() {
    console.log(this.operations);
  }
  operationsLogTable() {
    console.table(this.operationsToTableObject(this.operations));
  }
  clear() {
    this.operations = [];
    this.document = void 0;
  }
}
class InMemoryCache {
  constructor() {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
  }
  async setDocument(drive, id, document) {
    var _a2;
    const global2 = document.operations.global.map((e) => {
      delete e.resultingState;
      return e;
    });
    const local = document.operations.local.map((e) => {
      delete e.resultingState;
      return e;
    });
    const doc = { ...document, operations: { global: global2, local } };
    if (!this.cache.has(drive)) {
      this.cache.set(drive, /* @__PURE__ */ new Map());
    }
    (_a2 = this.cache.get(drive)) == null ? void 0 : _a2.set(id, doc);
    return true;
  }
  async deleteDocument(drive, id) {
    var _a2;
    return ((_a2 = this.cache.get(drive)) == null ? void 0 : _a2.delete(id)) ?? false;
  }
  async getDocument(drive, id) {
    var _a2;
    return (_a2 = this.cache.get(drive)) == null ? void 0 : _a2.get(id);
  }
}
const K = [
  1518500249 | 0,
  1859775393 | 0,
  2400959708 | 0,
  3395469782 | 0
];
function createHash(algorithm) {
  return new Hash();
}
class Hash {
  constructor() {
    this.A = 1732584193 | 0;
    this.B = 4023233417 | 0;
    this.C = 2562383102 | 0;
    this.D = 271733878 | 0;
    this.E = 3285377520 | 0;
    this._size = 0;
    this._sp = 0;
    if (!sharedBuffer || sharedOffset >= 8e3) {
      sharedBuffer = new ArrayBuffer(
        8e3
        /* N.allocTotal */
      );
      sharedOffset = 0;
    }
    this._byte = new Uint8Array(
      sharedBuffer,
      sharedOffset,
      80
      /* N.allocBytes */
    );
    this._word = new Int32Array(
      sharedBuffer,
      sharedOffset,
      20
      /* N.allocWords */
    );
    sharedOffset += 80;
  }
  update(data) {
    if ("string" === typeof data) {
      return this._utf8(data);
    }
    if (data == null) {
      throw new TypeError("Invalid type: " + typeof data);
    }
    const byteOffset = data.byteOffset;
    const length = data.byteLength;
    let blocks = length / 64 | 0;
    let offset = 0;
    if (blocks && !(byteOffset & 3) && !(this._size % 64)) {
      const block2 = new Int32Array(
        data.buffer,
        byteOffset,
        blocks * 16
        /* N.inputWords */
      );
      while (blocks--) {
        this._int32(block2, offset >> 2);
        offset += 64;
      }
      this._size += offset;
    }
    const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;
    if (BYTES_PER_ELEMENT !== 1 && data.buffer) {
      const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);
      return this._uint8(rest);
    }
    if (offset === length)
      return this;
    return this._uint8(data, offset);
  }
  _uint8(data, offset) {
    const { _byte, _word } = this;
    const length = data.length;
    offset = offset | 0;
    while (offset < length) {
      const start = this._size % 64;
      let index = start;
      while (offset < length && index < 64) {
        _byte[index++] = data[offset++];
      }
      if (index >= 64) {
        this._int32(_word);
      }
      this._size += index - start;
    }
    return this;
  }
  _utf8(text) {
    const { _byte, _word } = this;
    const length = text.length;
    let surrogate = this._sp;
    for (let offset = 0; offset < length; ) {
      const start = this._size % 64;
      let index = start;
      while (offset < length && index < 64) {
        let code = text.charCodeAt(offset++) | 0;
        if (code < 128) {
          _byte[index++] = code;
        } else if (code < 2048) {
          _byte[index++] = 192 | code >>> 6;
          _byte[index++] = 128 | code & 63;
        } else if (code < 55296 || code > 57343) {
          _byte[index++] = 224 | code >>> 12;
          _byte[index++] = 128 | code >>> 6 & 63;
          _byte[index++] = 128 | code & 63;
        } else if (surrogate) {
          code = ((surrogate & 1023) << 10) + (code & 1023) + 65536;
          _byte[index++] = 240 | code >>> 18;
          _byte[index++] = 128 | code >>> 12 & 63;
          _byte[index++] = 128 | code >>> 6 & 63;
          _byte[index++] = 128 | code & 63;
          surrogate = 0;
        } else {
          surrogate = code;
        }
      }
      if (index >= 64) {
        this._int32(_word);
        _word[0] = _word[
          16
          /* N.inputWords */
        ];
      }
      this._size += index - start;
    }
    this._sp = surrogate;
    return this;
  }
  _int32(data, offset) {
    let { A, B, C, D, E } = this;
    let i = 0;
    offset = offset | 0;
    while (i < 16) {
      W[i++] = swap32(data[offset++]);
    }
    for (i = 16; i < 80; i++) {
      W[i] = rotate1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
    }
    for (i = 0; i < 80; i++) {
      const S = i / 20 | 0;
      const T = rotate5(A) + ft(S, B, C, D) + E + W[i] + K[S] | 0;
      E = D;
      D = C;
      C = rotate30(B);
      B = A;
      A = T;
    }
    this.A = A + this.A | 0;
    this.B = B + this.B | 0;
    this.C = C + this.C | 0;
    this.D = D + this.D | 0;
    this.E = E + this.E | 0;
  }
  digest(encoding) {
    const { _byte, _word } = this;
    let i = this._size % 64 | 0;
    _byte[i++] = 128;
    while (i & 3) {
      _byte[i++] = 0;
    }
    i >>= 2;
    if (i > 14) {
      while (i < 16) {
        _word[i++] = 0;
      }
      i = 0;
      this._int32(_word);
    }
    while (i < 16) {
      _word[i++] = 0;
    }
    const bits64 = this._size * 8;
    const low32 = (bits64 & 4294967295) >>> 0;
    const high32 = (bits64 - low32) / 4294967296;
    if (high32)
      _word[
        14
        /* N.highIndex */
      ] = swap32(high32);
    if (low32)
      _word[
        15
        /* N.lowIndex */
      ] = swap32(low32);
    this._int32(_word);
    return encoding === "hex" ? this._hex() : this._bin();
  }
  _hex() {
    const { A, B, C, D, E } = this;
    return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E);
  }
  _bin() {
    const { A, B, C, D, E, _byte, _word } = this;
    _word[0] = swap32(A);
    _word[1] = swap32(B);
    _word[2] = swap32(C);
    _word[3] = swap32(D);
    _word[4] = swap32(E);
    return _byte.slice(0, 20);
  }
}
const W = new Int32Array(
  80
  /* N.workWords */
);
let sharedBuffer;
let sharedOffset = 0;
const hex32 = (num) => (num + 4294967296).toString(16).substr(-8);
const swapLE = (c) => c << 24 & 4278190080 | c << 8 & 16711680 | c >> 8 & 65280 | c >> 24 & 255;
const swapBE = (c) => c;
const swap32 = isBE() ? swapBE : swapLE;
const rotate1 = (num) => num << 1 | num >>> 31;
const rotate5 = (num) => num << 5 | num >>> 27;
const rotate30 = (num) => num << 30 | num >>> 2;
function ft(s, b, c, d) {
  if (s === 0)
    return b & c | ~b & d;
  if (s === 2)
    return b & c | b & d | c & d;
  return b ^ c ^ d;
}
function isBE() {
  const buf = new Uint8Array(new Uint16Array([65279]).buffer);
  return buf[0] === 254;
}
const FileSystemError = new Error("File system not available.");
function generateUUID$1() {
  if (!crypto.randomUUID) {
    throw new Error("generateUUID is not available in unsecure contexts.");
  }
  return crypto.randomUUID();
}
function writeFile(path, name2, stream) {
  throw FileSystemError;
}
function readFile(path) {
  throw FileSystemError;
}
const hash = (data, algorithm = "sha1") => {
  if (!["sha1"].includes(algorithm)) {
    throw new Error("Hashing algorithm not supported: Available: sha1");
  }
  const hash2 = hashUIntArray(data);
  return uint8ArrayToBase64(hash2);
};
function uint8ArrayToBase64(uint8Array) {
  let binaryString = "";
  for (let i = 0; i < uint8Array.length; i++) {
    binaryString += String.fromCharCode(uint8Array[i]);
  }
  const base64String = btoa(binaryString);
  return base64String;
}
function hashUIntArray(data, algorithm = "sha1") {
  if (!["sha1"].includes(algorithm)) {
    throw new Error("Hashing algorithm not supported: Available: sha1");
  }
  return createHash().update(data).digest();
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var safeStableStringify = { exports: {} };
var hasRequiredSafeStableStringify;
function requireSafeStableStringify() {
  if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
  hasRequiredSafeStableStringify = 1;
  (function(module, exports) {
    const { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    const stringify2 = configure();
    stringify2.configure = configure;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports.stringify = stringify2;
    exports.configure = configure;
    module.exports = stringify2;
    const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty2.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty2.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty2.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join2 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join2 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join3 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join3;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join2 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join2, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join2;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify3(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify3;
    }
  })(safeStableStringify, safeStableStringify.exports);
  return safeStableStringify.exports;
}
var safeStableStringifyExports = requireSafeStableStringify();
const cjsModule = /* @__PURE__ */ getDefaultExportFromCjs(safeStableStringifyExports);
cjsModule.configure;
var util$1;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$1 || (util$1 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$1.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$1.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$1.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$1.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$1.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$1.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$1.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet$1(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    var _a2, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a2, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a2 = err === null || err === void 0 ? void 0 : err.message) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a2) {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$1.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$1.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a2) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$1.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$1.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util$1.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$1.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$1.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return util$1.objectValues(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else if (type2 instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type2.unwrap())];
  } else if (type2 instanceof ZodBranded) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodReadonly) {
    return getDiscriminator(type2.unwrap());
  } else if (type2 instanceof ZodCatch) {
    return getDiscriminator(type2._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$1.objectKeys(b);
    const sharedKeys = util$1.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet$1(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet$1(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util$1.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$1.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet$1(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util$1.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet$1(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util$1.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$1.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a3, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a3 = params.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util$1;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const SET_NAME = "SET_NAME";
const UNDO = "UNDO";
const REDO = "REDO";
const PRUNE = "PRUNE";
const LOAD_STATE = "LOAD_STATE";
const Operation = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
};
const PROXY_DRAFT = Symbol.for("__MUTATIVE_PROXY_DRAFT__");
const RAW_RETURN_SYMBOL = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__");
const iteratorSymbol = Symbol.iterator;
const dataTypes = {
  mutable: "mutable",
  immutable: "immutable"
};
const internal = {};
function has(target, key) {
  return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
  if (key in target) {
    let prototype = Reflect.getPrototypeOf(target);
    while (prototype) {
      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
      if (descriptor)
        return descriptor;
      prototype = Reflect.getPrototypeOf(prototype);
    }
  }
  return;
}
function isBaseSetInstance(obj) {
  return Object.getPrototypeOf(obj) === Set.prototype;
}
function isBaseMapInstance(obj) {
  return Object.getPrototypeOf(obj) === Map.prototype;
}
function latest(proxyDraft) {
  var _a2;
  return (_a2 = proxyDraft.copy) !== null && _a2 !== void 0 ? _a2 : proxyDraft.original;
}
function isDraft(target) {
  return !!getProxyDraft(target);
}
function getProxyDraft(value) {
  if (typeof value !== "object")
    return null;
  return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
  var _a2;
  const proxyDraft = getProxyDraft(value);
  return proxyDraft ? (_a2 = proxyDraft.copy) !== null && _a2 !== void 0 ? _a2 : proxyDraft.original : value;
}
function isDraftable(value, options) {
  if (!value || typeof value !== "object")
    return false;
  let markResult;
  return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === "function");
}
function getPath$1(target, path = []) {
  if (Object.hasOwnProperty.call(target, "key")) {
    const parentCopy = target.parent.copy;
    const proxyDraft = getProxyDraft(get$1(parentCopy, target.key));
    if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
      return null;
    }
    const isSet = target.parent.type === 3;
    const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
    if (!(isSet && parentCopy.size > key || has(parentCopy, key)))
      return null;
    path.push(key);
  }
  if (target.parent) {
    return getPath$1(target.parent, path);
  }
  path.reverse();
  try {
    resolvePath(target.copy, path);
  } catch (e) {
    return null;
  }
  return path;
}
function getType(target) {
  if (Array.isArray(target))
    return 1;
  if (target instanceof Map)
    return 2;
  if (target instanceof Set)
    return 3;
  return 0;
}
function get$1(target, key) {
  return getType(target) === 2 ? target.get(key) : target[key];
}
function set(target, key, value) {
  const type2 = getType(target);
  if (type2 === 2) {
    target.set(key, value);
  } else {
    target[key] = value;
  }
}
function peek(target, key) {
  const state = getProxyDraft(target);
  const source = state ? latest(state) : target;
  return source[key];
}
function isEqual(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function revokeProxy(proxyDraft) {
  if (!proxyDraft)
    return;
  while (proxyDraft.finalities.revoke.length > 0) {
    const revoke = proxyDraft.finalities.revoke.pop();
    revoke();
  }
}
function escapePath(path, pathAsArray) {
  return pathAsArray ? path : [""].concat(path).map((_item) => {
    const item = `${_item}`;
    if (item.indexOf("/") === -1 && item.indexOf("~") === -1)
      return item;
    return item.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function resolvePath(base, path) {
  for (let index = 0; index < path.length - 1; index += 1) {
    const key = path[index];
    base = get$1(getType(base) === 3 ? Array.from(base) : base, key);
    if (typeof base !== "object") {
      throw new Error(`Cannot resolve patch at '${path.join("/")}'.`);
    }
  }
  return base;
}
function strictCopy(target) {
  const copy2 = Object.create(Object.getPrototypeOf(target));
  Reflect.ownKeys(target).forEach((key) => {
    let desc = Reflect.getOwnPropertyDescriptor(target, key);
    if (desc.enumerable && desc.configurable && desc.writable) {
      copy2[key] = target[key];
      return;
    }
    if (!desc.writable) {
      desc.writable = true;
      desc.configurable = true;
    }
    if (desc.get || desc.set)
      desc = {
        configurable: true,
        writable: true,
        enumerable: desc.enumerable,
        value: target[key]
      };
    Reflect.defineProperty(copy2, key, desc);
  });
  return copy2;
}
const propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
  let markResult;
  if (Array.isArray(original)) {
    return Array.prototype.concat.call(original);
  } else if (original instanceof Set) {
    if (!isBaseSetInstance(original)) {
      const SubClass = Object.getPrototypeOf(original).constructor;
      return new SubClass(original.values());
    }
    return Set.prototype.difference ? Set.prototype.difference.call(original, /* @__PURE__ */ new Set()) : new Set(original.values());
  } else if (original instanceof Map) {
    if (!isBaseMapInstance(original)) {
      const SubClass = Object.getPrototypeOf(original).constructor;
      return new SubClass(original);
    }
    return new Map(original);
  } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== void 0) && markResult !== dataTypes.mutable) {
    if (markResult === dataTypes.immutable) {
      return strictCopy(original);
    } else if (typeof markResult === "function") {
      if (options.enablePatches || options.enableAutoFreeze) {
        throw new Error(`You can't use mark and patches or auto freeze together.`);
      }
      return markResult();
    }
    throw new Error(`Unsupported mark result: ${markResult}`);
  } else if (typeof original === "object" && Object.getPrototypeOf(original) === Object.prototype) {
    const copy2 = {};
    Object.keys(original).forEach((key) => {
      copy2[key] = original[key];
    });
    Object.getOwnPropertySymbols(original).forEach((key) => {
      if (propIsEnum.call(original, key)) {
        copy2[key] = original[key];
      }
    });
    return copy2;
  } else {
    throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
  }
}
function ensureShallowCopy(target) {
  if (target.copy)
    return;
  target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
  if (!isDraftable(target))
    return getValue(target);
  if (Array.isArray(target))
    return target.map(deepClone);
  if (target instanceof Map) {
    const iterable = Array.from(target.entries()).map(([k, v]) => [
      k,
      deepClone(v)
    ]);
    if (!isBaseMapInstance(target)) {
      const SubClass = Object.getPrototypeOf(target).constructor;
      return new SubClass(iterable);
    }
    return new Map(iterable);
  }
  if (target instanceof Set) {
    const iterable = Array.from(target).map(deepClone);
    if (!isBaseSetInstance(target)) {
      const SubClass = Object.getPrototypeOf(target).constructor;
      return new SubClass(iterable);
    }
    return new Set(iterable);
  }
  const copy2 = Object.create(Object.getPrototypeOf(target));
  for (const key in target)
    copy2[key] = deepClone(target[key]);
  return copy2;
}
function cloneIfNeeded(target) {
  return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
  var _a2;
  proxyDraft.assignedMap = (_a2 = proxyDraft.assignedMap) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Map();
  if (!proxyDraft.operated) {
    proxyDraft.operated = true;
    if (proxyDraft.parent) {
      markChanged(proxyDraft.parent);
    }
  }
}
function throwFrozenError() {
  throw new Error("Cannot modify frozen object");
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
  {
    updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : /* @__PURE__ */ new WeakMap();
    stack = stack !== null && stack !== void 0 ? stack : [];
    keys = keys !== null && keys !== void 0 ? keys : [];
    const value = updatedValues.has(target) ? updatedValues.get(target) : target;
    if (stack.length > 0) {
      const index = stack.indexOf(value);
      if (value && typeof value === "object" && index !== -1) {
        if (stack[0] === value) {
          throw new Error(`Forbids circular reference`);
        }
        throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index2) => {
          if (typeof key === "symbol")
            return `[${key.toString()}]`;
          const parent = stack[index2];
          if (typeof key === "object" && (parent instanceof Map || parent instanceof Set))
            return Array.from(parent.keys()).indexOf(key);
          return key;
        }).join("/")}`);
      }
      stack.push(value);
      keys.push(subKey);
    } else {
      stack.push(value);
    }
  }
  if (Object.isFrozen(target) || isDraft(target)) {
    {
      stack.pop();
      keys.pop();
    }
    return;
  }
  const type2 = getType(target);
  switch (type2) {
    case 2:
      for (const [key, value] of target) {
        deepFreeze(key, key, updatedValues, stack, keys);
        deepFreeze(value, key, updatedValues, stack, keys);
      }
      target.set = target.clear = target.delete = throwFrozenError;
      break;
    case 3:
      for (const value of target) {
        deepFreeze(value, value, updatedValues, stack, keys);
      }
      target.add = target.clear = target.delete = throwFrozenError;
      break;
    case 1:
      Object.freeze(target);
      let index = 0;
      for (const value of target) {
        deepFreeze(value, index, updatedValues, stack, keys);
        index += 1;
      }
      break;
    default:
      Object.freeze(target);
      Object.keys(target).forEach((name2) => {
        const value = target[name2];
        deepFreeze(value, name2, updatedValues, stack, keys);
      });
  }
  {
    stack.pop();
    keys.pop();
  }
}
function forEach(target, iter) {
  const type2 = getType(target);
  if (type2 === 0) {
    Reflect.ownKeys(target).forEach((key) => {
      iter(key, target[key], target);
    });
  } else if (type2 === 1) {
    let index = 0;
    for (const entry of target) {
      iter(index, entry, target);
      index += 1;
    }
  } else {
    target.forEach((entry, index) => iter(index, entry, target));
  }
}
function handleValue(target, handledSet, options) {
  if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target))
    return;
  const isSet = target instanceof Set;
  const setMap = isSet ? /* @__PURE__ */ new Map() : void 0;
  handledSet.add(target);
  forEach(target, (key, value) => {
    var _a2;
    if (isDraft(value)) {
      const proxyDraft = getProxyDraft(value);
      ensureShallowCopy(proxyDraft);
      const updatedValue = ((_a2 = proxyDraft.assignedMap) === null || _a2 === void 0 ? void 0 : _a2.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
      set(isSet ? setMap : target, key, updatedValue);
    } else {
      handleValue(value, handledSet, options);
    }
  });
  if (setMap) {
    const set2 = target;
    const values = Array.from(set2);
    set2.clear();
    values.forEach((value) => {
      set2.add(setMap.has(value) ? setMap.get(value) : value);
    });
  }
}
function finalizeAssigned(proxyDraft, key) {
  const copy2 = proxyDraft.type === 3 ? proxyDraft.setMap : proxyDraft.copy;
  if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy2) {
    handleValue(get$1(copy2, key), proxyDraft.finalities.handledSet, proxyDraft.options);
  }
}
function finalizeSetValue(target) {
  if (target.type === 3 && target.copy) {
    target.copy.clear();
    target.setMap.forEach((value) => {
      target.copy.add(getValue(value));
    });
  }
}
function finalizePatches(target, generatePatches2, patches, inversePatches) {
  const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
  if (shouldFinalize) {
    if (patches && inversePatches) {
      const basePath2 = getPath$1(target);
      if (basePath2) {
        generatePatches2(target, basePath2, patches, inversePatches);
      }
    }
    target.finalized = true;
  }
}
function markFinalization(target, key, value, generatePatches2) {
  const proxyDraft = getProxyDraft(value);
  if (proxyDraft) {
    if (!proxyDraft.callbacks) {
      proxyDraft.callbacks = [];
    }
    proxyDraft.callbacks.push((patches, inversePatches) => {
      var _a2;
      const copy2 = target.type === 3 ? target.setMap : target.copy;
      if (isEqual(get$1(copy2, key), value)) {
        let updatedValue = proxyDraft.original;
        if (proxyDraft.copy) {
          updatedValue = proxyDraft.copy;
        }
        finalizeSetValue(target);
        finalizePatches(target, generatePatches2, patches, inversePatches);
        if (target.options.enableAutoFreeze) {
          target.options.updatedValues = (_a2 = target.options.updatedValues) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new WeakMap();
          target.options.updatedValues.set(updatedValue, proxyDraft.original);
        }
        set(copy2, key, updatedValue);
      }
    });
    if (target.options.enableAutoFreeze) {
      if (proxyDraft.finalities !== target.finalities) {
        target.options.enableAutoFreeze = false;
      }
    }
  }
  if (isDraftable(value, target.options)) {
    target.finalities.draft.push(() => {
      const copy2 = target.type === 3 ? target.setMap : target.copy;
      if (isEqual(get$1(copy2, key), value)) {
        finalizeAssigned(target, key);
      }
    });
  }
}
function generateArrayPatches(proxyState, basePath2, patches, inversePatches, pathAsArray) {
  let { original, assignedMap, options } = proxyState;
  let copy2 = proxyState.copy;
  if (copy2.length < original.length) {
    [original, copy2] = [copy2, original];
    [patches, inversePatches] = [inversePatches, patches];
  }
  for (let index = 0; index < original.length; index += 1) {
    if (assignedMap.get(index.toString()) && copy2[index] !== original[index]) {
      const _path = basePath2.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Replace,
        path,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: cloneIfNeeded(copy2[index])
      });
      inversePatches.push({
        op: Operation.Replace,
        path,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: cloneIfNeeded(original[index])
      });
    }
  }
  for (let index = original.length; index < copy2.length; index += 1) {
    const _path = basePath2.concat([index]);
    const path = escapePath(_path, pathAsArray);
    patches.push({
      op: Operation.Add,
      path,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: cloneIfNeeded(copy2[index])
    });
  }
  if (original.length < copy2.length) {
    const { arrayLengthAssignment = true } = options.enablePatches;
    if (arrayLengthAssignment) {
      const _path = basePath2.concat(["length"]);
      const path = escapePath(_path, pathAsArray);
      inversePatches.push({
        op: Operation.Replace,
        path,
        value: original.length
      });
    } else {
      for (let index = copy2.length; original.length < index; index -= 1) {
        const _path = basePath2.concat([index - 1]);
        const path = escapePath(_path, pathAsArray);
        inversePatches.push({
          op: Operation.Remove,
          path
        });
      }
    }
  }
}
function generatePatchesFromAssigned({ original, copy: copy2, assignedMap }, basePath2, patches, inversePatches, pathAsArray) {
  assignedMap.forEach((assignedValue, key) => {
    const originalValue = get$1(original, key);
    const value = cloneIfNeeded(get$1(copy2, key));
    const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
    if (isEqual(originalValue, value) && op === Operation.Replace)
      return;
    const _path = basePath2.concat(key);
    const path = escapePath(_path, pathAsArray);
    patches.push(op === Operation.Remove ? { op, path } : { op, path, value });
    inversePatches.push(op === Operation.Add ? { op: Operation.Remove, path } : op === Operation.Remove ? { op: Operation.Add, path, value: originalValue } : { op: Operation.Replace, path, value: originalValue });
  });
}
function generateSetPatches({ original, copy: copy2 }, basePath2, patches, inversePatches, pathAsArray) {
  let index = 0;
  original.forEach((value) => {
    if (!copy2.has(value)) {
      const _path = basePath2.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Remove,
        path,
        value
      });
      inversePatches.unshift({
        op: Operation.Add,
        path,
        value
      });
    }
    index += 1;
  });
  index = 0;
  copy2.forEach((value) => {
    if (!original.has(value)) {
      const _path = basePath2.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Add,
        path,
        value
      });
      inversePatches.unshift({
        op: Operation.Remove,
        path,
        value
      });
    }
    index += 1;
  });
}
function generatePatches(proxyState, basePath2, patches, inversePatches) {
  const { pathAsArray = true } = proxyState.options.enablePatches;
  switch (proxyState.type) {
    case 0:
    case 2:
      return generatePatchesFromAssigned(proxyState, basePath2, patches, inversePatches, pathAsArray);
    case 1:
      return generateArrayPatches(proxyState, basePath2, patches, inversePatches, pathAsArray);
    case 3:
      return generateSetPatches(proxyState, basePath2, patches, inversePatches, pathAsArray);
  }
}
let readable = false;
const checkReadable = (value, options, ignoreCheckDraftable = false) => {
  if (typeof value === "object" && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
    throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
  }
};
function unsafe(callback) {
  readable = true;
  let result;
  try {
    result = callback();
  } finally {
    readable = false;
  }
  return result;
}
const mapHandler = {
  get size() {
    const current2 = latest(getProxyDraft(this));
    return current2.size;
  },
  has(key) {
    return latest(getProxyDraft(this)).has(key);
  },
  set(key, value) {
    const target = getProxyDraft(this);
    const source = latest(target);
    if (!source.has(key) || !isEqual(source.get(key), value)) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(key, true);
      target.copy.set(key, value);
      markFinalization(target, key, value, generatePatches);
    }
    return this;
  },
  delete(key) {
    if (!this.has(key)) {
      return false;
    }
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    if (target.original.has(key)) {
      target.assignedMap.set(key, false);
    } else {
      target.assignedMap.delete(key);
    }
    target.copy.delete(key);
    return true;
  },
  clear() {
    const target = getProxyDraft(this);
    if (!this.size)
      return;
    ensureShallowCopy(target);
    markChanged(target);
    target.assignedMap = /* @__PURE__ */ new Map();
    for (const [key] of target.original) {
      target.assignedMap.set(key, false);
    }
    target.copy.clear();
  },
  forEach(callback, thisArg) {
    const target = getProxyDraft(this);
    latest(target).forEach((_value, _key) => {
      callback.call(thisArg, this.get(_key), _key, this);
    });
  },
  get(key) {
    var _a2, _b;
    const target = getProxyDraft(this);
    const value = latest(target).get(key);
    const mutable = ((_b = (_a2 = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a2, value, dataTypes)) === dataTypes.mutable;
    if (target.options.strict) {
      checkReadable(value, target.options, mutable);
    }
    if (mutable) {
      return value;
    }
    if (target.finalized || !isDraftable(value, target.options)) {
      return value;
    }
    if (value !== target.original.get(key)) {
      return value;
    }
    const draft = internal.createDraft({
      original: value,
      parentDraft: target,
      key,
      finalities: target.finalities,
      options: target.options
    });
    ensureShallowCopy(target);
    target.copy.set(key, draft);
    return draft;
  },
  keys() {
    return latest(getProxyDraft(this)).keys();
  },
  values() {
    const iterator = this.keys();
    return {
      [iteratorSymbol]: () => this.values(),
      next: () => {
        const result = iterator.next();
        if (result.done)
          return result;
        const value = this.get(result.value);
        return {
          done: false,
          value
        };
      }
    };
  },
  entries() {
    const iterator = this.keys();
    return {
      [iteratorSymbol]: () => this.entries(),
      next: () => {
        const result = iterator.next();
        if (result.done)
          return result;
        const value = this.get(result.value);
        return {
          done: false,
          value: [result.value, value]
        };
      }
    };
  },
  [iteratorSymbol]() {
    return this.entries();
  }
};
const mapHandlerKeys = Reflect.ownKeys(mapHandler);
const getNextIterator = (target, iterator, { isValuesIterator }) => () => {
  var _a2, _b;
  const result = iterator.next();
  if (result.done)
    return result;
  const key = result.value;
  let value = target.setMap.get(key);
  const currentDraft = getProxyDraft(value);
  const mutable = ((_b = (_a2 = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a2, value, dataTypes)) === dataTypes.mutable;
  if (target.options.strict) {
    checkReadable(key, target.options, mutable);
  }
  if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
    const proxy = internal.createDraft({
      original: key,
      parentDraft: target,
      key,
      finalities: target.finalities,
      options: target.options
    });
    target.setMap.set(key, proxy);
    value = proxy;
  } else if (currentDraft) {
    value = currentDraft.proxy;
  }
  return {
    done: false,
    value: isValuesIterator ? value : [value, value]
  };
};
const setHandler = {
  get size() {
    const target = getProxyDraft(this);
    return target.setMap.size;
  },
  has(value) {
    const target = getProxyDraft(this);
    if (target.setMap.has(value))
      return true;
    ensureShallowCopy(target);
    const valueProxyDraft = getProxyDraft(value);
    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))
      return true;
    return false;
  },
  add(value) {
    const target = getProxyDraft(this);
    if (!this.has(value)) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(value, true);
      target.setMap.set(value, value);
      markFinalization(target, value, value, generatePatches);
    }
    return this;
  },
  delete(value) {
    if (!this.has(value)) {
      return false;
    }
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    const valueProxyDraft = getProxyDraft(value);
    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
      target.assignedMap.set(valueProxyDraft.original, false);
      return target.setMap.delete(valueProxyDraft.original);
    }
    if (!valueProxyDraft && target.setMap.has(value)) {
      target.assignedMap.set(value, false);
    } else {
      target.assignedMap.delete(value);
    }
    return target.setMap.delete(value);
  },
  clear() {
    if (!this.size)
      return;
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    for (const value of target.original) {
      target.assignedMap.set(value, false);
    }
    target.setMap.clear();
  },
  values() {
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    const iterator = target.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: getNextIterator(target, iterator, { isValuesIterator: true })
    };
  },
  entries() {
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    const iterator = target.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: getNextIterator(target, iterator, {
        isValuesIterator: false
      })
    };
  },
  keys() {
    return this.values();
  },
  [iteratorSymbol]() {
    return this.values();
  },
  forEach(callback, thisArg) {
    const iterator = this.values();
    let result = iterator.next();
    while (!result.done) {
      callback.call(thisArg, result.value, result.value, this);
      result = iterator.next();
    }
  }
};
if (Set.prototype.difference) {
  Object.assign(setHandler, {
    intersection(other) {
      return Set.prototype.intersection.call(new Set(this.values()), other);
    },
    union(other) {
      return Set.prototype.union.call(new Set(this.values()), other);
    },
    difference(other) {
      return Set.prototype.difference.call(new Set(this.values()), other);
    },
    symmetricDifference(other) {
      return Set.prototype.symmetricDifference.call(new Set(this.values()), other);
    },
    isSubsetOf(other) {
      return Set.prototype.isSubsetOf.call(new Set(this.values()), other);
    },
    isSupersetOf(other) {
      return Set.prototype.isSupersetOf.call(new Set(this.values()), other);
    },
    isDisjointFrom(other) {
      return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);
    }
  });
}
const setHandlerKeys = Reflect.ownKeys(setHandler);
const draftsCache = /* @__PURE__ */ new WeakSet();
const proxyHandler = {
  get(target, key, receiver) {
    var _a2, _b;
    const copy2 = (_a2 = target.copy) === null || _a2 === void 0 ? void 0 : _a2[key];
    if (copy2 && draftsCache.has(copy2)) {
      return copy2;
    }
    if (key === PROXY_DRAFT)
      return target;
    let markResult;
    if (target.options.mark) {
      const value2 = key === "size" && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
      markResult = target.options.mark(value2, dataTypes);
      if (markResult === dataTypes.mutable) {
        if (target.options.strict) {
          checkReadable(value2, target.options, true);
        }
        return value2;
      }
    }
    const source = latest(target);
    if (source instanceof Map && mapHandlerKeys.includes(key)) {
      if (key === "size") {
        return Object.getOwnPropertyDescriptor(mapHandler, "size").get.call(target.proxy);
      }
      const handle = mapHandler[key];
      if (handle) {
        return handle.bind(target.proxy);
      }
    }
    if (source instanceof Set && setHandlerKeys.includes(key)) {
      if (key === "size") {
        return Object.getOwnPropertyDescriptor(setHandler, "size").get.call(target.proxy);
      }
      const handle = setHandler[key];
      if (handle) {
        return handle.bind(target.proxy);
      }
    }
    if (!has(source, key)) {
      const desc = getDescriptor(source, key);
      return desc ? `value` in desc ? desc.value : (
        // !case: support for getter
        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)
      ) : void 0;
    }
    const value = source[key];
    if (target.options.strict) {
      checkReadable(value, target.options);
    }
    if (target.finalized || !isDraftable(value, target.options)) {
      return value;
    }
    if (value === peek(target.original, key)) {
      ensureShallowCopy(target);
      target.copy[key] = createDraft({
        original: target.original[key],
        parentDraft: target,
        key: target.type === 1 ? Number(key) : key,
        finalities: target.finalities,
        options: target.options
      });
      if (typeof markResult === "function") {
        const subProxyDraft = getProxyDraft(target.copy[key]);
        ensureShallowCopy(subProxyDraft);
        markChanged(subProxyDraft);
        return subProxyDraft.copy;
      }
      return target.copy[key];
    }
    return value;
  },
  set(target, key, value) {
    var _a2;
    if (target.type === 3 || target.type === 2) {
      throw new Error(`Map/Set draft does not support any property assignment.`);
    }
    let _key;
    if (target.type === 1 && key !== "length" && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
      throw new Error(`Only supports setting array indices and the 'length' property.`);
    }
    const desc = getDescriptor(latest(target), key);
    if (desc === null || desc === void 0 ? void 0 : desc.set) {
      desc.set.call(target.proxy, value);
      return true;
    }
    const current2 = peek(latest(target), key);
    const currentProxyDraft = getProxyDraft(current2);
    if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
      target.copy[key] = value;
      target.assignedMap = (_a2 = target.assignedMap) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Map();
      target.assignedMap.set(key, false);
      return true;
    }
    if (isEqual(value, current2) && (value !== void 0 || has(target.original, key)))
      return true;
    ensureShallowCopy(target);
    markChanged(target);
    if (has(target.original, key) && isEqual(value, target.original[key])) {
      target.assignedMap.delete(key);
    } else {
      target.assignedMap.set(key, true);
    }
    target.copy[key] = value;
    markFinalization(target, key, value, generatePatches);
    return true;
  },
  has(target, key) {
    return key in latest(target);
  },
  ownKeys(target) {
    return Reflect.ownKeys(latest(target));
  },
  getOwnPropertyDescriptor(target, key) {
    const source = latest(target);
    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
    if (!descriptor)
      return descriptor;
    return {
      writable: true,
      configurable: target.type !== 1 || key !== "length",
      enumerable: descriptor.enumerable,
      value: source[key]
    };
  },
  getPrototypeOf(target) {
    return Reflect.getPrototypeOf(target.original);
  },
  setPrototypeOf() {
    throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
  },
  defineProperty() {
    throw new Error(`Cannot call 'defineProperty()' on drafts`);
  },
  deleteProperty(target, key) {
    var _a2;
    if (target.type === 1) {
      return proxyHandler.set.call(this, target, key, void 0, target.proxy);
    }
    if (peek(target.original, key) !== void 0 || key in target.original) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(key, false);
    } else {
      target.assignedMap = (_a2 = target.assignedMap) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Map();
      target.assignedMap.delete(key);
    }
    if (target.copy)
      delete target.copy[key];
    return true;
  }
};
function createDraft(createDraftOptions) {
  const { original, parentDraft, key, finalities, options } = createDraftOptions;
  const type2 = getType(original);
  const proxyDraft = {
    type: type2,
    finalized: false,
    parent: parentDraft,
    original,
    copy: null,
    proxy: null,
    finalities,
    options,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: type2 === 3 ? new Map(original.entries()) : void 0
  };
  if (key || "key" in createDraftOptions) {
    proxyDraft.key = key;
  }
  const { proxy, revoke } = Proxy.revocable(type2 === 1 ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
  finalities.revoke.push(revoke);
  draftsCache.add(proxy);
  proxyDraft.proxy = proxy;
  if (parentDraft) {
    const target = parentDraft;
    target.finalities.draft.push((patches, inversePatches) => {
      var _a2, _b;
      const oldProxyDraft = getProxyDraft(proxy);
      let copy2 = target.type === 3 ? target.setMap : target.copy;
      const draft = get$1(copy2, key);
      const proxyDraft2 = getProxyDraft(draft);
      if (proxyDraft2) {
        let updatedValue = proxyDraft2.original;
        if (proxyDraft2.operated) {
          updatedValue = getValue(draft);
        }
        finalizeSetValue(proxyDraft2);
        finalizePatches(proxyDraft2, generatePatches, patches, inversePatches);
        if (target.options.enableAutoFreeze) {
          target.options.updatedValues = (_a2 = target.options.updatedValues) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new WeakMap();
          target.options.updatedValues.set(updatedValue, proxyDraft2.original);
        }
        set(copy2, key, updatedValue);
      }
      (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {
        callback(patches, inversePatches);
      });
    });
  } else {
    const target = getProxyDraft(proxy);
    target.finalities.draft.push((patches, inversePatches) => {
      finalizeSetValue(target);
      finalizePatches(target, generatePatches, patches, inversePatches);
    });
  }
  return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
  var _a2;
  const proxyDraft = getProxyDraft(result);
  const original = (_a2 = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a2 !== void 0 ? _a2 : result;
  const hasReturnedValue = !!returnedValue.length;
  if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
    while (proxyDraft.finalities.draft.length > 0) {
      const finalize = proxyDraft.finalities.draft.pop();
      finalize(patches, inversePatches);
    }
  }
  const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
  if (proxyDraft)
    revokeProxy(proxyDraft);
  if (enableAutoFreeze) {
    deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
  }
  return [
    state,
    patches && hasReturnedValue ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }] : patches,
    inversePatches && hasReturnedValue ? [{ op: Operation.Replace, path: [], value: original }] : inversePatches
  ];
}
function draftify(baseState, options) {
  var _a2;
  const finalities = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let patches;
  let inversePatches;
  if (options.enablePatches) {
    patches = [];
    inversePatches = [];
  }
  const isMutable = ((_a2 = options.mark) === null || _a2 === void 0 ? void 0 : _a2.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
  const draft = isMutable ? baseState : createDraft({
    original: baseState,
    parentDraft: null,
    finalities,
    options
  });
  return [
    draft,
    (returnedValue = []) => {
      const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
      return options.enablePatches ? [finalizedState, finalizedPatches, finalizedInversePatches] : finalizedState;
    }
  ];
}
function handleReturnValue(options) {
  const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
  forEach(value, (key, item, source) => {
    const proxyDraft = getProxyDraft(item);
    if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
      options.isContainDraft = true;
      const currentValue = proxyDraft.original;
      if (source instanceof Set) {
        const arr = Array.from(source);
        source.clear();
        arr.forEach((_item) => source.add(key === _item ? currentValue : _item));
      } else {
        set(source, key, currentValue);
      }
    } else if (typeof item === "object" && item !== null) {
      options.value = item;
      options.isRoot = false;
      handleReturnValue(options);
    }
  });
  if (isRoot) {
    if (!options.isContainDraft)
      console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
    if (useRawReturn) {
      console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
    }
  }
}
function getCurrent(target) {
  var _a2;
  const proxyDraft = getProxyDraft(target);
  if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))
    return target;
  const type2 = getType(target);
  if (proxyDraft && !proxyDraft.operated)
    return proxyDraft.original;
  let currentValue;
  function ensureShallowCopy2() {
    currentValue = type2 === 2 ? !isBaseMapInstance(target) ? new (Object.getPrototypeOf(target)).constructor(target) : new Map(target) : type2 === 3 ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
  }
  if (proxyDraft) {
    proxyDraft.finalized = true;
    try {
      ensureShallowCopy2();
    } finally {
      proxyDraft.finalized = false;
    }
  } else {
    currentValue = target;
  }
  forEach(currentValue, (key, value) => {
    if (proxyDraft && isEqual(get$1(proxyDraft.original, key), value))
      return;
    const newValue = getCurrent(value);
    if (newValue !== value) {
      if (currentValue === target)
        ensureShallowCopy2();
      set(currentValue, key, newValue);
    }
  });
  if (type2 === 3) {
    const value = (_a2 = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a2 !== void 0 ? _a2 : currentValue;
    return !isBaseSetInstance(value) ? new (Object.getPrototypeOf(value)).constructor(currentValue) : new Set(currentValue);
  }
  return currentValue;
}
function current(target) {
  if (!isDraft(target)) {
    throw new Error(`current() is only used for Draft, parameter: ${target}`);
  }
  return getCurrent(target);
}
const makeCreator = (arg) => {
  return function create2(arg0, arg1, arg2) {
    var _a2, _b, _c;
    if (typeof arg0 === "function" && typeof arg1 !== "function") {
      return function(base2, ...args) {
        return create2(base2, (draft2) => arg0.call(this, draft2, ...args), arg1);
      };
    }
    const base = arg0;
    const mutate = arg1;
    let options = arg2;
    if (typeof arg1 !== "function") {
      options = arg1;
    }
    if (options !== void 0 && Object.prototype.toString.call(options) !== "[object Object]") {
      throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
    }
    options = Object.assign(Object.assign({}, arg), options);
    const state = isDraft(base) ? current(base) : base;
    const mark = Array.isArray(options.mark) ? (value, types2) => {
      for (const mark2 of options.mark) {
        if (typeof mark2 !== "function") {
          throw new Error(`Invalid mark: ${mark2}, 'mark' should be a function.`);
        }
        const result2 = mark2(value, types2);
        if (result2) {
          return result2;
        }
      }
      return;
    } : options.mark;
    const enablePatches = (_a2 = options.enablePatches) !== null && _a2 !== void 0 ? _a2 : false;
    const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
    const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
    const _options = {
      enableAutoFreeze,
      mark,
      strict,
      enablePatches
    };
    if (!isDraftable(state, _options) && typeof state === "object" && state !== null) {
      throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
    }
    const [draft, finalize] = draftify(state, _options);
    if (typeof arg1 !== "function") {
      if (!isDraftable(state, _options)) {
        throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
      }
      return [draft, finalize];
    }
    let result;
    try {
      result = mutate(draft);
    } catch (error) {
      revokeProxy(getProxyDraft(draft));
      throw error;
    }
    const returnValue = (value) => {
      const proxyDraft = getProxyDraft(draft);
      if (!isDraft(value)) {
        if (value !== void 0 && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
          throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
        }
        const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
        if (rawReturnValue) {
          const _value = rawReturnValue[0];
          if (_options.strict && typeof value === "object" && value !== null) {
            handleReturnValue({
              rootDraft: proxyDraft,
              value,
              useRawReturn: true
            });
          }
          return finalize([_value]);
        }
        if (value !== void 0) {
          if (typeof value === "object" && value !== null) {
            handleReturnValue({ rootDraft: proxyDraft, value });
          }
          return finalize([value]);
        }
      }
      if (value === draft || value === void 0) {
        return finalize([]);
      }
      const returnedProxyDraft = getProxyDraft(value);
      if (_options === returnedProxyDraft.options) {
        if (returnedProxyDraft.operated) {
          throw new Error(`Cannot return a modified child draft.`);
        }
        return finalize([current(value)]);
      }
      return finalize([value]);
    };
    if (result instanceof Promise) {
      return result.then(returnValue, (error) => {
        revokeProxy(getProxyDraft(draft));
        throw error;
      });
    }
    return returnValue(result);
  };
};
const create = makeCreator();
Object.prototype.constructor.toString();
function castDraft(value) {
  return value;
}
var IntegrityIssueType;
(function(IntegrityIssueType2) {
  IntegrityIssueType2["UNEXPECTED_INDEX"] = "UNEXPECTED_INDEX";
})(IntegrityIssueType || (IntegrityIssueType = {}));
var IntegrityIssueSubType;
(function(IntegrityIssueSubType2) {
  IntegrityIssueSubType2["DUPLICATED_INDEX"] = "DUPLICATED_INDEX";
  IntegrityIssueSubType2["MISSING_INDEX"] = "MISSING_INDEX";
})(IntegrityIssueSubType || (IntegrityIssueSubType = {}));
function garbageCollect(sortedOperations) {
  var _a2, _b, _c;
  const result = [];
  let i = sortedOperations.length - 1;
  while (i > -1) {
    result.unshift(sortedOperations[i]);
    const skipUntil = (((_a2 = sortedOperations[i]) == null ? void 0 : _a2.index) || 0) - (((_b = sortedOperations[i]) == null ? void 0 : _b.skip) || 0) - 1;
    let j = i - 1;
    while (j > -1 && (((_c = sortedOperations[j]) == null ? void 0 : _c.index) || 0) > skipUntil) {
      j--;
    }
    i = j;
  }
  return result;
}
function sortOperations(operations) {
  return operations.slice().sort((a, b) => a.skip - b.skip).sort((a, b) => a.index - b.index);
}
function reshuffleByTimestamp(startIndex, opsA, opsB) {
  return [...opsA, ...opsB].sort((a, b) => new Date(a.timestamp || "").getTime() - new Date(b.timestamp || "").getTime()).map((op, i) => ({
    ...op,
    index: startIndex.index + i,
    skip: i === 0 ? startIndex.skip : 0
  }));
}
function operationsAreEqual(op1, op2) {
  return cjsModule(op1) === cjsModule(op2);
}
function attachBranch(trunk, newBranch) {
  const trunkCopy = garbageCollect(sortOperations(trunk.slice()));
  const newOperations = garbageCollect(sortOperations(newBranch.slice()));
  if (trunkCopy.length < 1) {
    return [newOperations, []];
  }
  const result = [];
  let enteredBranch = false;
  while (newOperations.length > 0) {
    const newOperationCandidate = newOperations[0];
    let nextTrunkOperation = trunkCopy.shift();
    while (nextTrunkOperation && precedes(nextTrunkOperation, newOperationCandidate)) {
      result.push(nextTrunkOperation);
      nextTrunkOperation = trunkCopy.shift();
    }
    if (!nextTrunkOperation) {
      enteredBranch = true;
    } else if (!enteredBranch) {
      if (operationsAreEqual(nextTrunkOperation, newOperationCandidate)) {
        newOperations.shift();
        result.push(nextTrunkOperation);
      } else {
        trunkCopy.unshift(nextTrunkOperation);
        enteredBranch = true;
      }
    }
    if (enteredBranch) {
      let nextAppend = newOperations.shift();
      while (nextAppend) {
        result.push(nextAppend);
        nextAppend = newOperations.shift();
      }
    }
  }
  if (!enteredBranch) {
    let nextAppend = trunkCopy.shift();
    while (nextAppend) {
      result.push(nextAppend);
      nextAppend = trunkCopy.shift();
    }
  }
  return [garbageCollect(result), trunkCopy];
}
function precedes(op1, op2) {
  return op1.index < op2.index || op1.index === op2.index && op1.id === op2.id && op1.skip < op2.skip;
}
function split$1(sortedTargetOperations, sortedMergeOperations) {
  const commonOperations = [];
  const targetDiffOperations = [];
  const mergeDiffOperations = [];
  const maxLength = Math.max(sortedTargetOperations.length, sortedMergeOperations.length);
  let splitHappened = false;
  for (let i = 0; i < maxLength; i++) {
    const targetOperation = sortedTargetOperations[i];
    const mergeOperation = sortedMergeOperations[i];
    if (targetOperation && mergeOperation) {
      if (!splitHappened && operationsAreEqual(targetOperation, mergeOperation)) {
        commonOperations.push(targetOperation);
      } else {
        splitHappened = true;
        targetDiffOperations.push(targetOperation);
        mergeDiffOperations.push(mergeOperation);
      }
    } else if (targetOperation) {
      targetDiffOperations.push(targetOperation);
    } else if (mergeOperation) {
      mergeDiffOperations.push(mergeOperation);
    }
  }
  return [commonOperations, targetDiffOperations, mergeDiffOperations];
}
function merge(sortedTargetOperations, sortedMergeOperations, reshuffle) {
  const [_commonOperations, _targetOperations, _mergeOperations] = split$1(garbageCollect(sortedTargetOperations), garbageCollect(sortedMergeOperations));
  const maxCommonIndex = getMaxIndex(_commonOperations);
  const nextIndex = 1 + Math.max(maxCommonIndex, getMaxIndex(_targetOperations), getMaxIndex(_mergeOperations));
  const filteredMergeOperations = filterDuplicatedOperations(_mergeOperations, _targetOperations);
  const newOperationHistory = reshuffle({
    index: nextIndex,
    skip: nextIndex - (maxCommonIndex + 1)
  }, _targetOperations, filteredMergeOperations);
  return _commonOperations.concat(newOperationHistory);
}
function getMaxIndex(sortedOperations) {
  const lastElement = sortedOperations[sortedOperations.length - 1];
  if (!lastElement) {
    return -1;
  }
  return lastElement.index;
}
function nextSkipNumber(sortedOperations) {
  var _a2, _b, _c;
  if (sortedOperations.length < 1) {
    return -1;
  }
  const cleanedOperations = garbageCollect(sortedOperations);
  let nextSkip = (((_a2 = cleanedOperations[cleanedOperations.length - 1]) == null ? void 0 : _a2.skip) || 0) + 1;
  if (cleanedOperations.length > 1) {
    nextSkip += ((_b = cleanedOperations[cleanedOperations.length - 2]) == null ? void 0 : _b.skip) || 0;
  }
  return (((_c = cleanedOperations[cleanedOperations.length - 1]) == null ? void 0 : _c.index) || -1) < nextSkip ? -1 : nextSkip;
}
function groupOperationsByScope(operations) {
  const result = operations.reduce((acc, operation) => {
    var _a2;
    if (!acc[operation.scope]) {
      acc[operation.scope] = [];
    }
    (_a2 = acc[operation.scope]) == null ? void 0 : _a2.push(operation);
    return acc;
  }, {});
  return result;
}
function removeExistingOperations(newOperations, operationsHistory) {
  return newOperations.filter((newOperation) => {
    return !operationsHistory.some((historyOperation) => {
      return newOperation.type === "NOOP" && newOperation.skip === 0 && newOperation.index === historyOperation.index || newOperation.index === historyOperation.index && newOperation.skip === historyOperation.skip && newOperation.scope === historyOperation.scope && newOperation.hash === historyOperation.hash && newOperation.type === historyOperation.type;
    });
  });
}
function skipHeaderOperations(operations, skipHeaderOperation) {
  const lastOperation = sortOperations(operations).at(-1);
  const lastIndex = (lastOperation == null ? void 0 : lastOperation.index) ?? -1;
  const nextIndex = lastIndex + 1;
  const skipOperationIndex = {
    ...skipHeaderOperation,
    index: skipHeaderOperation.index ?? nextIndex
  };
  if (skipOperationIndex.index < lastIndex) {
    throw new Error(`The skip header operation index must be greater than or equal to ${lastIndex}`);
  }
  const clearedOperations = garbageCollect(sortOperations([...operations, skipOperationIndex]));
  return clearedOperations.slice(0, -1);
}
function garbageCollectDocumentOperations(documentOperations) {
  const clearedOperations = Object.entries(documentOperations).reduce((acc, entry) => {
    const [scope, ops] = entry;
    return {
      ...acc,
      [scope]: garbageCollect(sortOperations(ops))
    };
  }, {});
  return clearedOperations;
}
function filterDuplicatedOperations(targetOperations, sourceOperations) {
  return targetOperations.filter((op) => {
    if (op.id) {
      return !sourceOperations.some((targetOp) => targetOp.id === op.id);
    }
    return true;
  });
}
function filterDocumentOperationsResultingState(documentOperations) {
  if (!documentOperations) {
    return {};
  }
  const entries = Object.entries(documentOperations);
  return entries.reduce((acc, [scope, operations]) => ({
    ...acc,
    [scope]: operations.map((op) => {
      const { resultingState, ...restProps } = op;
      return restProps;
    })
  }), {});
}
function diffOperations(clearedOperationsA, clearedOperationsB) {
  return clearedOperationsA.filter((operationA) => !clearedOperationsB.some((operationB) => operationA.index === operationB.index));
}
const isDefinedNonNullAny$2 = (v) => v !== void 0 && v !== null;
z.any().refine((v) => isDefinedNonNullAny$2(v));
const Load_StateSchema = z.enum(["LOAD_STATE"]);
const PruneSchema = z.enum(["PRUNE"]);
const RedoSchema = z.enum(["REDO"]);
const Set_NameSchema = z.enum(["SET_NAME"]);
const UndoSchema = z.enum(["UNDO"]);
function OperationScopeSchema$1() {
  return z.literal("global").or(z.literal("local"));
}
function DocumentActionSchema() {
  return z.union([
    LoadStateActionSchema(),
    PruneActionSchema(),
    RedoActionSchema(),
    SetNameActionSchema(),
    UndoActionSchema()
  ]);
}
function LoadStateActionSchema() {
  return z.object({
    input: z.lazy(() => LoadStateActionInputSchema()),
    type: Load_StateSchema,
    scope: OperationScopeSchema$1()
  });
}
function LoadStateActionInputSchema() {
  return z.object({
    operations: z.number(),
    state: z.lazy(() => LoadStateActionStateInputSchema())
  });
}
function LoadStateActionStateInputSchema() {
  return z.object({
    data: z.unknown().nullish(),
    name: z.string()
  });
}
function PruneActionSchema() {
  return z.object({
    input: z.lazy(() => PruneActionInputSchema()),
    type: PruneSchema,
    scope: OperationScopeSchema$1()
  });
}
function PruneActionInputSchema() {
  return z.object({
    end: z.number().nullish(),
    start: z.number().nullish()
  });
}
const RedoActionInputSchema = z.number;
function RedoActionSchema() {
  return z.object({
    input: RedoActionInputSchema(),
    type: RedoSchema,
    scope: OperationScopeSchema$1()
  });
}
const SetNameActionInputSchema = z.string;
function SetNameActionSchema() {
  return z.object({
    input: SetNameActionInputSchema(),
    type: Set_NameSchema,
    scope: z.literal("global")
  });
}
const UndoActionInputSchema = z.number;
function UndoActionSchema() {
  return z.object({
    input: UndoActionInputSchema(),
    type: UndoSchema,
    scope: OperationScopeSchema$1()
  });
}
const undo = (skip = 1, scope = "global") => createAction("UNDO", skip, void 0, UndoActionInputSchema, scope);
const redo = (count = 1, scope = "global") => createAction("REDO", count, void 0, RedoActionInputSchema, scope);
const loadState = (state, operations) => createAction("LOAD_STATE", { state, operations }, void 0, LoadStateActionInputSchema);
const noop$1 = (scope = "global") => createAction("NOOP", void 0, void 0, void 0, scope);
function setNameOperation(document, name2) {
  return { ...document, name: name2 };
}
function undoOperation(document, action, skip) {
  const { scope } = action;
  const defaultResult = {
    document,
    action,
    skip,
    reuseLastOperationIndex: false
  };
  return create(defaultResult, (draft) => {
    const operations = [...document.operations[scope]];
    const sortedOperations = sortOperations(operations);
    draft.action = noop$1(scope);
    const lastOperation = sortedOperations.at(-1);
    let nextIndex = (lastOperation == null ? void 0 : lastOperation.index) ?? -1;
    const isNewNoop = (lastOperation == null ? void 0 : lastOperation.type) !== "NOOP";
    if (isNewNoop) {
      nextIndex = nextIndex + 1;
    } else {
      draft.reuseLastOperationIndex = true;
    }
    const nextOperationHistory = isNewNoop ? [...sortedOperations, { index: nextIndex, skip: 0 }] : sortedOperations;
    draft.skip = nextSkipNumber(nextOperationHistory);
    if (lastOperation && draft.skip > lastOperation.skip + 1) {
      draft.skip = draft.skip + 1;
    }
    if (draft.skip < 0) {
      throw new Error(`Cannot undo: you can't undo more operations than the ones in the scope history`);
    }
  });
}
function redoOperation(document, action, skip) {
  const { scope, input } = action;
  const defaultResult = {
    document,
    action,
    skip,
    reuseLastOperationIndex: false
  };
  return create(defaultResult, (draft) => {
    if (draft.skip > 0) {
      throw new Error(`Cannot redo: skip value from reducer cannot be used with REDO action`);
    }
    if (typeof input !== "number" || input > 1) {
      throw new Error(`Cannot redo: you can only redo one operation at a time`);
    }
    if (typeof input !== "number" || input < 1) {
      throw new Error(`Invalid REDO action: invalid redo input value`);
    }
    if (draft.document.clipboard.length < 1) {
      throw new Error(`Cannot redo: no operations in the clipboard`);
    }
    const operationIndex = draft.document.clipboard.findLastIndex((op) => op.scope === scope);
    if (operationIndex < 0) {
      throw new Error(`Cannot redo: no operations in clipboard for scope "${scope}"`);
    }
    const operation = draft.document.clipboard.splice(operationIndex, 1)[0];
    draft.action = castDraft({
      type: operation.type,
      scope: operation.scope,
      input: operation.input
    });
  });
}
function pruneOperation(document, input, wrappedReducer) {
  const operations = document.operations.global;
  let { start, end } = input;
  start = start || 0;
  end = end || operations.length;
  const actionsToPrune = operations.slice(start, end);
  const actionsToKeepStart = operations.slice(0, start);
  const actionsToKeepEnd = operations.slice(end);
  const newDocument = replayOperations(document.initialState, {
    ...document.operations,
    global: actionsToKeepStart.concat(actionsToPrune)
  }, wrappedReducer);
  const { name: name2, state: newState } = newDocument;
  const loadStateIndex = actionsToKeepStart.length;
  const loadStateTimestamp = actionsToKeepStart.length ? actionsToKeepStart[actionsToKeepStart.length - 1].timestamp : actionsToKeepEnd.length ? actionsToKeepEnd[0].timestamp : (/* @__PURE__ */ new Date()).toISOString();
  return replayOperations(document.initialState, {
    ...document.operations,
    global: [
      ...actionsToKeepStart,
      {
        skip: 0,
        ...loadState({ name: name2, state: newState }, actionsToPrune.length),
        timestamp: loadStateTimestamp,
        index: loadStateIndex,
        hash: hashDocumentStateForScope({ state: newState }, "global")
      },
      ...actionsToKeepEnd.map((action, index) => ({
        ...action,
        index: loadStateIndex + index + 1
      }))
    ]
  }, wrappedReducer);
}
function loadStateOperation(oldDocument, newDocument) {
  return {
    ...oldDocument,
    name: newDocument.name,
    state: newDocument.state ?? { global: {}, local: {} }
  };
}
function generateId(method) {
  return generateUUID$1();
}
function getUnixTimestamp(date) {
  return (new Date(date).getTime() / 1e3).toFixed(0);
}
function buildOperationSignatureParams({ documentId, signer, operation, previousStateHash }) {
  const { timestamp, scope, id, type: type2 } = operation;
  return [
    getUnixTimestamp(timestamp),
    // timestamp,
    signer.app.key,
    // signer public key
    hash(
      // hash (docID, scope, operationID, operationName, operationInput)
      [documentId, scope, id, type2, cjsModule(operation.input)].join("")
    ),
    previousStateHash
    // state hash that the operation was applied to
  ];
}
const textEncode = new TextEncoder();
function buildOperationSignatureMessage(params) {
  const message = params.join("");
  const prefix = "Signed Operation:\n" + message.length.toString();
  return textEncode.encode(prefix + message);
}
function ab2hex(ab) {
  const view = ArrayBuffer.isView(ab) ? ab : new Uint8Array(ab);
  return Array.prototype.map.call(view, (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
async function buildOperationSignature(context, signMethod) {
  const params = buildOperationSignatureParams(context);
  const message = buildOperationSignatureMessage(params);
  const signature = await signMethod(message);
  return [...params, `0x${ab2hex(signature)}`];
}
async function buildSignedOperation(action, reducer2, document, context, signHandler) {
  var _a2, _b;
  const result = reducer2(document, action, void 0, {
    reuseHash: true,
    reuseOperationResultingState: true
  });
  const operation = result.operations[action.scope].at(-1);
  if (!operation) {
    throw new Error("Action was not applied");
  }
  const previousStateHash = ((_a2 = result.operations[action.scope].at(-2)) == null ? void 0 : _a2.hash) ?? "";
  const signature = await buildOperationSignature({
    ...context,
    operation,
    previousStateHash
  }, signHandler);
  return {
    ...operation,
    context: {
      ...operation.context,
      signer: {
        ...(_b = operation.context) == null ? void 0 : _b.signer,
        ...context.signer,
        signatures: [...context.signer.signatures ?? [], signature]
      }
    }
  };
}
function getNextRevision(document, operation) {
  var _a2;
  let latestOperationIndex;
  if ("index" in operation) {
    latestOperationIndex = operation.index;
  } else {
    latestOperationIndex = ((_a2 = document.operations[operation.scope].at(-1)) == null ? void 0 : _a2.index) ?? -1;
  }
  return (latestOperationIndex ?? -1) + 1;
}
function updateHeader(document, action) {
  return {
    ...document,
    revision: {
      ...document.revision,
      [action.scope]: getNextRevision(document, action)
    },
    lastModified: getDocumentLastModified(document)
  };
}
function updateOperations(document, actionOrOperation, skip = 0, reuseLastOperationIndex = false) {
  if ("type" in actionOrOperation && [UNDO, REDO, PRUNE].includes(actionOrOperation.type)) {
    return document;
  }
  const { scope } = actionOrOperation;
  const operations = document.operations[scope].slice();
  let operationId;
  const latestOperation = operations.at(-1);
  const lastOperationIndex = (latestOperation == null ? void 0 : latestOperation.index) ?? -1;
  let nextIndex = reuseLastOperationIndex ? lastOperationIndex : lastOperationIndex + 1;
  let timestamp = (/* @__PURE__ */ new Date()).toISOString();
  if ("index" in actionOrOperation) {
    if (actionOrOperation.index - skip > nextIndex) {
      throw new Error(`Missing operations: expected ${nextIndex} with skip 0 or equivalent, got index ${actionOrOperation.index} with skip ${skip}`);
    }
    nextIndex = actionOrOperation.index;
    operationId = actionOrOperation.id;
    timestamp = actionOrOperation.timestamp;
  } else {
    operationId = "id" in actionOrOperation ? actionOrOperation.id : generateId();
  }
  operations.push({
    ...actionOrOperation,
    id: operationId,
    index: nextIndex,
    timestamp,
    hash: "",
    scope,
    skip,
    error: void 0
  });
  return {
    ...document,
    operations: { ...document.operations, [scope]: operations }
  };
}
function updateDocument(document, action, skip = 0, reuseLastOperationIndex = false) {
  let newDocument = updateOperations(document, action, skip, reuseLastOperationIndex);
  newDocument = updateHeader(newDocument, action);
  return newDocument;
}
function _baseReducer(document, action, wrappedReducer) {
  const parsedAction = DocumentActionSchema().parse(action);
  switch (parsedAction.type) {
    case SET_NAME:
      return setNameOperation(document, parsedAction.input);
    case PRUNE:
      return pruneOperation(document, parsedAction.input, wrappedReducer);
    case LOAD_STATE:
      return loadStateOperation(document, parsedAction.input.state);
    default:
      return document;
  }
}
function processUndoRedo(document, action, skip) {
  switch (action.type) {
    case UNDO:
      return undoOperation(document, action, skip);
    case REDO:
      return redoOperation(document, action, skip);
    default:
      return { document, action, skip, reuseLastOperationIndex: false };
  }
}
function processSkipOperation(document, action, customReducer, skipValue, reuseOperationResultingState = false, resultingStateParser = parseResultingState) {
  const scope = action.scope;
  const latestOperation = document.operations[scope].at(-1);
  if (!latestOperation)
    return document;
  const documentOperations = garbageCollectDocumentOperations({
    ...document.operations,
    [scope]: skipHeaderOperations(document.operations[scope], latestOperation)
  });
  let scopeState = void 0;
  const lastRemainingOperation = documentOperations[scope].at(-1);
  if (reuseOperationResultingState && (lastRemainingOperation == null ? void 0 : lastRemainingOperation.resultingState)) {
    scopeState = resultingStateParser(lastRemainingOperation.resultingState);
  } else {
    const { state } = replayOperations(document.initialState, documentOperations, customReducer, void 0, void 0, void 0, void 0, {
      reuseOperationResultingState,
      operationResultingStateParser: resultingStateParser
    });
    scopeState = state[scope];
  }
  return {
    ...document,
    state: {
      ...document.state,
      [scope]: scopeState
    },
    operations: garbageCollectDocumentOperations({
      ...document.operations
    })
  };
}
function processUndoOperation(document, scope, customReducer, reuseOperationResultingState = false, resultingStateParser = parseResultingState) {
  const operations = [...document.operations[scope]];
  const sortedOperations = sortOperations(operations);
  sortedOperations.pop();
  const documentOperations = garbageCollectDocumentOperations({
    ...document.operations
  });
  const clearedOperations = [...documentOperations[scope]];
  const diff = diffOperations(garbageCollect(sortedOperations), clearedOperations);
  const doc = replayOperations(document.initialState, documentOperations, customReducer, void 0, void 0, void 0, void 0, {
    reuseOperationResultingState,
    operationResultingStateParser: resultingStateParser
  });
  const clipboard = sortOperations([...document.clipboard, ...diff].filter((op) => op.type !== "NOOP")).reverse();
  return { ...doc, clipboard };
}
function baseReducer(document, action, customReducer, dispatch, options = {}) {
  const { skip, ignoreSkipOperations = false, reuseHash = false, reuseOperationResultingState = false, operationResultingStateParser } = options;
  let _action = { ...action };
  let skipValue = skip || 0;
  let newDocument = {
    ...document
  };
  let reuseLastOperationIndex = false;
  const shouldProcessSkipOperation = !ignoreSkipOperations && (skipValue > 0 || "index" in _action && "skip" in _action && typeof _action.skip === "number" && _action.skip > 0);
  if (isUndoRedo(_action)) {
    const { skip: calculatedSkip, action: transformedAction, document: processedDocument, reuseLastOperationIndex: reuseIndex } = processUndoRedo(document, _action, skipValue);
    _action = transformedAction;
    skipValue = calculatedSkip;
    newDocument = processedDocument;
    reuseLastOperationIndex = reuseIndex;
  } else {
    newDocument = {
      ...newDocument,
      clipboard: []
    };
  }
  if (isDocumentAction(_action)) {
    newDocument = _baseReducer(newDocument, _action, customReducer);
  }
  newDocument = updateDocument(newDocument, _action, skipValue, reuseLastOperationIndex);
  const isUndoAction = isUndo(action);
  if (isUndoAction) {
    const result = processUndoOperation(newDocument, action.scope, customReducer);
    return result;
  }
  if (shouldProcessSkipOperation) {
    newDocument = processSkipOperation(newDocument, _action, customReducer, skipValue, reuseOperationResultingState, operationResultingStateParser);
  }
  newDocument = create(newDocument, (draft) => {
    try {
      const newState = customReducer(draft.state, _action, dispatch);
      if (newState) {
        unsafe(() => {
          draft.state = castDraft(newState);
        });
      } else {
      }
    } catch (error) {
      const lastOperationIndex = newDocument.operations[_action.scope].length - 1;
      draft.operations[_action.scope][lastOperationIndex].error = error.message;
      draft.operations[_action.scope][lastOperationIndex].skip = 0;
      if (shouldProcessSkipOperation) {
        draft.state = castDraft({
          ...document.state
        });
        draft.operations = castDraft({
          ...document.operations,
          [_action.scope]: [
            ...document.operations[_action.scope],
            {
              ...draft.operations[_action.scope][lastOperationIndex]
            }
          ]
        });
      }
    }
  });
  if ([UNDO, REDO, PRUNE].includes(_action.type)) {
    return newDocument;
  }
  const scope = _action.scope || "global";
  const hash2 = reuseHash && Object.prototype.hasOwnProperty.call(_action, "hash") ? _action.hash : hashDocumentStateForScope(newDocument, scope);
  const lastOperation = newDocument.operations[scope].at(-1);
  if (lastOperation) {
    lastOperation.hash = hash2;
    if (reuseOperationResultingState) {
      lastOperation.resultingState = JSON.stringify(newDocument.state[scope]);
    }
    if (!isDocumentAction(_action) && _action.attachments) {
      _action.attachments.forEach((attachment) => {
        const { hash: hash3, ...file } = attachment;
        if (!newDocument.attachments) {
          newDocument.attachments = {};
        }
        newDocument.attachments[hash3] = {
          ...file
        };
      });
    }
  }
  return newDocument;
}
class InvalidActionInputError extends Error {
  constructor(data) {
    super();
    __publicField(this, "data");
    this.name = "InvalidActionInputError";
    this.data = data;
    this.message = this.message || `Invalid action input: ${JSON.stringify(data, null, 2)}`;
  }
}
class InvalidActionInputZodError extends InvalidActionInputError {
  constructor(issues) {
    super(issues);
    __publicField(this, "issues");
    this.issues = issues;
    this.name = "InvalidActionInputZodError";
  }
}
function isUndoRedo(action) {
  return [UNDO, REDO].includes(action.type);
}
function isUndo(action) {
  return action.type === UNDO;
}
function isDocumentAction(action) {
  return [SET_NAME, UNDO, REDO, PRUNE, LOAD_STATE].includes(action.type);
}
function createAction(type2, input, attachments, validator, scope = "global") {
  if (!type2) {
    throw new Error("Empty action type");
  }
  if (typeof type2 !== "string") {
    throw new Error(`Invalid action type: ${JSON.stringify(type2)}`);
  }
  const action = {
    type: type2,
    input,
    scope
  };
  try {
    validator == null ? void 0 : validator().parse(action.input);
  } catch (error) {
    if (error instanceof ZodError) {
      throw new InvalidActionInputZodError(error.issues);
    } else {
      throw new InvalidActionInputError(error);
    }
  }
  return action;
}
function createReducer(stateReducer2, documentReducer = baseReducer) {
  const reducer2 = (document, action, dispatch, options) => {
    return documentReducer(document, action, stateReducer2, dispatch, options);
  };
  return reducer2;
}
function baseCreateExtendedState(initialState, createState2) {
  return {
    name: "",
    documentType: "",
    revision: {
      global: 0,
      local: 0
    },
    created: (/* @__PURE__ */ new Date()).toISOString(),
    lastModified: (/* @__PURE__ */ new Date()).toISOString(),
    attachments: {},
    ...initialState,
    state: (createState2 == null ? void 0 : createState2(initialState == null ? void 0 : initialState.state)) ?? ((initialState == null ? void 0 : initialState.state) ?? {
      global: {},
      local: {}
    })
  };
}
function baseCreateDocument(initialState, createState2) {
  const state = baseCreateExtendedState(initialState, createState2);
  return {
    ...state,
    initialState: state,
    operations: { global: [], local: [] },
    clipboard: []
  };
}
function hashDocumentStateForScope(document, scope = "global") {
  return hash(cjsModule(document.state[scope] || ""));
}
const hashKey = (date, randomLimit = 1e3) => {
  const random = Math.random() * randomLimit;
  return hash(`${(/* @__PURE__ */ new Date()).toISOString()}${random}`);
};
function getDocumentLastModified(document) {
  var _a2;
  const sortedOperations = sortOperations(Object.values(document.operations).flat());
  const timestamp = ((_a2 = sortedOperations.at(-1)) == null ? void 0 : _a2.timestamp) || document.initialState.lastModified;
  return timestamp;
}
function replayOperations(initialState, clearedOperations, stateReducer2, dispatch, header, documentReducer = baseReducer, skipHeaderOperations2 = {}, options) {
  const wrappedReducer = createReducer(stateReducer2, documentReducer);
  return replayDocument(initialState, clearedOperations, wrappedReducer, dispatch, header, skipHeaderOperations2, options);
}
function replayDocument(initialState, operations, reducer2, dispatch, header, skipHeaderOperations2 = {}, options) {
  const { checkHashes = true, reuseOperationResultingState, operationResultingStateParser = parseResultingState } = options || {};
  let documentState = initialState;
  const operationsToReplay = [];
  const initialOperations = {
    global: [],
    local: []
  };
  if (reuseOperationResultingState) {
    for (const [scope, scopeOperations] of Object.entries(operations)) {
      const index = scopeOperations.findLastIndex((s) => !!s.resultingState);
      if (index < 0) {
        operationsToReplay.push(...scopeOperations);
        continue;
      }
      const opWithState = scopeOperations[index];
      if (!opWithState.resultingState)
        continue;
      try {
        const scopeState = operationResultingStateParser(opWithState.resultingState);
        documentState = {
          ...documentState,
          state: {
            ...documentState.state,
            // TODO how to deal with attachments?
            [scope]: scopeState
          }
        };
        initialOperations[scope].push(...scopeOperations.slice(0, index + 1));
        operationsToReplay.push(...scopeOperations.slice(index + 1));
      } catch {
        operationsToReplay.push(...scopeOperations);
      }
    }
  } else {
    operationsToReplay.push(...Object.values(operations).flat());
  }
  const document = baseCreateDocument(documentState);
  document.initialState = initialState;
  document.operations = initialOperations;
  let result = document;
  if (operationsToReplay.length) {
    result = operationsToReplay.reduce((document2, operation) => {
      const doc = reducer2(document2, operation, dispatch, {
        skip: operation.skip,
        ignoreSkipOperations: true,
        reuseHash: !checkHashes
      });
      return doc;
    }, document);
  } else {
    for (const scopeOperations of Object.values(initialOperations)) {
      const lastOperation = scopeOperations.at(-1);
      if (lastOperation) {
        result = updateHeader(result, lastOperation);
      }
    }
  }
  if (!checkHashes) {
    for (const scope of Object.keys(result.state)) {
      for (let i = operationsToReplay.length - 1; i >= 0; i--) {
        const operation = operationsToReplay[i];
        if (operation.scope !== scope) {
          continue;
        }
        if (operation.hash !== hashDocumentStateForScope(result, scope)) {
          throw new Error(`Hash mismatch for scope ${scope}`);
        } else {
          break;
        }
      }
    }
  }
  const resultOperations = Object.keys(result.operations).reduce((acc, key) => {
    const scope = key;
    return {
      ...acc,
      [scope]: [
        ...result.operations[scope].map((operation, index) => {
          var _a2;
          return {
            ...operation,
            timestamp: ((_a2 = operations[scope][index]) == null ? void 0 : _a2.timestamp) ?? operation.timestamp
          };
        })
      ]
    };
  }, { global: [], local: [] });
  const lastModified = Object.values(resultOperations).reduce((acc, curr) => {
    const operation = curr.at(-1);
    if (operation && operation.timestamp > acc) {
      acc = operation.timestamp;
    }
    return acc;
  }, initialState.lastModified);
  return {
    ...result,
    operations: resultOperations,
    lastModified,
    meta: (header == null ? void 0 : header.meta) ?? {}
  };
}
function parseResultingState(state) {
  const stateType = typeof state;
  if (stateType === "string") {
    return JSON.parse(state);
  } else if (stateType === "object") {
    return state;
  } else {
    throw new Error(`Providing resulting state is of type: ${stateType}`);
  }
}
const isDefinedNonNullAny$1 = (v) => v !== void 0 && v !== null;
z.any().refine((v) => isDefinedNonNullAny$1(v));
function AddChangeLogItemInputSchema() {
  return z.object({
    __typename: z.literal("AddChangeLogItemInput").optional(),
    content: z.string(),
    id: z.string(),
    insertBefore: z.string().nullable()
  });
}
function AddModuleInputSchema() {
  return z.object({
    description: z.string().nullish(),
    id: z.string(),
    name: z.string()
  });
}
function AddOperationErrorInputSchema() {
  return z.object({
    errorCode: z.string().nullish(),
    errorDescription: z.string().nullish(),
    errorName: z.string().nullish(),
    errorTemplate: z.string().nullish(),
    id: z.string(),
    operationId: z.string()
  });
}
function AddOperationExampleInputSchema() {
  return z.object({
    example: z.string(),
    id: z.string(),
    operationId: z.string()
  });
}
function AddOperationInputSchema() {
  return z.object({
    description: z.string().nullish(),
    id: z.string(),
    moduleId: z.string(),
    name: z.string(),
    reducer: z.string().nullish(),
    schema: z.string().nullish(),
    template: z.string().nullish(),
    scope: OperationScopeSchema().nullish()
  });
}
function AddStateExampleInputSchema() {
  return z.object({
    scope: z.string(),
    example: z.string(),
    id: z.string(),
    insertBefore: z.string().nullish()
  });
}
function DeleteChangeLogItemInputSchema() {
  return z.object({
    __typename: z.literal("DeleteChangeLogItemInput").optional(),
    id: z.string()
  });
}
function DeleteModuleInputSchema() {
  return z.object({
    id: z.string()
  });
}
function DeleteOperationErrorInputSchema() {
  return z.object({
    id: z.string()
  });
}
function DeleteOperationExampleInputSchema() {
  return z.object({
    id: z.string()
  });
}
function DeleteOperationInputSchema() {
  return z.object({
    id: z.string()
  });
}
function DeleteStateExampleInputSchema() {
  return z.object({
    scope: z.string(),
    id: z.string()
  });
}
function OperationScopeSchema() {
  return z.literal("global").or(z.literal("local"));
}
function MoveOperationInputSchema() {
  return z.object({
    newModuleId: z.string(),
    operationId: z.string()
  });
}
function ReorderChangeLogItemsInputSchema() {
  return z.object({
    __typename: z.literal("ReorderChangeLogItemsInput").optional(),
    order: z.array(z.string())
  });
}
function ReorderModuleOperationsInputSchema() {
  return z.object({
    moduleId: z.string(),
    order: z.array(z.string())
  });
}
function ReorderModulesInputSchema() {
  return z.object({
    order: z.array(z.string())
  });
}
function ReorderOperationErrorsInputSchema() {
  return z.object({
    operationId: z.string(),
    order: z.array(z.string())
  });
}
function ReorderOperationExamplesInputSchema() {
  return z.object({
    operationId: z.string(),
    order: z.array(z.string())
  });
}
function ReorderStateExamplesInputSchema() {
  return z.object({
    scope: z.string(),
    order: z.array(z.string())
  });
}
function SetAuthorNameInputSchema() {
  return z.object({
    authorName: z.string()
  });
}
function SetAuthorWebsiteInputSchema() {
  return z.object({
    authorWebsite: z.string()
  });
}
function SetInitialStateInputSchema() {
  return z.object({
    scope: z.string(),
    initialValue: z.string()
  });
}
function SetModelDescriptionInputSchema() {
  return z.object({
    description: z.string()
  });
}
function SetModelExtensionInputSchema() {
  return z.object({
    extension: z.string()
  });
}
function SetModelIdInputSchema() {
  return z.object({
    id: z.string()
  });
}
function SetModelNameInputSchema() {
  return z.object({
    name: z.string()
  });
}
function SetModuleDescriptionInputSchema() {
  return z.object({
    description: z.string().nullish(),
    id: z.string()
  });
}
function SetModuleNameInputSchema() {
  return z.object({
    id: z.string(),
    name: z.string().nullish()
  });
}
function SetOperationDescriptionInputSchema() {
  return z.object({
    description: z.string().nullish(),
    id: z.string()
  });
}
function SetOperationErrorCodeInputSchema() {
  return z.object({
    errorCode: z.string().nullish(),
    id: z.string()
  });
}
function SetOperationErrorDescriptionInputSchema() {
  return z.object({
    errorDescription: z.string().nullish(),
    id: z.string()
  });
}
function SetOperationErrorNameInputSchema() {
  return z.object({
    errorName: z.string().nullish(),
    id: z.string()
  });
}
function SetOperationErrorTemplateInputSchema() {
  return z.object({
    errorTemplate: z.string().nullish(),
    id: z.string()
  });
}
function SetOperationNameInputSchema() {
  return z.object({
    id: z.string(),
    name: z.string().nullish()
  });
}
function SetOperationScopeInputSchema() {
  return z.object({
    id: z.string(),
    scope: OperationScopeSchema()
  });
}
function SetOperationReducerInputSchema() {
  return z.object({
    id: z.string(),
    reducer: z.string().nullish()
  });
}
function SetOperationSchemaInputSchema() {
  return z.object({
    id: z.string(),
    schema: z.string().nullish()
  });
}
function SetOperationTemplateInputSchema() {
  return z.object({
    id: z.string(),
    template: z.string().nullish()
  });
}
function SetStateSchemaInputSchema() {
  return z.object({
    scope: z.string(),
    schema: z.string()
  });
}
function UpdateChangeLogItemInputSchema() {
  return z.object({
    __typename: z.literal("UpdateChangeLogItemInput").optional(),
    id: z.string(),
    newContent: z.string()
  });
}
function UpdateOperationExampleInputSchema() {
  return z.object({
    example: z.string(),
    id: z.string()
  });
}
function UpdateStateExampleInputSchema() {
  return z.object({
    scope: z.string(),
    id: z.string(),
    newExample: z.string()
  });
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
var hasRequiredJszip_min;
function requireJszip_min() {
  if (hasRequiredJszip_min) return jszip_min.exports;
  hasRequiredJszip_min = 1;
  (function(module, exports) {
    !function(e) {
      module.exports = e();
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && t2) return t2(r, true);
              if (l) return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t3 = a[r][1][e3];
              return u(t3 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++) u(h[e]);
        return u;
      }({ 1: [function(e, t2, r) {
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t3, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t3 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t3 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t3 >> 2, s = (3 & t3) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t3, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t3 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t3, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t2, r) {
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t3, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t3, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t3 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t3.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t3, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t3.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t3);
        }, t2.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t2, r) {
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t2, r) {
        var n = e("./utils");
        var o = function() {
          for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t3[r2] = e2;
          }
          return t3;
        }();
        t2.exports = function(e2, t3) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t4, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4[a])];
            return -1 ^ e3;
          }(0 | t3, e2, e2.length, 0) : function(e3, t4, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t3, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t2, r) {
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t2, r) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t2.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t2, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t3) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t3, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t3 = this;
          this._pako.onData = function(e2) {
            t3.push({ data: e2, meta: t3.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t2, r) {
        function A(e2, t3) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t3; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t3, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t3 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t3 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z2 = 0, C = 0;
          w && (z2 |= 16), "UNIX" === i2 ? (C = 798, z2 |= function(e3, t4) {
            var r3 = e3;
            return e3 || (r3 = t4 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z2 |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z2, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t3, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t3 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t3 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t3 = this.streamFiles && !e2.file.dir;
          if (t3) {
            var r2 = n(e2, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t3 = this.streamFiles && !e2.file.dir, r2 = n(e2, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t3) this.push({ data: function(e3) {
            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          }(e2), meta: { percent: 100 } });
          else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++) this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t4, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t4, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t3 = this;
          return e2.on("data", function(e3) {
            t3.processChunk(e3);
          }), e2.on("end", function() {
            t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
          }), e2.on("error", function(e3) {
            t3.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t3 = this._sources;
          if (!i.prototype.error.call(this, e2)) return false;
          for (var r2 = 0; r2 < t3.length; r2++) try {
            t3[r2].error(e2);
          } catch (e3) {
          }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t3 = 0; t3 < e2.length; t3++) e2[t3].lock();
        }, t2.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t2, r) {
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t3) {
          var o = new n(a.streamFiles, t3, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t4) {
              h++;
              var r2 = function(e4, t5) {
                var r3 = e4 || t5, n3 = u[r3];
                if (!n3) throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t4.options.compression, a.compression), n2 = t4.options.compressionOptions || a.compressionOptions || {}, i = t4.dir, s = t4.date;
              t4._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t2, r) {
        function n() {
          if (!(this instanceof n)) return new n();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t3 in this) "function" != typeof this[t3] && (e2[t3] = this[t3]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t3) {
          return new n().loadAsync(e2, t3);
        }, n.external = e("./external"), t2.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t2, r) {
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t3) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t3(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t2.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t3 = new s(o);
            return t3.load(e3), t3;
          }).then(function(e3) {
            var t3 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t3.push(f(r2[n2]));
            return i.Promise.all(t3);
          }).then(function(e3) {
            for (var t3 = e3.shift(), r2 = t3.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t3.zipComment.length && (h.comment = t3.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t2, r) {
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t3) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t3);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t3 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t3.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t3.isPaused ? this.generatedError = e3 : t3.error(e3);
          }).on("end", function() {
            t3.isPaused ? t3._upstreamEnded = true : t3.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t2, r) {
        var i = e("readable-stream").Readable;
        function n(e2, t3, r2) {
          i.call(this, t3), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t4) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t4);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t2, r) {
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t3) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t3);
          if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t3);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc) return Buffer.alloc(e2);
          var t3 = new Buffer(e2);
          return t3.fill(0), t3;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t2, r) {
        function s(e2, t3, r2) {
          var n2, i2 = u.getTypeOf(t3), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t3 instanceof c && 0 === t3.uncompressedSize || s2.dir || !t3 || 0 === t3.length) && (s2.base64 = false, s2.binary = true, t3 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t3 instanceof c || t3 instanceof l ? t3 : p.isNode && p.isStream(t3) ? new m(e2, t3) : u.prepareContent(e2, t3, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t3 = e2.lastIndexOf("/");
          return 0 < t3 ? e2.substring(0, t3) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t3) {
          return t3 = void 0 !== t3 ? t3 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t3 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t3, r2, n2;
          for (t3 in this.files) n2 = this.files[t3], (r2 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t3) {
            r2(e2, t3) && n2.push(t3);
          }), n2;
        }, file: function(e2, t3, r2) {
          if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t3, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t4) {
              return !t4.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2) return this;
          if (h(r2)) return this.filter(function(e3, t4) {
            return t4.dir && r2.test(e3);
          });
          var e2 = this.root + r2, t3 = b.call(this, e2), n2 = this.clone();
          return n2.root = t3.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];
          else for (var t3 = this.filter(function(e3, t4) {
            return t4.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t3.length; n2++) delete this.files[t3[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t3, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t3 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t3 = new l("error")).error(e3);
          }
          return new a(t3, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t3) {
          return this.generateInternalStream(e2).accumulate(t3);
        }, generateNodeStream: function(e2, t3) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t3);
        } };
        t2.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t2, r) {
        t2.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t2, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t3 = 0; t3 < this.data.length; t3++) e2[t3] = 255 & e2[t3];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t3 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t3 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return [];
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t2, r) {
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t3, r2 = 0;
          for (this.checkOffset(e2), t3 = this.index + e2 - 1; t3 >= this.index; t3--) r2 = (r2 << 8) + this.byteAt(t3);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t2.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t2, r) {
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t2, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t2, r) {
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
          var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t3;
        }, t2.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t2, r) {
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t2.exports = function(e2) {
          var t3 = n.getTypeOf(e2);
          return n.checkSupport(t3), "string" !== t3 || i.uint8array ? "nodebuffer" === t3 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t2, r) {
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t2, r) {
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t2.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t2, r) {
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t2.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t2, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t3 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t3 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t2.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t2, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t3 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t3.dataIsReady = true, t3.data = e3, t3.max = e3 && e3.length || 0, t3.type = n.getTypeOf(e3), t3.isPaused || t3._tickAndRepeat();
          }, function(e3) {
            t3.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e2 = null, t3 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t3);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t3);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t3);
          }
          return this.index = t3, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t2, r) {
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t3) {
          return this._listeners[e2].push(t3), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t3) {
          if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t3);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t3 = this;
          return e2.on("data", function(e3) {
            t3.processChunk(e3);
          }), e2.on("end", function() {
            t3.end();
          }), e2.on("error", function(e3) {
            t3.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t3) {
          return this.extraStreamInfo[e2] = t3, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t2.exports = n;
      }, {}], 29: [function(e, t2, r) {
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream) try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
        function l(e2, o2) {
          return new a.Promise(function(t3, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t4) {
              n2.push(e3), o2 && o2(t4);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t4, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t4), r3);
                    case "base64":
                      return u.encode(t4);
                    default:
                      return h.transformTo(e4, t4);
                  }
                }(s2, function(e4, t4) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t4.length; r3++) s3 += t4[r3].length;
                  switch (e4) {
                    case "string":
                      return t4.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t4);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t4.length; r3++) i3.set(t4[r3], n3), n3 += t4[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t4);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t3(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t3, r2) {
          var n2 = t3;
          switch (t3) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t3, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t3) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t3.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t3, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t2.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t2, r) {
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t2, s) {
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t3, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t3 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
            return t3;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t3, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t3 = r2 = 0; t3 < s2; ) if ((n2 = e3[t3++]) < 128) a2[r2++] = n2;
            else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t3 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t3 < s2; ) n2 = n2 << 6 | 63 & e3[t3++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t3 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t3;
              (t3 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r2, this.leftOver.length);
            } else t3 = this.leftOver.concat(t3);
            this.leftOver = null;
          }
          var n2 = function(e3, t4) {
            var r3;
            for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
            return r3 < 0 ? t4 : 0 === r3 ? t4 : r3 + u[e3[r3]] > t4 ? r3 : t4;
          }(t3), i2 = t3;
          n2 !== t3.length && (h.uint8array ? (i2 = t3.subarray(0, n2), this.leftOver = t3.subarray(n2, t3.length)) : (i2 = t3.slice(0, n2), this.leftOver = t3.slice(n2, t3.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t2, a) {
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t3) {
          for (var r2 = 0; r2 < e2.length; ++r2) t3[r2] = 255 & e2.charCodeAt(r2);
          return t3;
        }
        e("setimmediate"), a.newBlob = function(t3, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t3], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t3), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t3, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2) return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; ) "array" === t3 || "nodebuffer" === t3 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t3 = "", r2 = 0; r2 < e2.length; r2++) t3 += String.fromCharCode(e2[r2]);
          return t3;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t3 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t3; ) try {
            return i.stringifyByChunk(e2, r2, t3);
          } catch (e3) {
            t3 = Math.floor(t3 / 2);
          }
          return i.stringifyByChar(e2);
        }
        function f(e2, t3) {
          for (var r2 = 0; r2 < e2.length; r2++) t3[r2] = e2[r2];
          return t3;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t3) {
          if (t3 = t3 || "", !e2) return t3;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t3);
          return c[r2][e2](t3);
        }, a.resolve = function(e2) {
          for (var t3 = e2.split("/"), r2 = [], n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t3.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t3, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++) n2 += "\\x" + ((t3 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t3, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t3 || []);
          });
        }, a.inherits = function(e2, t3) {
          function r2() {
          }
          r2.prototype = t3.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t3, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++) for (t3 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t3) && void 0 === r2[t3] && (r2[t3] = arguments[e2][t3]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t3, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t3(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t3 = a.getTypeOf(e3);
            return t3 ? ("arraybuffer" === t3 ? e3 = a.transformTo("uint8array", e3) : "string" === t3 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t2, r) {
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t3 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t3) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t3) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t3;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t3 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t3, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t3, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t3 = this.reader.readInt(4), r2 = this.reader.readData(t3), this.zip64ExtensibleData[e2] = { id: e2, length: t3, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t3;
          for (e2 = 0; e2 < this.files.length; e2++) t3 = this.files[e2], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t3 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t3 - r2;
          if (0 < n2) this.isSignature(t3, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t2, r) {
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t3) {
          this.options = e2, this.loadOptions = t3;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t3, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t3 = function(e3) {
            for (var t4 in h) if (Object.prototype.hasOwnProperty.call(h, t4) && h[t4].magic === e3) return h[t4];
            return null;
          }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t3, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t3 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e2.skip(t3), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t3, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t3 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t3] = { id: t3, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t3 = this.findExtraFieldUnicodePath();
            if (null !== t3) this.fileNameStr = t3;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2) this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t3 = n(e2.value);
            return 1 !== t3.readInt(1) ? null : a(this.fileName) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t3 = n(e2.value);
            return 1 !== t3.readInt(1) ? null : a(this.fileComment) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
          }
          return null;
        } }, t2.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t2, r) {
        function n(e2, t3, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t3, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t3 = null, r2 = "string";
          try {
            if (!e2) throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t3 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t3 = t3.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t3 = t3.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t3 = new h("error")).error(e3);
          }
          return new s(t3, r2, "");
        }, async: function(e2, t3) {
          return this.internalStream(e2).accumulate(t3);
        }, nodeStream: function(e2, t3) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t3);
        }, _compressWorker: function(e2, t3) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t3);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;
        t2.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t2) {
        (function(t3) {
          var r, n, e2 = t3.MutationObserver || t3.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t3.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t3.setImmediate || void 0 === t3.MessageChannel) r = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
            var e3 = t3.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t3.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
          else {
            var o = new t3.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t4;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t4 = h, h = [], e3 = -1; ++e3 < r2; ) t4[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t2, r) {
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2) throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t3, r2) {
          this.promise = e2, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t3, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t3, e3);
            }
            e2 === t3 ? l.reject(t3, new TypeError("Cannot resolve promise with itself")) : l.resolve(t3, e2);
          });
        }
        function c(e2) {
          var t3 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t3) return function() {
            t3.apply(e2, arguments);
          };
        }
        function d(t3, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t3, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t3, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t3) {
          var r2 = {};
          try {
            r2.value = e2(t3), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t2.exports = o).prototype.finally = function(t3) {
          if ("function" != typeof t3) return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t3()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t3()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t3) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t3 && this.state === s) return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t3, this.outcome) : this.queue.push(new h(r2, e2, t3));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t3) {
          var r2 = p(c, t3);
          if ("error" === r2.status) return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2) d(e2, n2);
          else {
            e2.state = a, e2.outcome = t3;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t3);
          }
          return e2;
        }, l.reject = function(e2, t3) {
          e2.state = s, e2.outcome = t3;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t3);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this) return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t3 = new this(u);
          return l.reject(t3, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2) return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t3 = -1, o2 = new this(u);
          for (; ++t3 < n2; ) h2(e2[t3], t3);
          return o2;
          function h2(e3, t4) {
            r2.resolve(e3).then(function(e4) {
              s2[t4] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2) return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; ) a2 = e2[i2], t3.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t2, r) {
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t2.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t2, r) {
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p)) return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t3 = this.options;
          t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (r2 !== l) throw new Error(i[r2]);
          if (t3.header && a.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var n2;
            if (n2 = "string" == typeof t3.dictionary ? h.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t3) {
          var r2 = new p(t3);
          if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t3) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended) return false;
          n2 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t3) {
          return (t3 = t3 || {}).raw = true, n(e2, t3);
        }, r.gzip = function(e2, t3) {
          return (t3 = t3 || {}).gzip = true, n(e2, t3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t2, r) {
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a)) return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t3 = this.options;
          t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e2 && e2.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t3.windowBits);
          if (r2 !== m.Z_OK) throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t3) {
          var r2 = new a(t3);
          if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t3) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended) return false;
          n2 = t3 === ~~t3 ? t3 : true === t3 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t3) {
          return (t3 = t3 || {}).raw = true, o(e2, t3);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t2, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var r2 = t3.shift();
            if (r2) {
              if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t3) {
          return e2.length === t3 ? e2 : e2.subarray ? e2.subarray(0, t3) : (e2.length = t3, e2);
        };
        var i = { arraySet: function(e2, t3, r2, n2, i2) {
          if (t3.subarray && e2.subarray) e2.set(t3.subarray(r2, r2 + n2), i2);
          else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t3[r2 + s2];
        }, flattenChunks: function(e2) {
          var t3, r2, n2, i2, s2, a;
          for (t3 = n2 = 0, r2 = e2.length; t3 < r2; t3++) n2 += e2[t3].length;
          for (a = new Uint8Array(n2), t3 = i2 = 0, r2 = e2.length; t3 < r2; t3++) s2 = e2[t3], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t3, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t3[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t2, r) {
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t3) {
          if (t3 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e2, t3));
          for (var r2 = "", n2 = 0; n2 < t3; n2++) r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t3, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t3 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
          return t3;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t3 = new h.Buf8(e2.length), r2 = 0, n2 = t3.length; r2 < n2; r2++) t3[r2] = e2.charCodeAt(r2);
          return t3;
        }, r.buf2string = function(e2, t3) {
          var r2, n2, i2, s2, a = t3 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;
          else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
          return l(o, n2);
        }, r.utf8border = function(e2, t3) {
          var r2;
          for ((t3 = t3 || e2.length) > e2.length && (t3 = e2.length), r2 = t3 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;
          return r2 < 0 ? t3 : 0 === r2 ? t3 : r2 + u[e2[r2]] > t3 ? r2 : t3;
        };
      }, { "./common": 41 }], 43: [function(e, t2, r) {
        t2.exports = function(e2, t3, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t3[n++] | 0) | 0, --a; ) ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t2, r) {
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t2, r) {
        var o = function() {
          for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t3[r2] = e2;
          }
          return t3;
        }();
        t2.exports = function(e2, t3, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t3[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t2, r) {
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z2 = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t3) {
          return e2.msg = n[t3], t3;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t3 = e2.length; 0 <= --t3; ) e2[t3] = 0;
        }
        function F(e2) {
          var t3 = e2.state, r2 = t3.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t3.pending_buf, t3.pending_out, r2, e2.next_out), e2.next_out += r2, t3.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t3.pending -= r2, 0 === t3.pending && (t3.pending_out = 0));
        }
        function N(e2, t3) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t3), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t3) {
          e2.pending_buf[e2.pending++] = t3;
        }
        function P(e2, t3) {
          e2.pending_buf[e2.pending++] = t3 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t3;
        }
        function L(e2, t3) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z2 ? e2.strstart - (e2.w_size - z2) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t3) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t3, o2 <= (a2 = n2)) break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t3 = f2[t3 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t3, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z2)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t3 = r2 = e2.hash_size; n2 = e2.head[--t3], e2.head[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              for (t3 = r2 = f2; n2 = e2.prev[--t3], e2.prev[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in) break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
          } while (e2.lookahead < z2 && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t3) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z2) {
              if (j(e2), e2.lookahead < z2 && t3 === l) return A;
              if (0 === e2.lookahead) break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
              e2.strstart++;
            } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W2(e2, t3) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z2) {
              if (j(e2), e2.lookahead < z2 && t3 === l) return A;
              if (0 === e2.lookahead) break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
            } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M2(e2, t3, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t3, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t3;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t3 = e2.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C : E, e2.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l, u._tr_init(t3), m) : R(e2, _);
        }
        function K2(e2) {
          var t3 = G(e2);
          return t3 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t3;
        }
        function Y(e2, t3, r2, n2, i2, s2) {
          if (!e2) return _;
          var a2 = 1;
          if (t3 === g && (t3 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t3 < 0 || 9 < t3 || s2 < 0 || b < s2) return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = s2, o2.method = r2, K2(e2);
        }
        h = [new M2(0, 0, 0, 0, function(e2, t3) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t3 === l) return A;
              if (0 === e2.lookahead) break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = 0, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M2(4, 4, 8, 4, Z), new M2(4, 5, 16, 8, Z), new M2(4, 6, 32, 32, Z), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r.deflateInit = function(e2, t3) {
          return Y(e2, t3, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K2, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t3) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t3, m) : _;
        }, r.deflate = function(e2, t3) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t3 || t3 < 0) return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t3 !== f) return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t3, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
          }
          if (69 === n2.status) if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else n2.status = 73;
          if (73 === n2.status) if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else n2.status = 91;
          if (91 === n2.status) if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t3) <= T(r2) && t3 !== f) return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t3 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t4) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t4 === l) return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t4 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t3) : 3 === n2.strategy ? function(e3, t4) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t4 === l) return A;
                  if (0 === e3.lookahead) break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t4 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t3) : h[n2.level].func(n2, t3);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t3 ? u._tr_align(n2) : 5 !== t3 && (u._tr_stored_block(n2, 0, 0, false), 3 === t3 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;
          }
          return t3 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t3;
          return e2 && e2.state ? (t3 = e2.state.status) !== C && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E && 666 !== t3 ? R(e2, _) : (e2.state = null, t3 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t3) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t3.length;
          if (!e2 || !e2.state) return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t3, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t3, l2 - r2.w_size, r2.w_size, 0), t3 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t3, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t2, r) {
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t2, r) {
        t2.exports = function(e2, t3) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z2, C;
          r2 = e2.state, n = e2.next_in, z2 = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t3 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e: do {
            p < 15 && (d += z2[n++] << p, p += 8, d += z2[n++] << p, p += 8), v = m[d & g];
            t: for (; ; ) {
              if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
              else {
                if (!(16 & y)) {
                  if (0 == (64 & y)) {
                    v = m[(65535 & v) + (d & (1 << y) - 1)];
                    continue t;
                  }
                  if (32 & y) {
                    r2.mode = 12;
                    break e;
                  }
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break e;
                }
                w = 65535 & v, (y &= 15) && (p < y && (d += z2[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z2[n++] << p, p += 8, d += z2[n++] << p, p += 8), v = _[d & b];
                r: for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                    if (0 == (64 & y)) {
                      v = _[(65535 & v) + (d & (1 << y) - 1)];
                      continue r;
                    }
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break e;
                  }
                  if (k = 65535 & v, p < (y &= 15) && (d += z2[n++] << p, (p += 8) < y && (d += z2[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break e;
                  }
                  if (d >>>= y, p -= y, (y = s - a) < k) {
                    if (l < (y = k - y) && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break e;
                    }
                    if (S = c, (x = 0) === f) {
                      if (x += u - y, y < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        x = s - k, S = C;
                      }
                    } else if (f < y) {
                      if (x += u + f - y, (y -= f) < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        if (x = 0, f < w) {
                          for (w -= y = f; C[s++] = c[x++], --y; ) ;
                          x = s - k, S = C;
                        }
                      }
                    } else if (x += f - y, y < w) {
                      for (w -= y; C[s++] = c[x++], --y; ) ;
                      x = s - k, S = C;
                    }
                    for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                    w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                  } else {
                    for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                    w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t2, r) {
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t3;
          return e2 && e2.state ? (t3 = e2.state, e2.total_in = e2.total_out = t3.total = 0, e2.msg = "", t3.wrap && (e2.adler = 1 & t3.wrap), t3.mode = P, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I.Buf32(n), t3.distcode = t3.distdyn = new I.Buf32(i), t3.sane = 1, t3.back = -1, N) : U;
        }
        function o(e2) {
          var t3;
          return e2 && e2.state ? ((t3 = e2.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a(e2)) : U;
        }
        function h(e2, t3) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t3 < 0 ? (r2 = 0, t3 = -t3) : (r2 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U : (null !== n2.window && n2.wbits !== t3 && (n2.window = null), n2.wrap = r2, n2.wbits = t3, o(e2))) : U;
        }
        function u(e2, t3) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t3)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t3;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t3 = 0; t3 < 144; ) e2.lens[t3++] = 8;
            for (; t3 < 256; ) e2.lens[t3++] = 9;
            for (; t3 < 280; ) e2.lens[t3++] = 7;
            for (; t3 < 288; ) e2.lens[t3++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; ) e2.lens[t3++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t3, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t3, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t3, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t3, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t3) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z2, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e: for (; ; ) switch (r2.mode) {
            case P:
              if (0 === r2.wrap) {
                r2.mode = 13;
                break;
              }
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (2 & r2.wrap && 35615 === u2) {
                E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                break;
              }
              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e2.msg = "incorrect header check", r2.mode = 30;
                break;
              }
              if (8 != (15 & u2)) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
              else if (k > r2.wbits) {
                e2.msg = "invalid window size", r2.mode = 30;
                break;
              }
              r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
              break;
            case 2:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.flags = u2, 8 != (255 & r2.flags)) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (57344 & r2.flags) {
                e2.msg = "unknown header flags set", r2.mode = 30;
                break;
              }
              r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
            case 3:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
            case 4:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
            case 5:
              if (1024 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
              } else r2.head && (r2.head.extra = null);
              r2.mode = 6;
            case 6:
              if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;
              r2.length = 0, r2.mode = 7;
            case 7:
              if (2048 & r2.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
              } else r2.head && (r2.head.name = null);
              r2.length = 0, r2.mode = 8;
            case 8:
              if (4096 & r2.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
              } else r2.head && (r2.head.comment = null);
              r2.mode = 9;
            case 9:
              if (512 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (u2 !== (65535 & r2.check)) {
                  e2.msg = "header crc mismatch", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
              break;
            case 10:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
            case 11:
              if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
              e2.adler = r2.check = 1, r2.mode = 12;
            case 12:
              if (5 === t3 || 6 === t3) break e;
            case 13:
              if (r2.last) {
                u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                break;
              }
              for (; l2 < 3; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                case 0:
                  r2.mode = 14;
                  break;
                case 1:
                  if (j(r2), r2.mode = 20, 6 !== t3) break;
                  u2 >>>= 2, l2 -= 2;
                  break e;
                case 2:
                  r2.mode = 17;
                  break;
                case 3:
                  e2.msg = "invalid block type", r2.mode = 30;
              }
              u2 >>>= 2, l2 -= 2;
              break;
            case 14:
              for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e2.msg = "invalid stored block lengths", r2.mode = 30;
                break;
              }
              if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t3) break e;
            case 15:
              r2.mode = 16;
            case 16:
              if (d = r2.length) {
                if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d) break e;
                I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                break;
              }
              r2.mode = 12;
              break;
            case 17:
              for (; l2 < 14; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                e2.msg = "too many length or distance symbols", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 18;
            case 18:
              for (; r2.have < r2.ncode; ) {
                for (; l2 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
              }
              for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e2.msg = "invalid code lengths set", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 19;
            case 19:
              for (; r2.have < r2.nlen + r2.ndist; ) {
                for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                else {
                  if (16 === b) {
                    for (z2 = _ + 2; l2 < z2; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                  } else if (17 === b) {
                    for (z2 = _ + 3; l2 < z2; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                  } else {
                    for (z2 = _ + 7; l2 < z2; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                  }
                  if (r2.have + d > r2.nlen + r2.ndist) {
                    e2.msg = "invalid bit length repeat", r2.mode = 30;
                    break;
                  }
                  for (; d--; ) r2.lens[r2.have++] = k;
                }
              }
              if (30 === r2.mode) break;
              if (0 === r2.lens[256]) {
                e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                break;
              }
              if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e2.msg = "invalid literal/lengths set", r2.mode = 30;
                break;
              }
              if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                e2.msg = "invalid distances set", r2.mode = 30;
                break;
              }
              if (r2.mode = 20, 6 === t3) break e;
            case 20:
              r2.mode = 21;
            case 21:
              if (6 <= o2 && 258 <= h2) {
                e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                break;
              }
              for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (g && 0 == (240 & g)) {
                for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r2.back += v;
              }
              if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                r2.mode = 26;
                break;
              }
              if (32 & g) {
                r2.back = -1, r2.mode = 12;
                break;
              }
              if (64 & g) {
                e2.msg = "invalid literal/length code", r2.mode = 30;
                break;
              }
              r2.extra = 15 & g, r2.mode = 22;
            case 22:
              if (r2.extra) {
                for (z2 = r2.extra; l2 < z2; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              r2.was = r2.length, r2.mode = 23;
            case 23:
              for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (0 == (240 & g)) {
                for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r2.back += v;
              }
              if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                e2.msg = "invalid distance code", r2.mode = 30;
                break;
              }
              r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
            case 24:
              if (r2.extra) {
                for (z2 = r2.extra; l2 < z2; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              if (r2.offset > r2.dmax) {
                e2.msg = "invalid distance too far back", r2.mode = 30;
                break;
              }
              r2.mode = 25;
            case 25:
              if (0 === h2) break e;
              if (d = c2 - h2, r2.offset > d) {
                if ((d = r2.offset - d) > r2.whave && r2.sane) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
              } else m = i2, p = a2 - r2.offset, d = r2.length;
              for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;
              0 === r2.length && (r2.mode = 21);
              break;
            case 26:
              if (0 === h2) break e;
              i2[a2++] = r2.length, h2--, r2.mode = 21;
              break;
            case 27:
              if (r2.wrap) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 |= n2[s2++] << l2, l2 += 8;
                }
                if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                  e2.msg = "incorrect data check", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.mode = 28;
            case 28:
              if (r2.wrap && r2.flags) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (u2 !== (4294967295 & r2.total)) {
                  e2.msg = "incorrect length check", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.mode = 29;
            case 29:
              x = 1;
              break e;
            case 30:
              x = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U;
          }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t3)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t3) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state) return U;
          var t3 = e2.state;
          return t3.window && (t3.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t3) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t3).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t3) {
          var r2, n2 = t3.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t3, n2, 0) !== r2.check ? -3 : Z(e2, t3, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t2, r) {
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e2, t3, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z2 = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++) O[b] = 0;
          for (v = 0; v < n; v++) O[t3[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
          if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++) ;
          for (k < y && (k = y), b = z2 = 1; b <= 15; b++) if (z2 <<= 1, (z2 -= O[b]) < 0) return -1;
          if (0 < z2 && (0 === e2 || 1 !== w)) return -1;
          for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++) 0 !== t3[r2 + v] && (a[B[t3[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
            for (h = 1 << b - 1; E & h; ) h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w) break;
              b = t3[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z2 = 1 << (x = b - S); x + S < w && !((z2 -= O[x + S]) <= 0); ) x++, z2 <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t2, r) {
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t2, r) {
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t3 = e2.length; 0 <= --t3; ) e2[t3] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l + 2));
        n(z2);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t3, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t3, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t3) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t3;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t3) {
          e2.pending_buf[e2.pending++] = 255 & t3, e2.pending_buf[e2.pending++] = t3 >>> 8 & 255;
        }
        function P(e2, t3, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t3 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t3 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t3 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t3, r2) {
          P(e2, r2[2 * t3], r2[2 * t3 + 1]);
        }
        function j(e2, t3) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t3; ) ;
          return r2 >>> 1;
        }
        function Z(e2, t3, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t3; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W2(e2) {
          var t3;
          for (t3 = 0; t3 < l; t3++) e2.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < f; t3++) e2.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < c; t3++) e2.bl_tree[2 * t3] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M2(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t3, r2, n2) {
          var i2 = 2 * t3, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t3] <= n2[r2];
        }
        function G(e2, t3, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t3, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t3, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K2(e2, t3, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t3) : (L(e2, (s2 = A[i2]) + u + 1, t3), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
          L(e2, m, t3);
        }
        function Y(e2, t3) {
          var r2, n2, i2, s2 = t3.dyn_tree, a2 = t3.stat_desc.static_tree, o2 = t3.stat_desc.has_stree, h2 = t3.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t3.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t4) {
            var r3, n3, i3, s3, a3, o3, h3 = t4.dyn_tree, u3 = t4.max_code, l2 = t4.stat_desc.static_tree, f2 = t4.stat_desc.has_stree, c2 = t4.stat_desc.extra_bits, d2 = t4.stat_desc.extra_base, p2 = t4.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t3), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t3, r2) {
          var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t3[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t3[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t3, r2) {
          var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t3[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;
            else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
        }
        n(T);
        var q = false;
        function J(e2, t3, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
            M2(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t4, r3, e3.pending), e3.pending += r3;
          }(e2, t3, r2);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t3, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;
            for (t3 = 0; t3 <= g; t3++) s2[t3] = 0;
            for (e3 = 0; e3 <= 143; ) z2[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; ) z2[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; ) z2[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; ) z2[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z2, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z2, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W2(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t3, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t4, r3 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t4]) return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h;
            for (t4 = 32; t4 < u; t4++) if (0 !== e3.dyn_ltree[2 * t4]) return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t4;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t4 = c - 1; 3 <= t4 && 0 === e3.bl_tree[2 * S[t4] + 1]; t4--) ;
            return e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t3 ? J(e2, t3, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K2(e2, z2, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
            var i3;
            for (P(e3, t4 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t4 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K2(e2, e2.dyn_ltree, e2.dyn_dtree)), W2(e2), n2 && M2(e2);
        }, r._tr_tally = function(e2, t3, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t3 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t3, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t3 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t3--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t3)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z2), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t2, r) {
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t2, r) {
        (function(e2) {
          !function(r2, n) {
            if (!r2.setImmediate) {
              var i, s, t3, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t4 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t4, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t3.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t4 = l.createElement("script");
                t4.onreadystatechange = function() {
                  c(e4), t4.onreadystatechange = null, s.removeChild(t4), t4 = null;
                }, s.appendChild(t4);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t4 = new Array(arguments.length - 1), r3 = 0; r3 < t4.length; r3++) t4[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t4 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u) setTimeout(c, 0, e4);
              else {
                var t4 = h[e4];
                if (t4) {
                  u = true;
                  try {
                    !function(e5) {
                      var t5 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t5();
                          break;
                        case 1:
                          t5(r3[0]);
                          break;
                        case 2:
                          t5(r3[0], r3[1]);
                          break;
                        case 3:
                          t5(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t5.apply(n, r3);
                      }
                    }(t4);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  return jszip_min.exports;
}
var jszip_minExports = requireJszip_min();
const JSZip = /* @__PURE__ */ getDefaultExportFromCjs(jszip_minExports);
const types = {
  "application/andrew-inset": ["ez"],
  "application/appinstaller": ["appinstaller"],
  "application/applixware": ["aw"],
  "application/appx": ["appx"],
  "application/appxbundle": ["appxbundle"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomdeleted+xml": ["atomdeleted"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/atsc-dwd+xml": ["dwd"],
  "application/atsc-held+xml": ["held"],
  "application/atsc-rsat+xml": ["rsat"],
  "application/automationml-aml+xml": ["aml"],
  "application/automationml-amlx+zip": ["amlx"],
  "application/bdoc": ["bdoc"],
  "application/calendar+xml": ["xcs"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdfx+xml": ["cdfx"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cpl+xml": ["cpl"],
  "application/cu-seeme": ["cu"],
  "application/cwl": ["cwl"],
  "application/dash+xml": ["mpd"],
  "application/dash-patch+xml": ["mpp"],
  "application/davmount+xml": ["davmount"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["ecma"],
  "application/emma+xml": ["emma"],
  "application/emotionml+xml": ["emotionml"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/express": ["exp"],
  "application/fdf": ["fdf"],
  "application/fdt+xml": ["fdt"],
  "application/font-tdpfr": ["pfr"],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hjson": ["hjson"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/its+xml": ["its"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["*js"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lgr+xml": ["lgr"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/media-policy-dataset+xml": ["mpf"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mmt-aei+xml": ["maei"],
  "application/mmt-usd+xml": ["musd"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["*mp4", "*mpg4", "mp4s", "m4p"],
  "application/msix": ["msix"],
  "application/msixbundle": ["msixbundle"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/n-quads": ["nq"],
  "application/n-triples": ["nt"],
  "application/node": ["cjs"],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
  "application/oxps": ["oxps"],
  "application/p2p-overlay+xml": ["relo"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-keys": ["asc"],
  "application/pgp-signature": ["sig", "*asc"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/provenance+xml": ["provx"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf", "owl"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/route-apd+xml": ["rapd"],
  "application/route-s-tsid+xml": ["sls"],
  "application/route-usd+xml": ["rusd"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/senml+xml": ["senmlx"],
  "application/sensml+xml": ["sensmlx"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/sieve": ["siv", "sieve"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/sql": ["sql"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/swid+xml": ["swidtag"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/toml": ["toml"],
  "application/trig": ["trig"],
  "application/ttml+xml": ["ttml"],
  "application/ubjson": ["ubj"],
  "application/urc-ressheet+xml": ["rsheet"],
  "application/urc-targetdesc+xml": ["td"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/watcherinfo+xml": ["wif"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-att+xml": ["xav"],
  "application/xcap-caps+xml": ["xca"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xcap-el+xml": ["xel"],
  "application/xcap-ns+xml": ["xns"],
  "application/xenc+xml": ["xenc"],
  "application/xfdf": ["xfdf"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xliff+xml": ["xlf"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["*xsl", "xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "audio/3gpp": ["*3gpp"],
  "audio/aac": ["adts", "aac"],
  "audio/adpcm": ["adp"],
  "audio/amr": ["amr"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mobile-xmf": ["mxmf"],
  "audio/mp3": ["*mp3"],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx", "opus"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/wav": ["wav"],
  "audio/wave": ["*wav"],
  "audio/webm": ["weba"],
  "audio/xm": ["xm"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/aces": ["exr"],
  "image/apng": ["apng"],
  "image/avci": ["avci"],
  "image/avcs": ["avcs"],
  "image/avif": ["avif"],
  "image/bmp": ["bmp", "dib"],
  "image/cgm": ["cgm"],
  "image/dicom-rle": ["drle"],
  "image/dpx": ["dpx"],
  "image/emf": ["emf"],
  "image/fits": ["fits"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/heic": ["heic"],
  "image/heic-sequence": ["heics"],
  "image/heif": ["heif"],
  "image/heif-sequence": ["heifs"],
  "image/hej2k": ["hej2"],
  "image/hsj2": ["hsj2"],
  "image/ief": ["ief"],
  "image/jls": ["jls"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpeg", "jpg", "jpe"],
  "image/jph": ["jph"],
  "image/jphc": ["jhc"],
  "image/jpm": ["jpm", "jpgm"],
  "image/jpx": ["jpx", "jpf"],
  "image/jxl": ["jxl"],
  "image/jxr": ["jxr"],
  "image/jxra": ["jxra"],
  "image/jxrs": ["jxrs"],
  "image/jxs": ["jxs"],
  "image/jxsc": ["jxsc"],
  "image/jxsi": ["jxsi"],
  "image/jxss": ["jxss"],
  "image/ktx": ["ktx"],
  "image/ktx2": ["ktx2"],
  "image/png": ["png"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/t38": ["t38"],
  "image/tiff": ["tif", "tiff"],
  "image/tiff-fx": ["tfx"],
  "image/webp": ["webp"],
  "image/wmf": ["wmf"],
  "message/disposition-notification": ["disposition-notification"],
  "message/global": ["u8msg"],
  "message/global-delivery-status": ["u8dsn"],
  "message/global-disposition-notification": ["u8mdn"],
  "message/global-headers": ["u8hdr"],
  "message/rfc822": ["eml", "mime"],
  "model/3mf": ["3mf"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/jt": ["jt"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/mtl": ["mtl"],
  "model/obj": ["obj"],
  "model/prc": ["prc"],
  "model/step+xml": ["stpx"],
  "model/step+zip": ["stpz"],
  "model/step-xml+zip": ["stpxz"],
  "model/stl": ["stl"],
  "model/u3d": ["u3d"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["*x3db", "x3dbz"],
  "model/x3d+fastinfoset": ["x3db"],
  "model/x3d+vrml": ["*x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "model/x3d-vrml": ["x3dv"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/javascript": ["js", "mjs"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["md", "markdown"],
  "text/mathml": ["mml"],
  "text/mdx": ["mdx"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/richtext": ["rtx"],
  "text/rtf": ["*rtf"],
  "text/sgml": ["sgml", "sgm"],
  "text/shex": ["shex"],
  "text/slim": ["slim", "slm"],
  "text/spdx": ["spdx"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vtt": ["vtt"],
  "text/wgsl": ["wgsl"],
  "text/xml": ["*xml"],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/iso.segment": ["m4s"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["*jpm", "*jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts", "m2t", "m2ts", "mts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"]
};
Object.freeze(types);
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions;
class Mime {
  constructor(...args) {
    _Mime_extensionToType.set(this, /* @__PURE__ */ new Map());
    _Mime_typeToExtension.set(this, /* @__PURE__ */ new Map());
    _Mime_typeToExtensions.set(this, /* @__PURE__ */ new Map());
    for (const arg of args) {
      this.define(arg);
    }
  }
  define(typeMap, force = false) {
    for (let [type2, extensions] of Object.entries(typeMap)) {
      type2 = type2.toLowerCase();
      extensions = extensions.map((ext) => ext.toLowerCase());
      if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type2)) {
        __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type2, /* @__PURE__ */ new Set());
      }
      const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type2);
      let first = true;
      for (let extension of extensions) {
        const starred = extension.startsWith("*");
        extension = starred ? extension.slice(1) : extension;
        allExtensions == null ? void 0 : allExtensions.add(extension);
        if (first) {
          __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type2, extension);
        }
        first = false;
        if (starred)
          continue;
        const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
        if (currentType && currentType != type2 && !force) {
          throw new Error(`"${type2} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
        }
        __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type2);
      }
    }
    return this;
  }
  getType(path) {
    if (typeof path !== "string")
      return null;
    const last = path.replace(/^.*[/\\]/, "").toLowerCase();
    const ext = last.replace(/^.*\./, "").toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    if (!hasDot && hasPath)
      return null;
    return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
  }
  getExtension(type2) {
    var _a2;
    if (typeof type2 !== "string")
      return null;
    type2 = (_a2 = type2 == null ? void 0 : type2.split) == null ? void 0 : _a2.call(type2, ";")[0];
    return (type2 && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type2.trim().toLowerCase())) ?? null;
  }
  getAllExtensions(type2) {
    if (typeof type2 !== "string")
      return null;
    return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type2.toLowerCase()) ?? null;
  }
  _freeze() {
    this.define = () => {
      throw new Error("define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances");
    };
    Object.freeze(this);
    for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) {
      Object.freeze(extensions);
    }
    return this;
  }
  _getTestState() {
    return {
      types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
      extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f")
    };
  }
}
_Mime_extensionToType = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtension = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtensions = /* @__PURE__ */ new WeakMap();
new Mime(types)._freeze();
function validateOperations(operations) {
  const errors = [];
  const scopes = Object.keys(operations);
  for (const scope of scopes) {
    const ops = operations[scope].sort((a, b) => a.index - b.index);
    let opIndex = -1;
    for (let i = 0; i < ops.length; i++) {
      opIndex = opIndex + 1 + ops[i].skip;
      if (ops[i].index !== opIndex) {
        errors.push({
          message: `Invalid operation index ${ops[i].index} at position ${i}`,
          details: {
            position: i,
            operation: ops[i],
            scope: ops[i].scope
          }
        });
      }
    }
  }
  return errors;
}
function createZip(document) {
  const zip = new JSZip();
  const { name: name2, revision, documentType: documentType2, created, lastModified } = document;
  const header = {
    name: name2,
    revision,
    documentType: documentType2,
    created,
    lastModified
  };
  zip.file("header.json", JSON.stringify(header, null, 2));
  zip.file("state.json", JSON.stringify(document.initialState || {}, null, 2));
  zip.file("current-state.json", JSON.stringify(document.state || {}, null, 2));
  zip.file("operations.json", JSON.stringify(filterDocumentOperationsResultingState(document.operations), null, 2));
  if (document.attachments) {
    const attachments = Object.keys(document.attachments);
    attachments.forEach((key) => {
      var _a2;
      const { data, ...attributes } = ((_a2 = document.attachments) == null ? void 0 : _a2[key]) ?? {};
      if (data) {
        zip.file(key, data, {
          base64: true,
          createFolders: true,
          comment: JSON.stringify(attributes)
        });
      }
    });
  }
  return zip;
}
async function baseSaveToFile(document, path, extension, name2) {
  const zip = createZip(document);
  await zip.generateAsync({
    type: "uint8array",
    streamFiles: true
  });
  const fileName = name2 ?? document.name;
  const fileExtension2 = `.${extension}.zip`;
  return writeFile(path, fileName.endsWith(fileExtension2) ? fileName : `${fileName}${fileExtension2}`);
}
async function baseSaveToFileHandle(document, input) {
  const zip = createZip(document);
  const blob = await zip.generateAsync({ type: "blob" });
  const writable = await input.createWritable();
  await writable.write(blob);
  await writable.close();
}
async function baseLoadFromFile(path, reducer2, options) {
  const file = readFile();
  return baseLoadFromInput(file, reducer2, options);
}
async function baseLoadFromInput(input, reducer2, options) {
  const zip = new JSZip();
  await zip.loadAsync(input);
  return loadFromZip(zip, reducer2, options);
}
async function loadFromZip(zip, reducer2, options) {
  const initialStateZip = zip.file("state.json");
  if (!initialStateZip) {
    throw new Error("Initial state not found");
  }
  const initialStateStr = await initialStateZip.async("string");
  const initialState = JSON.parse(initialStateStr);
  const headerZip = zip.file("header.json");
  let header = void 0;
  if (headerZip) {
    header = JSON.parse(await headerZip.async("string"));
  }
  const operationsZip = zip.file("operations.json");
  if (!operationsZip) {
    throw new Error("Operations history not found");
  }
  const operations = JSON.parse(await operationsZip.async("string"));
  const clearedOperations = garbageCollectDocumentOperations(operations);
  const operationsError = validateOperations(clearedOperations);
  if (operationsError.length) {
    const errorMessages = operationsError.map((err) => err.message);
    throw new Error(errorMessages.join("\n"));
  }
  let result = replayDocument(initialState, clearedOperations, reducer2, void 0, header, {}, options);
  if (header) {
    result = {
      ...result,
      ...header
    };
  }
  return result;
}
const SPLIT_LOWER_UPPER_RE = new RegExp("([\\p{Ll}\\d])(\\p{Lu})", "gu");
const SPLIT_UPPER_UPPER_RE = new RegExp("(\\p{Lu})([\\p{Lu}][\\p{Ll}])", "gu");
const SPLIT_SEPARATE_NUMBER_RE = new RegExp("(\\d)\\p{Ll}|(\\p{L})\\d", "u");
const DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu;
const SPLIT_REPLACE_VALUE = "$1\0$2";
const DEFAULT_PREFIX_SUFFIX_CHARACTERS = "";
function split(value) {
  let result = value.trim();
  result = result.replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE).replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);
  result = result.replace(DEFAULT_STRIP_REGEXP, "\0");
  let start = 0;
  let end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  if (start === end)
    return [];
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split(/\0/g);
}
function splitSeparateNumbers(value) {
  const words = split(value);
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);
    if (match) {
      const offset = match.index + (match[1] ?? match[2]).length;
      words.splice(i, 1, word.slice(0, offset), word.slice(offset));
    }
  }
  return words;
}
function noCase(input, options) {
  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
  return prefix + words.map(lowerFactory(options == null ? void 0 : options.locale)).join((options == null ? void 0 : options.delimiter) ?? " ") + suffix;
}
function pascalCase(input, options) {
  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options == null ? void 0 : options.locale);
  const upper = upperFactory(options == null ? void 0 : options.locale);
  const transform = pascalCaseTransformFactory(lower, upper);
  return prefix + words.map(transform).join("") + suffix;
}
function capitalCase(input, options) {
  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options == null ? void 0 : options.locale);
  const upper = upperFactory(options == null ? void 0 : options.locale);
  return prefix + words.map(capitalCaseTransformFactory(lower, upper)).join(" ") + suffix;
}
function constantCase(input, options) {
  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
  return prefix + words.map(upperFactory(options == null ? void 0 : options.locale)).join("_") + suffix;
}
function sentenceCase(input, options) {
  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options == null ? void 0 : options.locale);
  const upper = upperFactory(options == null ? void 0 : options.locale);
  const transform = capitalCaseTransformFactory(lower, upper);
  return prefix + words.map((word, index) => {
    if (index === 0)
      return transform(word);
    return lower(word);
  }).join(" ") + suffix;
}
function snakeCase(input, options) {
  return noCase(input, { delimiter: "_", ...options });
}
function lowerFactory(locale) {
  return locale === false ? (input) => input.toLowerCase() : (input) => input.toLocaleLowerCase(locale);
}
function upperFactory(locale) {
  return (input) => input.toLocaleUpperCase(locale);
}
function capitalCaseTransformFactory(lower, upper) {
  return (word) => `${upper(word[0])}${lower(word.slice(1))}`;
}
function pascalCaseTransformFactory(lower, upper) {
  return (word, index) => {
    const char0 = word[0];
    const initial = index > 0 && char0 >= "0" && char0 <= "9" ? "_" + char0 : upper(char0);
    return initial + lower(word.slice(1));
  };
}
function splitPrefixSuffix(input, options = {}) {
  const splitFn = options.split ?? (options.separateNumbers ? splitSeparateNumbers : split);
  const prefixCharacters = options.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  const suffixCharacters = options.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  let prefixIndex = 0;
  let suffixIndex = input.length;
  while (prefixIndex < input.length) {
    const char = input.charAt(prefixIndex);
    if (!prefixCharacters.includes(char))
      break;
    prefixIndex++;
  }
  while (suffixIndex > prefixIndex) {
    const index = suffixIndex - 1;
    const char = input.charAt(index);
    if (!suffixCharacters.includes(char))
      break;
    suffixIndex = index;
  }
  return [
    input.slice(0, prefixIndex),
    splitFn(input.slice(prefixIndex, suffixIndex)),
    input.slice(suffixIndex)
  ];
}
const isDefinedNonNullAny = (v) => v !== void 0 && v !== null;
z.any().refine((v) => isDefinedNonNullAny(v));
const TransmitterTypeSchema = z.enum([
  "Internal",
  "MatrixConnect",
  "PullResponder",
  "RESTWebhook",
  "SecureConnect",
  "SwitchboardPush"
]);
const TriggerTypeSchema = z.enum(["PullResponder"]);
function AddFileInputSchema() {
  return z.object({
    document: z.unknown().nullish(),
    documentType: z.string(),
    id: z.string(),
    name: z.string(),
    parentFolder: z.string().nullish(),
    synchronizationUnits: z.array(SynchronizationUnitSchema())
  });
}
function AddFolderInputSchema() {
  return z.object({
    id: z.string(),
    name: z.string(),
    parentFolder: z.string().nullish()
  });
}
function AddListenerInputSchema() {
  return z.object({
    listener: ListenerSchema()
  });
}
function AddTriggerInputSchema() {
  return z.object({
    trigger: TriggerSchema()
  });
}
function CopyNodeInputSchema() {
  return z.object({
    srcId: z.string(),
    synchronizationUnits: z.array(SynchronizationUnitSchema()).nullish(),
    targetId: z.string(),
    targetName: z.string().nullish(),
    targetParentFolder: z.string().nullish()
  });
}
function DeleteNodeInputSchema() {
  return z.object({
    id: z.string()
  });
}
function ListenerSchema() {
  return z.object({
    __typename: z.literal("Listener").optional(),
    block: z.boolean(),
    callInfo: ListenerCallInfoSchema().nullable(),
    filter: ListenerFilterSchema(),
    label: z.string().nullable(),
    listenerId: z.string(),
    system: z.boolean()
  });
}
function ListenerCallInfoSchema() {
  return z.object({
    __typename: z.literal("ListenerCallInfo").optional(),
    data: z.string().nullable(),
    name: z.string().nullable(),
    transmitterType: TransmitterTypeSchema.nullable()
  });
}
function ListenerFilterSchema() {
  return z.object({
    __typename: z.literal("ListenerFilter").optional(),
    branch: z.array(z.string()).nullable(),
    documentId: z.array(z.string()).nullable(),
    documentType: z.array(z.string()),
    scope: z.array(z.string()).nullable()
  });
}
function MoveNodeInputSchema() {
  return z.object({
    srcFolder: z.string(),
    targetParentFolder: z.string().nullish()
  });
}
function PullResponderTriggerDataSchema() {
  return z.object({
    __typename: z.literal("PullResponderTriggerData").optional(),
    interval: z.string(),
    listenerId: z.string(),
    url: z.string()
  });
}
function RemoveListenerInputSchema() {
  return z.object({
    listenerId: z.string()
  });
}
function RemoveTriggerInputSchema() {
  return z.object({
    triggerId: z.string()
  });
}
function SetAvailableOfflineInputSchema() {
  return z.object({
    availableOffline: z.boolean()
  });
}
function SetDriveIconInputSchema() {
  return z.object({
    icon: z.string()
  });
}
function SetDriveNameInputSchema() {
  return z.object({
    name: z.string()
  });
}
function SetSharingTypeInputSchema() {
  return z.object({
    type: z.string()
  });
}
function SynchronizationUnitSchema() {
  return z.object({
    __typename: z.literal("SynchronizationUnit").optional(),
    branch: z.string(),
    scope: z.string(),
    syncId: z.string()
  });
}
function TriggerSchema() {
  return z.object({
    __typename: z.literal("Trigger").optional(),
    data: TriggerDataSchema().nullable(),
    id: z.string(),
    type: TriggerTypeSchema
  });
}
function TriggerDataSchema() {
  return PullResponderTriggerDataSchema();
}
function UpdateFileInputSchema() {
  return z.object({
    documentType: z.string().nullish(),
    id: z.string(),
    name: z.string().nullish(),
    parentFolder: z.string().nullish()
  });
}
function UpdateNodeInputSchema() {
  return z.object({
    id: z.string(),
    name: z.string().nullish(),
    parentFolder: z.string().nullish()
  });
}
const setDriveName = (input) => createAction("SET_DRIVE_NAME", { ...input }, void 0, SetDriveNameInputSchema, "global");
const setDriveIcon = (input) => createAction("SET_DRIVE_ICON", { ...input }, void 0, SetDriveIconInputSchema, "global");
const setSharingType = (input) => createAction("SET_SHARING_TYPE", { ...input }, void 0, SetSharingTypeInputSchema, "local");
const setAvailableOffline = (input) => createAction("SET_AVAILABLE_OFFLINE", { ...input }, void 0, SetAvailableOfflineInputSchema, "local");
const addListener = (input) => createAction("ADD_LISTENER", { ...input }, void 0, AddListenerInputSchema, "local");
const removeListener = (input) => createAction("REMOVE_LISTENER", { ...input }, void 0, RemoveListenerInputSchema, "local");
const addTrigger = (input) => createAction("ADD_TRIGGER", { ...input }, void 0, AddTriggerInputSchema, "local");
const removeTrigger = (input) => createAction("REMOVE_TRIGGER", { ...input }, void 0, RemoveTriggerInputSchema, "local");
const addFile = (input) => createAction("ADD_FILE", { ...input }, void 0, AddFileInputSchema, "global");
const addFolder = (input) => createAction("ADD_FOLDER", { ...input }, void 0, AddFolderInputSchema, "global");
const deleteNode = (input) => createAction("DELETE_NODE", { ...input }, void 0, DeleteNodeInputSchema, "global");
const updateFile = (input) => createAction("UPDATE_FILE", { ...input }, void 0, UpdateFileInputSchema, "global");
const updateNode = (input) => createAction("UPDATE_NODE", { ...input }, void 0, UpdateNodeInputSchema, "global");
const copyNode = (input) => createAction("COPY_NODE", { ...input }, void 0, CopyNodeInputSchema, "global");
const moveNode = (input) => createAction("MOVE_NODE", { ...input }, void 0, MoveNodeInputSchema, "global");
const creators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addFile,
  addFolder,
  addListener,
  addTrigger,
  copyNode,
  deleteNode,
  moveNode,
  removeListener,
  removeTrigger,
  setAvailableOffline,
  setDriveIcon,
  setDriveName,
  setSharingType,
  updateFile,
  updateNode
}, Symbol.toStringTag, { value: "Module" }));
const reducer$2 = {
  setDriveNameOperation(state, action, dispatch) {
    state.name = action.input.name;
  },
  setDriveIconOperation(state, action, dispatch) {
    state.icon = action.input.icon;
  },
  setSharingTypeOperation(state, action, dispatch) {
    state.sharingType = action.input.type;
  },
  setAvailableOfflineOperation(state, action, dispatch) {
    state.availableOffline = action.input.availableOffline;
  },
  addListenerOperation(state, action, dispatch) {
    if (state.listeners.find((listener) => listener.listenerId === action.input.listener.listenerId)) {
      throw new Error(`A listener with Id: ${action.input.listener.listenerId} already exists`);
    }
    state.listeners.push(action.input.listener);
  },
  removeListenerOperation(state, action, dispatch) {
    state.listeners = state.listeners.filter((listener) => listener.listenerId !== action.input.listenerId);
  },
  addTriggerOperation(state, action, dispatch) {
    if (state.triggers.find((trigger) => trigger.id === action.input.trigger.id)) {
      throw new Error(`A trigger with Id: ${action.input.trigger.id} already exists`);
    }
    state.triggers.push(action.input.trigger);
  },
  removeTriggerOperation(state, action, dispatch) {
    state.triggers = state.triggers.filter((trigger) => trigger.id !== action.input.triggerId);
  }
};
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = { randomUUID };
function v4(options, buf, offset) {
  var _a2;
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a2 = options.rng) == null ? void 0 : _a2.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function isFileNode(node) {
  return node.kind === "file";
}
function isFolderNode(node) {
  return node.kind === "folder";
}
function getAncestors(node, allNodes) {
  if (!node.parentFolder) {
    return [];
  } else {
    const parentNode = allNodes.find((_node) => _node.id === node.parentFolder);
    if (!parentNode) {
      throw new Error(`Parent node with id ${node.parentFolder} not found`);
    }
    return [parentNode, ...getAncestors(parentNode, allNodes)];
  }
}
function getDescendants(node, allNodes) {
  const children = allNodes.filter((_node) => _node.parentFolder === node.id);
  const descendants = children.map((child) => getDescendants(child, allNodes));
  return [...children, ...descendants.flat()];
}
function generateNodesCopy(src, idGenerator, nodes) {
  const rootNode = nodes.find((node) => node.id === src.srcId);
  if (!rootNode) {
    throw new Error(`Node with id ${src.srcId} not found`);
  }
  const nodesToCopy = [
    {
      ...rootNode,
      name: src.targetName || rootNode.name,
      parentFolder: src.targetParentFolder || null
    },
    ...getDescendants(rootNode, nodes)
  ];
  const ids = {};
  if (src.targetParentFolder) {
    ids[src.targetParentFolder] = src.targetParentFolder;
  }
  const getNewNodeId = (id) => {
    let newId = ids[id];
    if (!newId) {
      const oldId = id;
      newId = idGenerator(id);
      ids[oldId] = newId;
    }
    return newId;
  };
  const copyNodesInput = nodesToCopy.map((node) => ({
    srcId: node.id,
    targetId: getNewNodeId(node.id),
    targetName: node.name,
    targetParentFolder: node.parentFolder ? getNewNodeId(node.parentFolder) : null,
    synchronizationUnits: isFileNode(node) ? node.synchronizationUnits.map((unit) => ({
      ...unit,
      syncId: generateSynchronizationUnitId(nodes)
    })) : void 0
  }));
  return copyNodesInput;
}
function generateSynchronizationUnitId(nodes) {
  let syncId = "";
  while (!syncId || nodes.find((node) => isFileNode(node) && node.synchronizationUnits.find((unit) => unit.syncId === syncId))) {
    syncId = v4();
  }
  return syncId;
}
function generateSynchronizationUnits(state, scopes, branch = "main") {
  return scopes.map((scope) => ({
    scope,
    branch,
    syncId: generateSynchronizationUnitId(state.nodes)
  }));
}
function generateAddNodeAction(state, action, scopes) {
  return addFile({
    ...action,
    synchronizationUnits: generateSynchronizationUnits(state, scopes)
  });
}
function generateCopyNodeAction(state, action) {
  const originalNode = state.nodes.find((node) => node.id === action.srcId);
  if (!originalNode) {
    throw new Error(`Node with id ${action.srcId} not found`);
  }
  let synchronizationUnits = void 0;
  if (isFileNode(originalNode)) {
    synchronizationUnits = originalNode.synchronizationUnits.map((syncUnit) => ({
      ...syncUnit,
      syncId: generateSynchronizationUnitId(state.nodes)
    }));
  }
  return copyNode({
    ...action,
    synchronizationUnits
  });
}
function getNextCopyNumber(files2, baseFilename) {
  let maxNumber = 0;
  const regex = new RegExp(`^${escapeRegExp(baseFilename)} \\(copy\\)(?: (\\d+))?$`);
  for (const file of files2) {
    const match = file.match(regex);
    if (match) {
      const number = match[1] ? parseInt(match[1], 10) : 1;
      if (number > maxNumber) {
        maxNumber = number;
      }
    }
  }
  return maxNumber + 1;
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function handleTargetNameCollisions(params) {
  const { nodes, targetParentFolder, srcName } = params;
  const targetNodeChildrenNames = nodes.filter((node) => targetParentFolder === "" ? node.parentFolder === null : node.parentFolder === targetParentFolder).map((node) => node.name);
  const targetHasNodesWithSameName = targetNodeChildrenNames.includes(srcName);
  const targetName = targetHasNodesWithSameName ? `${srcName} (copy) ${getNextCopyNumber(targetNodeChildrenNames, srcName)}` : srcName;
  return targetName;
}
const customUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  escapeRegExp,
  generateAddNodeAction,
  generateCopyNodeAction,
  generateNodesCopy,
  generateSynchronizationUnitId,
  generateSynchronizationUnits,
  getAncestors,
  getDescendants,
  getNextCopyNumber,
  handleTargetNameCollisions,
  isFileNode,
  isFolderNode
}, Symbol.toStringTag, { value: "Module" }));
const reducer$1 = {
  addFileOperation(state, action, dispatch) {
    if (state.nodes.find((node) => node.id === action.input.id)) {
      throw new Error(`Node with id ${action.input.id} already exists!`);
    }
    const name2 = handleTargetNameCollisions({
      nodes: state.nodes,
      srcName: action.input.name,
      targetParentFolder: action.input.parentFolder || null
    });
    const synchronizationUnits = action.input.synchronizationUnits;
    const invalidSyncUnit = synchronizationUnits.find((unit) => !!state.nodes.find((node) => isFileNode(node) && node.synchronizationUnits.find((fileUnit) => fileUnit.syncId === unit.syncId)));
    if (invalidSyncUnit) {
      throw new Error(`A synchronization unit with Id ${invalidSyncUnit.syncId} already exists`);
    }
    const fileNode = {
      id: action.input.id,
      name: name2,
      kind: "file",
      parentFolder: action.input.parentFolder ?? null,
      synchronizationUnits,
      documentType: action.input.documentType
    };
    state.nodes.push(fileNode);
    dispatch == null ? void 0 : dispatch({
      type: "CREATE_CHILD_DOCUMENT",
      input: {
        id: action.input.id,
        documentType: action.input.documentType,
        synchronizationUnits,
        document: action.input.document
      }
    });
  },
  addFolderOperation(state, action) {
    if (state.nodes.find((node) => node.id === action.input.id)) {
      throw new Error(`Node with id ${action.input.id} already exists!`);
    }
    const name2 = handleTargetNameCollisions({
      nodes: state.nodes,
      srcName: action.input.name,
      targetParentFolder: action.input.parentFolder || null
    });
    state.nodes.push({
      ...action.input,
      name: name2,
      kind: "folder",
      parentFolder: action.input.parentFolder ?? null
    });
  },
  deleteNodeOperation(state, action, dispatch) {
    const node = state.nodes.find((node2) => node2.id === action.input.id);
    if (!node) {
      throw new Error(`Node with id ${action.input.id} not found`);
    }
    const descendants = getDescendants(node, state.nodes);
    state.nodes = state.nodes.filter((node2) => node2.id !== action.input.id && !descendants.find((descendant) => descendant.id === node2.id));
    [node, ...descendants].filter((node2) => isFileNode(node2)).forEach((node2) => {
      dispatch == null ? void 0 : dispatch({
        type: "DELETE_CHILD_DOCUMENT",
        input: {
          id: node2.id
        }
      });
    });
  },
  updateFileOperation(state, action) {
    state.nodes = state.nodes.map((node) => node.id === action.input.id ? {
      ...node,
      ...{
        name: handleTargetNameCollisions({
          nodes: state.nodes,
          srcName: action.input.name ?? node.name,
          targetParentFolder: action.input.parentFolder || null
        }),
        documentType: action.input.documentType ?? node.documentType
      }
    } : node);
  },
  updateNodeOperation(state, action) {
    state.nodes = state.nodes.map((node) => node.id === action.input.id ? {
      ...node,
      ...{
        name: handleTargetNameCollisions({
          nodes: state.nodes,
          srcName: action.input.name ?? node.name,
          targetParentFolder: action.input.parentFolder || null
        }),
        parentFolder: action.input.parentFolder === null ? null : node.parentFolder
      }
    } : node);
  },
  copyNodeOperation(state, action, dispatch) {
    const node = state.nodes.find((node2) => node2.id === action.input.srcId);
    if (!node) {
      throw new Error(`Node with id ${action.input.srcId} not found`);
    }
    const duplicatedNode = state.nodes.find((node2) => node2.id === action.input.targetId);
    if (duplicatedNode) {
      throw new Error(`Node with id ${action.input.targetId} already exists`);
    }
    const name2 = handleTargetNameCollisions({
      nodes: state.nodes,
      srcName: action.input.targetName || node.name,
      targetParentFolder: action.input.targetParentFolder || null
    });
    const newNode = {
      ...node,
      name: name2,
      id: action.input.targetId,
      parentFolder: action.input.targetParentFolder || null
    };
    const isFile = isFileNode(newNode);
    if (isFile) {
      const synchronizationUnits = action.input.synchronizationUnits;
      if (!action.input.synchronizationUnits) {
        throw new Error("Synchronization units were not provided");
      }
      const invalidSyncUnit = synchronizationUnits.find((unit) => !!state.nodes.find((node2) => isFileNode(node2) && node2.synchronizationUnits.find((fileUnit) => fileUnit.syncId === unit.syncId)));
      if (invalidSyncUnit) {
        throw new Error(`A synchronization unit with Id ${invalidSyncUnit.syncId} already exists`);
      }
      newNode.synchronizationUnits = synchronizationUnits;
    }
    state.nodes.push(newNode);
    if (isFile) {
      dispatch == null ? void 0 : dispatch({
        type: "COPY_CHILD_DOCUMENT",
        input: {
          id: action.input.srcId,
          newId: action.input.targetId,
          synchronizationUnits: newNode.synchronizationUnits
        }
      });
    }
  },
  moveNodeOperation(state, action) {
    if (action.input.srcFolder === action.input.targetParentFolder) {
      throw new Error("Circular Reference Error: Attempting to move a node to its current parent folder");
    }
    const node = state.nodes.find((node2) => node2.id === action.input.srcFolder);
    if (!node) {
      throw new Error(`Node with id ${action.input.srcFolder} not found`);
    }
    const name2 = handleTargetNameCollisions({
      nodes: state.nodes,
      srcName: node.name,
      targetParentFolder: action.input.targetParentFolder || null
    });
    if (isFolderNode(node)) {
      const descendants = getDescendants(node, state.nodes);
      if (descendants.find((descendant) => descendant.id === action.input.targetParentFolder)) {
        throw new Error("Circular Reference Error: Cannot move a folder to one of its descendants");
      }
    }
    state.nodes = state.nodes.map((node2) => {
      if (node2.id === action.input.srcFolder) {
        return {
          ...node2,
          name: name2,
          parentFolder: action.input.targetParentFolder || null
        };
      }
      return node2;
    });
  }
};
const stateReducer = (state, action, dispatch) => {
  if (isDocumentAction(action)) {
    return state;
  }
  switch (action.type) {
    case "ADD_FILE":
      AddFileInputSchema().parse(action.input);
      reducer$1.addFileOperation(state[action.scope], action, dispatch);
      break;
    case "ADD_FOLDER":
      AddFolderInputSchema().parse(action.input);
      reducer$1.addFolderOperation(state[action.scope], action, dispatch);
      break;
    case "DELETE_NODE":
      DeleteNodeInputSchema().parse(action.input);
      reducer$1.deleteNodeOperation(state[action.scope], action, dispatch);
      break;
    case "UPDATE_FILE":
      UpdateFileInputSchema().parse(action.input);
      reducer$1.updateFileOperation(state[action.scope], action, dispatch);
      break;
    case "UPDATE_NODE":
      UpdateNodeInputSchema().parse(action.input);
      reducer$1.updateNodeOperation(state[action.scope], action, dispatch);
      break;
    case "COPY_NODE":
      CopyNodeInputSchema().parse(action.input);
      reducer$1.copyNodeOperation(state[action.scope], action, dispatch);
      break;
    case "MOVE_NODE":
      MoveNodeInputSchema().parse(action.input);
      reducer$1.moveNodeOperation(state[action.scope], action, dispatch);
      break;
    case "SET_DRIVE_NAME":
      SetDriveNameInputSchema().parse(action.input);
      reducer$2.setDriveNameOperation(state[action.scope], action, dispatch);
      break;
    case "SET_DRIVE_ICON":
      SetDriveIconInputSchema().parse(action.input);
      reducer$2.setDriveIconOperation(state[action.scope], action, dispatch);
      break;
    case "SET_SHARING_TYPE":
      SetSharingTypeInputSchema().parse(action.input);
      reducer$2.setSharingTypeOperation(state[action.scope], action, dispatch);
      break;
    case "SET_AVAILABLE_OFFLINE":
      SetAvailableOfflineInputSchema().parse(action.input);
      reducer$2.setAvailableOfflineOperation(state[action.scope], action, dispatch);
      break;
    case "ADD_LISTENER":
      AddListenerInputSchema().parse(action.input);
      reducer$2.addListenerOperation(state[action.scope], action, dispatch);
      break;
    case "REMOVE_LISTENER":
      RemoveListenerInputSchema().parse(action.input);
      reducer$2.removeListenerOperation(state[action.scope], action, dispatch);
      break;
    case "ADD_TRIGGER":
      AddTriggerInputSchema().parse(action.input);
      reducer$2.addTriggerOperation(state[action.scope], action, dispatch);
      break;
    case "REMOVE_TRIGGER":
      RemoveTriggerInputSchema().parse(action.input);
      reducer$2.removeTriggerOperation(state[action.scope], action, dispatch);
      break;
    default:
      return state;
  }
};
const reducer = createReducer(stateReducer);
const fileExtension = "phdd";
const documentType = "powerhouse/document-drive";
const documentModelName = "DocumentDrive";
const initialGlobalState = {
  id: "",
  name: "",
  nodes: [],
  icon: null,
  slug: null
};
const initialLocalState = {
  listeners: [],
  triggers: [],
  sharingType: "private",
  availableOffline: false
};
const createState = (state) => {
  return {
    global: { ...initialGlobalState, ...state == null ? void 0 : state.global },
    local: { ...initialLocalState, ...state == null ? void 0 : state.local }
  };
};
const createExtendedState = (extendedState) => {
  return baseCreateExtendedState({ ...extendedState, documentType }, createState);
};
const createDocument = (state) => {
  return baseCreateDocument(createExtendedState(state), createState);
};
const saveToFile = (document, path, name2) => {
  return baseSaveToFile(document, path, fileExtension, name2);
};
const saveToFileHandle = (document, input) => {
  return baseSaveToFileHandle(document, input);
};
const loadFromFile = (path) => {
  return baseLoadFromFile(path, reducer);
};
const loadFromInput = (input) => {
  return baseLoadFromInput(input, reducer);
};
const documentModelUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDocument,
  createExtendedState,
  createState,
  fileExtension,
  loadFromFile,
  loadFromInput,
  saveToFile,
  saveToFileHandle
}, Symbol.toStringTag, { value: "Module" }));
const actions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
const documentModelState = {
  id: documentType,
  name: documentModelName,
  extension: fileExtension,
  description: "",
  author: {
    name: "Powerhouse Inc",
    website: "https://www.powerhouse.inc/"
  },
  specifications: [
    {
      version: 1,
      changeLog: [],
      state: {
        global: {
          schema: "type FolderNode {\n    id: String!\n    name: String!\n    kind: String!\n    parentFolder: String\n}\n\ntype SynchronizationUnit {\n    syncId: ID!\n    scope: String!\n    branch: String!\n}\n\ntype FileNode {\n    id: String!\n    name: String!\n    kind: String!\n    documentType: String!\n    parentFolder: String\n    synchronizationUnits: [SynchronizationUnit!]!\n}\n\nunion Node = FolderNode | FileNode\n\ntype DocumentDriveState {\n    id: ID!\n    name: String!\n    nodes: [Node!]!\n    icon: String\n    slug: String\n}",
          initialValue: '"{\\"id\\":\\"\\",\\"name\\":\\"\\",\\"nodes\\":[],\\"icon\\":null,\\"slug\\":null}"',
          examples: []
        },
        local: {
          schema: "type ListenerFilter {\n    documentType: [String!]!\n    documentId: [ID!]\n    scope: [String!]\n    branch: [String!]\n}\n\nenum TransmitterType {\n    Internal,\n    SwitchboardPush,\n    PullResponder,\n    SecureConnect, \n    MatrixConnect,\n    RESTWebhook\n}\n\ntype ListenerCallInfo {\n    transmitterType: TransmitterType\n    name: String\n    data: String\n}\n\ntype Listener {\n    listenerId: ID!\n    label: String\n    block: Boolean!\n    system: Boolean!\n    filter: ListenerFilter!\n    callInfo: ListenerCallInfo\n}\n\nenum TriggerType {\n    PullResponder\n}\n\ntype PullResponderTriggerData {\n    listenerId: ID!\n    url: String!\n    interval: String!\n}\n\nunion TriggerData = PullResponderTriggerData\n\ntype Trigger {\n    id: ID!\n    type: TriggerType!\n    data: TriggerData\n}\n\ntype DocumentDriveLocalState{\n    sharingType: String\n    listeners: [Listener!]!\n    triggers: [Trigger!]!\n    availableOffline: Boolean!\n}",
          initialValue: '"{ \\"listeners\\": [], \\"triggers\\": [], \\"sharingType\\": \\"private\\", \\"availableOffline\\": false}"',
          examples: []
        }
      },
      modules: [
        {
          id: "GRzuvv78tBvmB6ciitokLfonNHA=",
          name: "Node",
          description: "",
          operations: [
            {
              id: "7xiTdxonc9yEASR8sfV/KnbSV10=",
              name: "ADD_FILE",
              description: "",
              schema: "input AddFileInput {\n    id: ID!\n    name: String!\n    documentType: String!\n    parentFolder: ID\n    synchronizationUnits: [SynchronizationUnit!]!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "4lzNMMKKdIAtEU6i12xLgi9hp+U=",
              name: "ADD_FOLDER",
              description: "",
              schema: "input AddFolderInput {\n    id: ID!\n    name: String!\n    parentFolder: ID\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "53jH2/3TWTTcgCJiv2C+BmuC6i0=",
              name: "DELETE_NODE",
              description: "",
              schema: "input DeleteNodeInput {\n    id: ID!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "pNn+Y1/HVq/GNMk7t0u3g3gtMLE=",
              name: "UPDATE_FILE",
              description: "",
              schema: "input UpdateFileInput {\n    id: ID!\n    parentFolder: ID\n    name: String\n    documentType: String\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "P0x1M8Mnt+Q/+9nggkwgVbfybsc=",
              name: "UPDATE_NODE",
              description: "",
              schema: "input UpdateNodeInput {\n    id: ID!\n    parentFolder: ID\n    name: String\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "vnQ7OB5b3wGLgjhbgJqAIpA+JLE=",
              name: "COPY_NODE",
              description: "",
              schema: "input CopyNodeInput {\n    srcId: ID!\n    targetId: ID!\n    targetName: String\n    targetParentFolder: ID\n    synchronizationUnits: [SynchronizationUnit!]\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "VNyiD/sNGzk6k9A1Qe7s8dmrJxA=",
              name: "MOVE_NODE",
              description: "",
              schema: "input MoveNodeInput {\n    srcFolder: ID!\n    targetParentFolder: ID\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            }
          ]
        },
        {
          id: "0dHwHlxOM9x0vMZ+gLnKxf2qTEo=",
          name: "Drive",
          description: "",
          operations: [
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z1dsU=",
              name: "SET_DRIVE_NAME",
              description: "",
              schema: "input SetDriveNameInput {\n    name: String!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z30dsU=",
              name: "SET_DRIVE_ICON",
              description: "",
              schema: "input SetDriveIconInput {\n    icon: String!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "global"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z2dsU=",
              name: "SET_SHARING_TYPE",
              description: "",
              schema: "input SetSharingTypeInput {\n    type: String!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "local"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z3dsU=",
              name: "SET_AVAILABLE_OFFLINE",
              description: "",
              schema: "input SetAvailableOfflineInput {\n    availableOffline: Boolean!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "local"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z9dsU=",
              name: "ADD_LISTENER",
              description: "",
              schema: "input AddListenerInput {\n    listener: Listener!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "local"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z10dsU=",
              name: "REMOVE_LISTENER",
              description: "",
              schema: "input RemoveListenerInput {\n    listenerId: String!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "local"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z20dsU=",
              name: "ADD_TRIGGER",
              description: "",
              schema: "input AddTriggerInput {\n    trigger: Trigger!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "local"
            },
            {
              id: "qGCiPGpTt/cyz3HzyrBn92z30dsU=",
              name: "REMOVE_TRIGGER",
              description: "",
              schema: "input RemoveTriggerInput {\n    triggerId: String!\n}",
              template: "",
              reducer: "",
              errors: [],
              examples: [],
              scope: "local"
            }
          ]
        }
      ]
    }
  ]
};
const driveDocumentModelModule = {
  reducer,
  documentModel: documentModelState,
  actions: { ...creators, ...actions },
  utils: { ...documentModelUtils, ...customUtils }
};
var define_process_env_default = {};
const LEVELS = {
  verbose: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 6
};
class ConsoleLogger {
  constructor(tags, errorHandler2) {
    __privateAdd(this, _ConsoleLogger_instances);
    __privateAdd(this, _tags);
    __privateAdd(this, _levelString, "env");
    __privateAdd(this, _errorHandler);
    __privateSet(this, _tags, (tags || []).map((tag) => `[${tag}]`));
    __privateSet(this, _errorHandler, errorHandler2);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.warn = this.warn.bind(this);
    this.error = this.error.bind(this);
    this.debug = this.debug.bind(this);
    this.verbose = this.verbose.bind(this);
  }
  get level() {
    return __privateGet(this, _levelString);
  }
  set level(level) {
    __privateSet(this, _levelString, level);
  }
  get errorHandler() {
    return __privateGet(this, _errorHandler);
  }
  set errorHandler(handler) {
    __privateSet(this, _errorHandler, handler);
  }
  log(...data) {
    return this.debug(...data);
  }
  verbose(...data) {
    if (__privateGet(this, _ConsoleLogger_instances, levelValue_get) > LEVELS.verbose) {
      return;
    }
    return this.debug(...data);
  }
  debug(...data) {
    if (__privateGet(this, _ConsoleLogger_instances, levelValue_get) > LEVELS.debug) {
      return;
    }
    return console.debug(...[...__privateGet(this, _tags), ...data]);
  }
  info(...data) {
    if (__privateGet(this, _ConsoleLogger_instances, levelValue_get) > LEVELS.info) {
      return;
    }
    return console.info(...[...__privateGet(this, _tags), ...data]);
  }
  warn(...data) {
    if (__privateGet(this, _ConsoleLogger_instances, levelValue_get) > LEVELS.warn) {
      return;
    }
    return console.warn(...[...__privateGet(this, _tags), ...data]);
  }
  error(...data) {
    if (__privateGet(this, _ConsoleLogger_instances, levelValue_get) > LEVELS.error) {
      return;
    }
    if (__privateGet(this, _errorHandler)) {
      __privateGet(this, _errorHandler).call(this, ...data);
    }
    return console.error(...[...__privateGet(this, _tags), ...data]);
  }
}
_tags = new WeakMap();
_levelString = new WeakMap();
_errorHandler = new WeakMap();
_ConsoleLogger_instances = new WeakSet();
levelValue_get = function() {
  if (__privateGet(this, _levelString) === "env") {
    const envLevel = typeof process !== "undefined" ? define_process_env_default.LOG_LEVEL : void 0;
    if (!envLevel) {
      return LEVELS.debug;
    }
    if (!(envLevel in LEVELS)) {
      return LEVELS.debug;
    }
    return LEVELS[envLevel];
  }
  return LEVELS[__privateGet(this, _levelString)];
};
const loggerInstance = new ConsoleLogger();
let logLevel = "env";
let errorHandler;
loggerInstance.level = logLevel;
loggerInstance.errorHandler = errorHandler;
const logger$1 = loggerInstance;
const setErrorHandler = (handler) => {
  errorHandler = handler;
  loggerInstance.errorHandler = handler;
};
const setLogLevel = (level) => {
  logLevel = level;
  loggerInstance.level = level;
};
const childLogger = (tags) => {
  const logger2 = new ConsoleLogger(tags);
  logger2.level = logLevel;
  logger2.errorHandler = errorHandler;
  return logger2;
};
class DocumentModelNotFoundError extends Error {
  constructor(id, cause) {
    super(`Document model "${id}" not found`, { cause });
    __publicField(this, "id");
    this.id = id;
  }
}
class OperationError extends Error {
  constructor(status, operation, message, cause) {
    super(message, { cause: cause ?? operation });
    __publicField(this, "status");
    __publicField(this, "operation");
    this.status = status;
    this.operation = operation;
  }
}
class ConflictOperationError extends OperationError {
  constructor(existingOperation, newOperation) {
    super("CONFLICT", newOperation, `Conflicting operation on index ${newOperation.index}`, { existingOperation, newOperation });
  }
}
class DriveAlreadyExistsError extends Error {
  constructor(driveId) {
    super(`Drive already exists. ID: ${driveId}`);
    __publicField(this, "driveId");
    this.driveId = driveId;
  }
}
class DriveNotFoundError extends Error {
  constructor(driveId) {
    super(`Drive with id ${driveId} not found`);
    __publicField(this, "driveId");
    this.driveId = driveId;
  }
}
class SynchronizationUnitNotFoundError extends Error {
  constructor(message, syncUnitId) {
    super(message);
    __publicField(this, "syncUnitId");
    this.syncUnitId = syncUnitId;
  }
}
var RunAsap;
(function(RunAsap2) {
  RunAsap2.useMessageChannel = (() => {
    if (typeof MessageChannel === "undefined") {
      return new Error("MessageChannel is not supported");
    }
    return (task) => {
      const controller = new AbortController();
      const signal = controller.signal;
      const mc = new MessageChannel();
      mc.port1.postMessage(null);
      mc.port2.addEventListener("message", () => {
        task();
        mc.port1.close();
        mc.port2.close();
      }, { once: true, signal });
      mc.port2.start();
      return () => controller.abort();
    };
  })();
  RunAsap2.usePostMessage = (() => {
    const _main = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      typeof window === "object" && window || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      typeof global === "object" && global || typeof self === "object" && self
    );
    if (!_main) {
      return new Error("No global object found");
    }
    const main2 = _main;
    if (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      !main2.postMessage || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      !main2.addEventListener || main2.importScripts
    ) {
      return new Error("postMessage is not supported");
    }
    let index = 0;
    const tasks = /* @__PURE__ */ new Map();
    function getNewIndex() {
      if (index === 9007199254740991) {
        return 0;
      }
      return ++index;
    }
    const MESSAGE_PREFIX = "com.usePostMessage" + Math.random();
    main2.addEventListener("message", (e) => {
      const event = e;
      if (typeof event.data !== "string") {
        return;
      }
      if (event.source !== main2 || !event.data.startsWith(MESSAGE_PREFIX)) {
        return;
      }
      const index2 = event.data.split(":").at(1);
      if (index2 === void 0) {
        return;
      }
      const i = +index2;
      const task = tasks.get(i);
      if (task) {
        task();
        tasks.delete(i);
      }
    }, false);
    return (task) => {
      const i = getNewIndex();
      tasks.set(i, task);
      main2.postMessage(MESSAGE_PREFIX + ":" + i, { targetOrigin: "*" });
      return () => {
        tasks.delete(i);
      };
    };
  })();
  RunAsap2.useSetImmediate = (() => {
    if (typeof window !== "undefined") {
      return new Error("setImmediate is not supported on the browser");
    }
    if (typeof setImmediate === "undefined") {
      return new Error("setImmediate is not supported");
    }
    return (task) => {
      const id = setImmediate(task);
      return () => clearImmediate(id);
    };
  })();
  RunAsap2.useSetTimeout = /* @__PURE__ */ (() => {
    return (task) => {
      const id = setTimeout(task, 0);
      return () => clearTimeout(id);
    };
  })();
  function runAsap2(task) {
    if (!(RunAsap2.useSetImmediate instanceof Error)) {
      return RunAsap2.useSetImmediate(task);
    } else if (!(RunAsap2.useMessageChannel instanceof Error)) {
      return RunAsap2.useMessageChannel(task);
    } else if (!(RunAsap2.usePostMessage instanceof Error)) {
      return RunAsap2.usePostMessage(task);
    } else {
      return RunAsap2.useSetTimeout(task);
    }
  }
  RunAsap2.runAsap = runAsap2;
  function runAsapAsync2(task, queueMethod = runAsap2) {
    if (queueMethod instanceof Error) {
      throw new Error("queueMethod is not supported", {
        cause: queueMethod
      });
    }
    return new Promise((resolve, reject) => {
      queueMethod(() => {
        task().then(resolve).catch(reject);
      });
    });
  }
  RunAsap2.runAsapAsync = runAsapAsync2;
})(RunAsap || (RunAsap = {}));
const runAsap = RunAsap.runAsap;
const runAsapAsync = RunAsap.runAsapAsync;
function isDocumentDrive(document) {
  return document.documentType === documentType;
}
function mergeOperations(currentOperations, newOperations) {
  const minIndexByScope = Object.keys(currentOperations).reduce((acc, curr) => {
    var _a2;
    const scope = curr;
    acc[scope] = ((_a2 = currentOperations[scope].at(-1)) == null ? void 0 : _a2.index) ?? 0;
    return acc;
  }, {});
  const conflictOp = newOperations.find((op) => op.index < (minIndexByScope[op.scope] ?? 0));
  if (conflictOp) {
    throw new OperationError("ERROR", conflictOp, `Tried to add operation with index ${conflictOp.index} and document is at index ${minIndexByScope[conflictOp.scope]}`);
  }
  return newOperations.sort((a, b) => a.index - b.index).reduce((acc, curr) => {
    const existingOperations = acc[curr.scope] || [];
    return { ...acc, [curr.scope]: [...existingOperations, curr] };
  }, currentOperations);
}
function generateUUID() {
  return generateId();
}
function isBefore(dateA, dateB) {
  return new Date(dateA) < new Date(dateB);
}
let createNanoEvents = () => ({
  emit(event, ...args) {
    for (let callbacks = this.events[event] || [], i = 0, length = callbacks.length; i < length; i++) {
      callbacks[i](...args);
    }
  },
  events: {},
  on(event, cb) {
    var _a2;
    ((_a2 = this.events)[event] || (_a2[event] = [])).push(cb);
    return () => {
      var _a3;
      this.events[event] = (_a3 = this.events[event]) == null ? void 0 : _a3.filter((i) => cb !== i);
    };
  }
});
function isOperationJob(job) {
  return "operations" in job;
}
function isActionJob(job) {
  return "actions" in job;
}
class MemoryQueue {
  constructor(id) {
    __publicField(this, "id");
    __publicField(this, "blocked", false);
    __publicField(this, "deleted", false);
    __publicField(this, "items", []);
    __publicField(this, "dependencies", new Array());
    this.id = id;
  }
  async setDeleted(deleted) {
    this.deleted = deleted;
  }
  async isDeleted() {
    return this.deleted;
  }
  async addJob(data) {
    this.items.push(data);
    return Promise.resolve();
  }
  async getNextJob() {
    const job = this.items.shift();
    return Promise.resolve(job);
  }
  async amountOfJobs() {
    return Promise.resolve(this.items.length);
  }
  getId() {
    return this.id;
  }
  async setBlocked(blocked) {
    this.blocked = blocked;
  }
  async isBlocked() {
    return this.blocked;
  }
  async getJobs() {
    return this.items;
  }
  async addDependencies(job) {
    if (!this.dependencies.find((j) => j.jobId === job.jobId)) {
      this.dependencies.push(job);
    }
    if (!this.isBlocked()) {
      this.setBlocked(true);
    }
  }
  async removeDependencies(job) {
    this.dependencies = this.dependencies.filter((j) => j.jobId !== job.jobId && j.driveId !== job.driveId);
    if (this.dependencies.length === 0) {
      await this.setBlocked(false);
    }
  }
}
class BaseQueueManager {
  constructor(workers = 3, timeout = 0) {
    __publicField(this, "emitter", createNanoEvents());
    __publicField(this, "ticker", 0);
    __publicField(this, "queues", []);
    __publicField(this, "workers");
    __publicField(this, "timeout");
    __publicField(this, "delegate");
    this.workers = workers;
    this.timeout = timeout;
  }
  async init(delegate, onError) {
    this.delegate = delegate;
    for (let i = 0; i < this.workers; i++) {
      setTimeout(() => this.processNextJob.bind(this)().catch(onError), 100 * i);
    }
    return Promise.resolve();
  }
  async addJob(job) {
    if (!this.delegate) {
      throw new Error("No server delegate defined");
    }
    const jobId = generateUUID();
    const queue = this.getQueue(job.driveId, job.documentId);
    if (await queue.isDeleted()) {
      throw new Error("Queue is deleted");
    }
    const newDocument = job.documentId && !await this.delegate.checkDocumentExists(job.documentId);
    if (newDocument && !await queue.isBlocked()) {
      await queue.setBlocked(true);
      const driveQueue = this.getQueue(job.driveId);
      const jobs = await driveQueue.getJobs();
      for (const driveJob of jobs) {
        const actions3 = isOperationJob(driveJob) ? driveJob.operations : driveJob.actions;
        const op = actions3.find((j) => {
          const input = j.input;
          return j.type === "ADD_FILE" && input.id === job.documentId;
        });
        if (op) {
          await queue.addDependencies(driveJob);
        }
      }
    }
    const actions2 = isOperationJob(job) ? job.operations : job.actions ?? [];
    const addFileOps = actions2.filter((j) => j.type === "ADD_FILE");
    for (const addFileOp of addFileOps) {
      const input = addFileOp.input;
      const q = this.getQueue(job.driveId, input.id);
      await q.addDependencies({ jobId, ...job });
    }
    const removeFileOps = actions2.filter((j) => j.type === "DELETE_NODE");
    for (const removeFileOp of removeFileOps) {
      const input = removeFileOp.input;
      const queue2 = this.getQueue(job.driveId, input.id);
      await queue2.setDeleted(true);
    }
    await queue.addJob({ jobId, ...job });
    return jobId;
  }
  getQueue(driveId, documentId) {
    const queueId = this.getQueueId(driveId, documentId);
    let queue = this.queues.find((q) => q.getId() === queueId);
    if (!queue) {
      queue = new MemoryQueue(queueId);
      this.queues.push(queue);
    }
    return queue;
  }
  removeQueue(driveId, documentId) {
    const queueId = this.getQueueId(driveId, documentId);
    this.queues = this.queues.filter((q) => q.getId() !== queueId);
    this.emit("queueRemoved", queueId);
  }
  getQueueByIndex(index) {
    const queue = this.queues[index];
    if (queue) {
      return queue;
    }
    return null;
  }
  getQueues() {
    return this.queues.map((q) => q.getId());
  }
  retryNextJob(timeout) {
    const _timeout = timeout !== void 0 ? timeout : this.timeout;
    const retry = _timeout > 0 ? (fn) => setTimeout(fn, _timeout) : runAsap;
    retry(() => this.processNextJob());
  }
  async findFirstNonEmptyQueue(ticker) {
    const numQueues = this.queues.length;
    for (let i = 0; i < numQueues; i++) {
      const index = (ticker + i) % numQueues;
      const queue = this.queues[index];
      if (queue && await queue.amountOfJobs() > 0) {
        return index;
      }
    }
    return null;
  }
  async processNextJob() {
    if (!this.delegate) {
      throw new Error("No server delegate defined");
    }
    if (this.queues.length === 0) {
      this.retryNextJob();
      return;
    }
    const queue = this.queues[this.ticker];
    if (!queue) {
      this.ticker = 0;
      this.retryNextJob();
      return;
    }
    const amountOfJobs = await queue.amountOfJobs();
    if (amountOfJobs === 0) {
      const nextTicker = await this.findFirstNonEmptyQueue(this.ticker);
      if (nextTicker !== null) {
        this.ticker = nextTicker;
        this.retryNextJob(0);
      } else {
        this.retryNextJob();
      }
      return;
    }
    this.ticker = this.ticker === this.queues.length - 1 ? 0 : this.ticker + 1;
    const isBlocked = await queue.isBlocked();
    if (isBlocked) {
      this.retryNextJob();
      return;
    }
    await queue.setBlocked(true);
    const nextJob = await queue.getNextJob();
    if (!nextJob) {
      this.retryNextJob();
      return;
    }
    try {
      const result = await this.delegate.processJob(nextJob);
      const actions2 = isOperationJob(nextJob) ? nextJob.operations : nextJob.actions;
      const addFileActions = actions2.filter((op) => op.type === "ADD_FILE");
      if (addFileActions.length > 0) {
        for (const addFile2 of addFileActions) {
          const documentQueue = this.getQueue(nextJob.driveId, addFile2.input.id);
          await documentQueue.removeDependencies(nextJob);
        }
      }
      this.emit("jobCompleted", nextJob, result);
    } catch (e) {
      logger$1.error(`job failed`, e);
      this.emit("jobFailed", nextJob, e);
    } finally {
      await queue.setBlocked(false);
      this.retryNextJob(0);
    }
  }
  emit(event, ...args) {
    this.emitter.emit(event, ...args);
  }
  on(event, cb) {
    return this.emitter.on(event, cb);
  }
  getQueueId(driveId, documentId) {
    return `queue:${driveId}${documentId ? `:${documentId}` : ""}`;
  }
}
class ReadDriveError extends Error {
}
class ReadDriveNotFoundError extends ReadDriveError {
  constructor(driveId) {
    super(`Read drive ${driveId} not found.`);
  }
}
class ReadDriveSlugNotFoundError extends ReadDriveError {
  constructor(slug) {
    super(`Read drive with slug ${slug} not found.`);
  }
}
class ReadDocumentNotFoundError extends ReadDriveError {
  constructor(drive, id) {
    super(`Document with id ${id} not found on read drive ${drive}.`);
  }
}
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
const LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
class GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function syntaxError(source, position, description2) {
  return new GraphQLError(`Syntax Error: ${description2}`, {
    source,
    positions: [position]
  });
}
class Location {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class Token {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit$1(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit$1(code) || code === 95;
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0; i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      // Has non-printable characters
      case 13:
        return false;
      // Has \r or \r\n which will be replaced as \n
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      //   \t
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = (
    // add leading and trailing new lines only if it improves readability
    !isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes
  );
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));
class Lexer {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      // Ignored ::
      //   - UnicodeBOM
      //   - WhiteSpace
      //   - LineTerminator
      //   - Comment
      //   - Comma
      //
      // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
      //
      // WhiteSpace ::
      //   - "Horizontal Tab (U+0009)"
      //   - "Space (U+0020)"
      //
      // Comma :: ,
      case 65279:
      // <BOM>
      case 9:
      // \t
      case 32:
      // <space>
      case 44:
        ++position;
        continue;
      // LineTerminator ::
      //   - "New Line (U+000A)"
      //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
      //   - "Carriage Return (U+000D)" "New Line (U+000A)"
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      // Comment
      case 35:
        return readComment(lexer, position);
      // Token ::
      //   - Punctuator
      //   - Name
      //   - IntValue
      //   - FloatValue
      //   - StringValue
      //
      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      // StringValue
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit$1(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit$1(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit$1(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit$1(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
const isProduction = globalThis.process && // eslint-disable-next-line no-undef
true;
const instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);
class Source {
  constructor(body, name2 = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name2;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function isSource(source) {
  return instanceOf(source, Source);
}
function parse(source, options) {
  const parser = new Parser(source, options);
  const document = parser.parseDocument();
  Object.defineProperty(document, "tokenCount", {
    enumerable: false,
    value: parser.tokenCount
  });
  return document;
}
class Parser {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name2;
    if (this.peek(TokenKind.NAME)) {
      name2 = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name: name2,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name2;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name2 = this.parseName();
    } else {
      name2 = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name: name2,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type2;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type2 = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type2 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type: type2
      });
    }
    return type2;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description: description2,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type2
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description: description2,
      name: name2,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description: description2,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    const name2 = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description: description2,
      name: name2,
      arguments: args,
      type: type2,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description: description2,
      name: name2,
      type: type2,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description: description2,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const types2 = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description: description2,
      name: name2,
      directives,
      types: types2
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description: description2,
      name: name2,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    const name2 = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description: description2,
      name: name2,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description: description2,
      name: name2,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name: name2,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const types2 = this.parseUnionMemberTypes();
    if (directives.length === 0 && types2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name: name2,
      directives,
      types: types2
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name: name2,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name2,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description2 = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name2 = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description: description2,
      name: name2,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name2 = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {
      return name2;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
const MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
function identityFunc(x) {
  return x;
}
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit(aChar) && isDigit(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
const DIGIT_0 = 48;
const DIGIT_9 = 57;
function isDigit(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1; i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1; j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function print(ast) {
  return visit(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives }) => "..." + name2 + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name2}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: description2, directives, operationTypes }) => wrap("", description2, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description: description2, name: name2, directives }) => wrap("", description2, "\n") + join(["scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: description2, name: name2, interfaces, directives, fields }) => wrap("", description2, "\n") + join(
      [
        "type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: description2, name: name2, arguments: args, type: type2, directives }) => wrap("", description2, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description: description2, name: name2, type: type2, defaultValue, directives }) => wrap("", description2, "\n") + join(
      [name2 + ": " + type2, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: description2, name: name2, interfaces, directives, fields }) => wrap("", description2, "\n") + join(
      [
        "interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: description2, name: name2, directives, types: types2 }) => wrap("", description2, "\n") + join(
      ["union", name2, join(directives, " "), wrap("= ", join(types2, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: description2, name: name2, directives, values }) => wrap("", description2, "\n") + join(["enum", name2, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: description2, name: name2, directives }) => wrap("", description2, "\n") + join([name2, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: description2, name: name2, directives, fields }) => wrap("", description2, "\n") + join(["input", name2, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: description2, name: name2, arguments: args, repeatable, locations }) => wrap("", description2, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives }) => join(["extend scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(
      [
        "extend type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives, types: types2 }) => join(
      [
        "extend union",
        name2,
        join(directives, " "),
        wrap("= ", join(types2, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives, values }) => join(["extend enum", name2, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives, fields }) => join(["extend input", name2, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name2.length; ++i) {
    if (!isNameContinue(name2.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
      );
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name2}" does not.`
    );
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isOutputType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
function assertAbstractType(type2) {
  if (!isAbstractType(type2)) {
    throw new Error(`Expected ${inspect(type2)} to be a GraphQL abstract type.`);
  }
  return type2;
}
class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function isNamedType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineTypes(config) {
  const types2 = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types2) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types2;
}
class GraphQLEnumType {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name2) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value) => value.name);
    }
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function didYouMeanEnumValue(enumType2, unknownValueStr) {
  const allNames = enumType2.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
const GRAPHQL_MAX_INT = 2147483647;
const GRAPHQL_MIN_INT = -2147483648;
const GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
const GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
const GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
const GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
const GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
const specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function isSpecifiedScalarType(type2) {
  return specifiedScalarTypes.some(({ name: name2 }) => type2.name === name2);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
const GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
const GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
const DEFAULT_DEPRECATION_REASON = "No longer supported";
const GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
const GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
const GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
const specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name: name2 }) => name2 === directive.name);
}
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
function astFromValue(value, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
const __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
const __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
const __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
const __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values = type2.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values = Object.values(type2.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type2) => {
        if (isInputObjectType(type2)) {
          return type2.isOneOf;
        }
      }
    }
  })
});
const __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
const __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
const __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
const __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
const SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);
function isIntrospectionType(type2) {
  return introspectionTypes.some(({ name: name2 }) => type2.name === name2);
}
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
class GraphQLSchema {
  // Used as a cache for validateSchema().
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : void 0;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(
      false,
      `"types" must be Array if provided but got: ${inspect(config.types)}.`
    );
    !config.directives || Array.isArray(config.directives) || devAssert(
      false,
      `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
    );
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type2 of config.types) {
        allReferencedTypes.delete(type2);
        collectReferencedTypes(type2, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(
        false,
        "One of the provided types for building the Schema is missing a name."
      );
      if (this._typeMap[typeName] !== void 0) {
        throw new Error(
          `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
        );
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name2) {
    return this.getTypeMap()[name2];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === void 0) {
      map = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type2 of abstractType.getTypes()) {
          map[type2.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type2 of implementations.objects) {
          map[type2.name] = true;
        }
        for (const type2 of implementations.interfaces) {
          map[type2.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name2) {
    return this.getDirectives().find((directive) => directive.name === name2);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
}
function collectReferencedTypes(type2, typeSet) {
  const namedType = getNamedType(type2);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema) {
  const errors = validateSchema(schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
class SchemaValidationContext {
  constructor(schema) {
    this._errors = [];
    this.schema = schema;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(
      new GraphQLError(message, {
        nodes: _nodes
      })
    );
  }
  getErrors() {
    return this._errors;
  }
}
function validateRootTypes(context) {
  const schema = context.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(
      `Query root type must be Object type, it cannot be ${inspect(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema,
        OperationTypeNode.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema,
        OperationTypeNode.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema,
        OperationTypeNode.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(
        `Expected directive but got: ${inspect(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context, directive);
    if (directive.locations.length === 0) {
      context.reportError(
        `Directive @${directive.name} must include 1 or more locations.`,
        directive.astNode
      );
    }
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type2 of Object.values(typeMap)) {
    if (!isNamedType(type2)) {
      context.reportError(
        `Expected GraphQL named type but got: ${inspect(type2)}.`,
        type2.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type2)) {
      validateName(context, type2);
    }
    if (isObjectType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isInterfaceType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isUnionType(type2)) {
      validateUnionMembers(context, type2);
    } else if (isEnumType(type2)) {
      validateEnumValues(context, type2);
    } else if (isInputObjectType(type2)) {
      validateInputFields(context, type2);
      validateInputObjectCircularRefs(type2);
    }
  }
}
function validateFields(context, type2) {
  const fields = Object.values(type2.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type2.name} must define one or more fields.`, [
      type2.astNode,
      ...type2.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(
        `The type of ${type2.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(
          `The type of ${type2.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(
          `Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context, type2) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type2.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(
        `Type ${inspect(type2)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
        getAllImplementsInterfaceNodes(type2, iface)
      );
      continue;
    }
    if (type2 === iface) {
      context.reportError(
        `Type ${type2.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type2, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(
        `Type ${type2.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type2, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type2, iface);
    validateTypeImplementsInterface(context, type2, iface);
  }
}
function validateTypeImplementsInterface(context, type2, iface) {
  const typeFieldMap = type2.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`,
        [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type2.name}.${fieldName} is type ${inspect(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type2.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(
          `Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type2, iface) {
  const ifaceInterfaces = type2.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(
        transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type2, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context, enumType2) {
  const enumValues = enumType2.getValues();
  if (enumValues.length === 0) {
    context.reportError(
      `Enum type ${enumType2.name} must define one or more values.`,
      [enumType2.astNode, ...enumType2.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
    if (inputObj.isOneOf) {
      validateOneOfInputObjectField(inputObj, field, context);
    }
  }
}
function validateOneOfInputObjectField(type2, field, context) {
  if (isNonNullType(field.type)) {
    var _field$astNode4;
    context.reportError(
      `OneOf input field ${type2.name}.${field.name} must be nullable.`,
      (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
    );
  }
  if (field.defaultValue !== void 0) {
    context.reportError(
      `OneOf input field ${type2.name}.${field.name} cannot have a default value.`,
      field.astNode
    );
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type2, iface) {
  const { astNode, extensionASTNodes } = type2;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
class TypeInfo {
  constructor(schema, initialType, getFieldDefFn) {
    this._schema = schema;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(
          isCompositeType(namedType) ? namedType : void 0
        );
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema, node.type);
        this._inputTypeStack.push(
          isInputType(inputType) ? inputType : void 0
        );
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find(
            (arg) => arg.name === node.name.value
          );
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType2 = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType2)) {
          inputField = objectType2.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(
          inputField ? inputField.defaultValue : void 0
        );
        this._inputTypeStack.push(
          isInputType(inputFieldType) ? inputFieldType : void 0
        );
        break;
      }
      case Kind.ENUM: {
        const enumType2 = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType2)) {
          enumValue = enumType2.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
    }
  }
}
function getFieldDef(schema, parentType, fieldNode) {
  const name2 = fieldNode.name.value;
  if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name2];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name2 = node.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name2}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name2}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    // Not reachable, all possible types have been considered.
    /* c8 ignore next */
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
const standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}
const MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFieldsAndFragmentPairs = new OrderedPairSet();
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  if (comparedFieldsAndFragmentPairs.has(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFieldsAndFragmentPairs.add(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  );
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name: name2, value }) => [name2.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
class OrderedPairSet {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a, b, weaklyPresent) {
    var _this$_data$get;
    const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
    if (result === void 0) {
      return false;
    }
    return weaklyPresent ? true : weaklyPresent === result;
  }
  add(a, b, weaklyPresent) {
    const map = this._data.get(a);
    if (map === void 0) {
      this._data.set(a, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
    } else {
      map.set(b, weaklyPresent);
    }
  }
}
class PairSet {
  constructor() {
    this._orderedPairSet = new OrderedPairSet();
  }
  has(a, b, weaklyPresent) {
    return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);
  }
  add(a, b, weaklyPresent) {
    if (a < b) {
      this._orderedPairSet.add(a, b, weaklyPresent);
    } else {
      this._orderedPairSet.add(b, a, weaklyPresent);
    }
  }
}
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
const defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    // Not reachable. All possible types have been considered
    /* c8 ignore next */
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type2 = context.getType();
      const selectionSet = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        } else if (selectionSet.selections.length === 0) {
          const fieldName = node.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type2.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name2}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type2.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type2,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type2, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type2.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind.NULL;
  const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type2.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type: type2, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
const recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
const specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
const specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);
class ASTValidationContext {
  constructor(ast, onError) {
    this._ast = ast;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name2) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = /* @__PURE__ */ Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name2];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set2;
      while (set2 = setsToVisit.pop()) {
        for (const selection of set2.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = /* @__PURE__ */ Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}
class SDLValidationContext extends ASTValidationContext {
  constructor(ast, schema, onError) {
    super(ast, onError);
    this._schema = schema;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}
class ValidationContext extends ASTValidationContext {
  constructor(schema, ast, typeInfo, onError) {
    super(ast, onError);
    this._schema = schema;
    this._typeInfo = typeInfo;
    this._variableUsages = /* @__PURE__ */ new Map();
    this._recursiveVariableUsages = /* @__PURE__ */ new Map();
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(
        node,
        visitWithTypeInfo(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        })
      );
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}
function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = void 0) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(
    schema,
    documentAST,
    typeInfo,
    (error) => {
      if (errors.length >= maxErrors) {
        errors.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors.push(error);
    }
  );
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors = [];
  const context = new SDLValidationContext(
    documentAST,
    schemaToExtend,
    (error) => {
      errors.push(error);
    }
  );
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  const errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors = validateSDL(documentAST, schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name2 = typeNode.name.value;
    typeMap[name2] = (_stdTypeMap$name = stdTypeMap[name2]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    // Get the extended root operation types.
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  };
  function replaceType(type2) {
    if (isListType(type2)) {
      return new GraphQLList(replaceType(type2.ofType));
    }
    if (isNonNullType(type2)) {
      return new GraphQLNonNull(replaceType(type2.ofType));
    }
    return replaceNamedType(type2);
  }
  function replaceNamedType(type2) {
    return typeMap[type2.name];
  }
  function replaceDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      args: mapValue(config.args, extendArg)
    });
  }
  function extendNamedType(type2) {
    if (isIntrospectionType(type2) || isSpecifiedScalarType(type2)) {
      return type2;
    }
    if (isScalarType(type2)) {
      return extendScalarType(type2);
    }
    if (isObjectType(type2)) {
      return extendObjectType(type2);
    }
    if (isInterfaceType(type2)) {
      return extendInterfaceType(type2);
    }
    if (isUnionType(type2)) {
      return extendUnionType(type2);
    }
    if (isEnumType(type2)) {
      return extendEnumType(type2);
    }
    if (isInputObjectType(type2)) {
      return extendInputObjectType(type2);
    }
    invariant(false, "Unexpected type: " + inspect(type2));
  }
  function extendInputObjectType(type2) {
    var _typeExtensionsMap$co;
    const config = type2.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type2) {
    var _typeExtensionsMap$ty;
    const config = type2.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type2) {
    var _typeExtensionsMap$co2;
    const config = type2.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type2) {
    var _typeExtensionsMap$co3;
    const config = type2.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [
        ...type2.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type2) {
    var _typeExtensionsMap$co4;
    const config = type2.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [
        ...type2.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type2) {
    var _typeExtensionsMap$co5;
    const config = type2.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config,
      types: () => [
        ...type2.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (
        /* c8 ignore next */
        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
      );
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name2 = node.name.value;
    const type2 = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
    if (type2 === void 0) {
      throw new Error(`Unknown type: "${name2}".`);
    }
    return type2;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      // @ts-expect-error
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (
        /* c8 ignore next */
        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
      );
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = (
      /* c8 ignore next */
      args !== null && args !== void 0 ? args : []
    );
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type2 = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type: type2,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type2),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (
        /* c8 ignore next */
        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
      );
      for (const field of fieldsNodes) {
        var _field$description2;
        const type2 = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type: type2,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type2),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (
        /* c8 ignore next */
        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
      );
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$interfaces$map, _node$interfaces;
        return (
          /* c8 ignore next */
          (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
        );
      }
    );
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$types$map, _node$types;
        return (
          /* c8 ignore next */
          (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
        );
      }
    );
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name2 = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name: name2,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name: name2,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name: name2,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name: name2,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name: name2,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name: name2,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes,
          isOneOf: isOneOf(astNode)
        });
      }
    }
  }
}
const stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
function isOneOf(node) {
  return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));
}
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config.astNode == null) {
    for (const type2 of config.types) {
      switch (type2.name) {
        // Note: While this could make early assertions to get the correctly
        // typed values below, that would throw immediately while type system
        // validation with validateSchema() will produce more actionable results.
        case "Query":
          config.query = type2;
          break;
        case "Mutation":
          config.mutation = type2;
          break;
        case "Subscription":
          config.subscription = type2;
          break;
      }
    }
  }
  const directives = [
    ...config.directives,
    // If specified directives were not explicitly declared, add them.
    ...specifiedDirectives.filter(
      (stdDirective) => config.directives.every(
        (directive) => directive.name !== stdDirective.name
      )
    )
  ];
  return new GraphQLSchema({ ...config, directives });
}
function buildSchema(source, options) {
  const document = parse(source, {
    noLocation: void 0,
    allowLegacyFragmentVariables: void 0
  });
  return buildASTSchema(document, {
    assumeValidSDL: void 0,
    assumeValid: void 0
  });
}
const defaultJsonSerializer = JSON;
const uppercase = (str) => str.toUpperCase();
const HeadersInstanceToPlainObject = (headers) => {
  const o = {};
  headers.forEach((v, k) => {
    o[k] = v;
  });
  return o;
};
const parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
const parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
const parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};
const parseRequestExtendedArgs = (urlOrOptions, document, ...variablesAndRequestHeaders) => {
  const [variables, requestHeaders] = variablesAndRequestHeaders;
  return urlOrOptions.document ? urlOrOptions : {
    url: urlOrOptions,
    document,
    variables,
    requestHeaders,
    signal: void 0
  };
};
const extractOperationName = (document) => {
  var _a2, _b;
  let operationName = void 0;
  const operationDefinitions = document.definitions.filter((definition) => definition.kind === `OperationDefinition`);
  if (operationDefinitions.length === 1) {
    operationName = (_b = (_a2 = operationDefinitions[0]) == null ? void 0 : _a2.name) == null ? void 0 : _b.value;
  }
  return operationName;
};
const resolveRequestDocument = (document) => {
  if (typeof document === `string`) {
    let operationName2 = void 0;
    try {
      const parsedDocument = parse(document);
      operationName2 = extractOperationName(parsedDocument);
    } catch (err) {
    }
    return { query: document, operationName: operationName2 };
  }
  const operationName = extractOperationName(document);
  return { query: print(document), operationName };
};
class ClientError extends Error {
  constructor(response, request2) {
    const message = `${ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request: request2
    })}`;
    super(message);
    Object.setPrototypeOf(this, ClientError.prototype);
    this.response = response;
    this.request = request2;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, ClientError);
    }
  }
  static extractMessage(response) {
    var _a2, _b;
    return ((_b = (_a2 = response.errors) == null ? void 0 : _a2[0]) == null ? void 0 : _b.message) ?? `GraphQL Error (Code: ${response.status})`;
  }
}
var browserPonyfill = { exports: {} };
var hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
  if (hasRequiredBrowserPonyfill) return browserPonyfill.exports;
  hasRequiredBrowserPonyfill = 1;
  (function(module, exports) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof commonjsGlobal !== "undefined" && commonjsGlobal;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      (function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof commonjsGlobal !== "undefined" && commonjsGlobal || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers2.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers2.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers2.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars2[i] = String.fromCharCode(view[i]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request2 = new Request(input, init);
            if (request2.signal && request2.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request2.method, fixUrl(request2.url), true);
            if (request2.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request2.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name2) {
                names.push(normalizeName(name2));
                xhr.setRequestHeader(name2, normalizeValue(init.headers[name2]));
              });
              request2.headers.forEach(function(value, name2) {
                if (names.indexOf(name2) === -1) {
                  xhr.setRequestHeader(name2, value);
                }
              });
            } else {
              request2.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request2.signal) {
              request2.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request2.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers2;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  })(browserPonyfill, browserPonyfill.exports);
  return browserPonyfill.exports;
}
var browserPonyfillExports = requireBrowserPonyfill();
const crossFetch = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
const CrossFetch = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: crossFetch
}, [browserPonyfillExports]);
const resolveHeaders = (headers) => {
  let oHeaders = {};
  if (headers) {
    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && browserPonyfillExports.Headers && headers instanceof browserPonyfillExports.Headers) {
      oHeaders = HeadersInstanceToPlainObject(headers);
    } else if (Array.isArray(headers)) {
      headers.forEach(([name2, value]) => {
        if (name2 && value !== void 0) {
          oHeaders[name2] = value;
        }
      });
    } else {
      oHeaders = headers;
    }
  }
  return oHeaders;
};
const cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
const buildRequestConfig = (params) => {
  if (!Array.isArray(params.query)) {
    const params_2 = params;
    const search = [`query=${encodeURIComponent(cleanQuery(params_2.query))}`];
    if (params.variables) {
      search.push(`variables=${encodeURIComponent(params_2.jsonSerializer.stringify(params_2.variables))}`);
    }
    if (params_2.operationName) {
      search.push(`operationName=${encodeURIComponent(params_2.operationName)}`);
    }
    return search.join(`&`);
  }
  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {
    throw new Error(`Cannot create query with given variable type, array expected`);
  }
  const params_ = params;
  const payload = params.query.reduce((acc, currentQuery, index) => {
    acc.push({
      query: cleanQuery(currentQuery),
      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : void 0
    });
    return acc;
  }, []);
  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;
};
const createHttpMethodFetcher = (method) => async (params) => {
  const { url, query, variables, operationName, fetch: fetch2, fetchOptions, middleware } = params;
  const headers = { ...params.headers };
  let queryParams = ``;
  let body = void 0;
  if (method === `POST`) {
    body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer);
    if (typeof body === `string`) {
      headers[`Content-Type`] = `application/json`;
    }
  } else {
    queryParams = buildRequestConfig({
      query,
      variables,
      operationName,
      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer
    });
  }
  const init = {
    method,
    headers,
    body,
    ...fetchOptions
  };
  let urlResolved = url;
  let initResolved = init;
  if (middleware) {
    const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }));
    const { url: urlNew, ...initNew } = result;
    urlResolved = urlNew;
    initResolved = initNew;
  }
  if (queryParams) {
    urlResolved = `${urlResolved}?${queryParams}`;
  }
  return await fetch2(urlResolved, initResolved);
};
class GraphQLClient {
  constructor(url, requestConfig = {}) {
    this.url = url;
    this.requestConfig = requestConfig;
    this.rawRequest = async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = crossFetch, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
      const { url: url2 } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const { operationName } = resolveRequestDocument(rawRequestOptions.query);
      return makeRequest({
        url: url2,
        query: rawRequestOptions.query,
        variables: rawRequestOptions.variables,
        headers: {
          ...resolveHeaders(callOrIdentity(headers)),
          ...resolveHeaders(rawRequestOptions.requestHeaders)
        },
        operationName,
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      }).then((response) => {
        if (responseMiddleware) {
          responseMiddleware(response);
        }
        return response;
      }).catch((error) => {
        if (responseMiddleware) {
          responseMiddleware(error);
        }
        throw error;
      });
    };
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = crossFetch, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const { query, operationName } = resolveRequestDocument(requestOptions.document);
    return makeRequest({
      url,
      query,
      variables: requestOptions.variables,
      headers: {
        ...resolveHeaders(callOrIdentity(headers)),
        ...resolveHeaders(requestOptions.requestHeaders)
      },
      operationName,
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    }).then((response) => {
      if (responseMiddleware) {
        responseMiddleware(response);
      }
      return response.data;
    }).catch((error) => {
      if (responseMiddleware) {
        responseMiddleware(error);
      }
      throw error;
    });
  }
  // prettier-ignore
  batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const queries = batchRequestOptions.documents.map(({ document }) => resolveRequestDocument(document).query);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    return makeRequest({
      url: this.url,
      query: queries,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables,
      headers: {
        ...resolveHeaders(callOrIdentity(headers)),
        ...resolveHeaders(batchRequestOptions.requestHeaders)
      },
      operationName: void 0,
      fetch: this.requestConfig.fetch ?? crossFetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    }).then((response) => {
      if (this.requestConfig.responseMiddleware) {
        this.requestConfig.responseMiddleware(response);
      }
      return response.data;
    }).catch((error) => {
      if (this.requestConfig.responseMiddleware) {
        this.requestConfig.responseMiddleware(error);
      }
      throw error;
    });
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
}
const makeRequest = async (params) => {
  const { query, variables, fetchOptions } = params;
  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`));
  const isBatchingQuery = Array.isArray(params.query);
  const response = await fetcher(params);
  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  const successfullyReceivedData = Array.isArray(result) ? !result.some(({ data }) => !data) : Boolean(result.data);
  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;
  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
    const { errors: _, ...rest } = Array.isArray(result) ? result : result;
    const data = fetchOptions.errorPolicy === `ignore` ? rest : result;
    const dataEnvelope = isBatchingQuery ? { data } : data;
    return {
      ...dataEnvelope,
      headers: response.headers,
      status: response.status
    };
  } else {
    const errorResult = typeof result === `string` ? {
      error: result
    } : result;
    throw new ClientError(
      // @ts-expect-error TODO
      { ...errorResult, status: response.status, headers: response.headers },
      { query, variables }
    );
  }
};
async function request(urlOrOptions, document, ...variablesAndRequestHeaders) {
  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document, ...variablesAndRequestHeaders);
  const client = new GraphQLClient(requestOptions.url);
  return client.request({
    ...requestOptions
  });
}
const createRequestBody = (query, variables, operationName, jsonSerializer) => {
  const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer;
  if (!Array.isArray(query)) {
    return jsonSerializer_.stringify({ query, variables, operationName });
  }
  if (typeof variables !== `undefined` && !Array.isArray(variables)) {
    throw new Error(`Cannot create request body with given variable type, array expected`);
  }
  const payload = query.reduce((acc, currentQuery, index) => {
    acc.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
    return acc;
  }, []);
  return jsonSerializer_.stringify(payload);
};
const getResult = async (response, jsonSerializer) => {
  let contentType;
  response.headers.forEach((value, key) => {
    if (key.toLowerCase() === `content-type`) {
      contentType = value;
    }
  });
  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {
    return jsonSerializer.parse(await response.text());
  } else {
    return response.text();
  }
};
const callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};
const gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};
async function requestGraphql(...args) {
  const [url, ...requestArgs] = args;
  const client = new GraphQLClient(url, { fetch });
  const { errors, ...response } = await client.request(...requestArgs);
  const result = { ...response };
  if (errors == null ? void 0 : errors.length) {
    result.errors = errors.map(({ message, ...options }) => new GraphQLError(message, options));
  }
  return result;
}
function getFields(type2) {
  if (type2 instanceof GraphQLObjectType) {
    return Object.entries(type2.getFields()).map(([fieldName, field]) => {
      const fieldType = field.type instanceof GraphQLNonNull ? field.type.ofType : field.type;
      if (fieldType instanceof GraphQLObjectType || fieldType instanceof GraphQLUnionType) {
        return `${fieldName} { ${getFields(fieldType)} }`;
      }
      if (fieldType instanceof GraphQLList) {
        const listItemType = fieldType.ofType instanceof GraphQLNonNull ? fieldType.ofType.ofType : fieldType.ofType;
        if (listItemType instanceof GraphQLScalarType) {
          return fieldName;
        } else if (listItemType instanceof GraphQLObjectType || listItemType instanceof GraphQLUnionType) {
          return `${fieldName} { ${getFields(listItemType)} }`;
        } else {
          throw new Error(`List item type ${listItemType.toString()} is not handled`);
        }
      }
      return fieldName;
    }).join(" ");
  } else if (type2 instanceof GraphQLUnionType) {
    return type2.getTypes().map((unionType2) => {
      return `... on ${unionType2.name} { ${getFields(unionType2)} }`;
    }).join(" ");
  }
  return "";
}
function generateDocumentStateQueryFields(documentModelState2, options) {
  const name2 = pascalCase(documentModelState2.name);
  const spec = documentModelState2.specifications.at(-1);
  if (!spec) {
    throw new Error("No document model specification found");
  }
  const source = `${spec.state.global.schema} type Query { ${name2}: ${name2}State }`;
  const schema = buildSchema(source);
  const queryType = schema.getQueryType();
  if (!queryType) {
    throw new Error("No query type found");
  }
  const fields = queryType.getFields();
  const stateQuery = fields[name2];
  if (!stateQuery) {
    throw new Error("No state query found");
  }
  const queryFields = getFields(stateQuery.type);
  return queryFields;
}
async function requestPublicDrive(url) {
  var _a2, _b;
  let drive;
  try {
    const result = await requestGraphql(url, gql`
        query getDrive {
          drive {
            id
            name
            icon
            slug
            meta {
              preferredEditor
            }
          }
        }
      `);
    if (((_a2 = result.errors) == null ? void 0 : _a2.length) || !result.drive) {
      throw ((_b = result.errors) == null ? void 0 : _b.at(0)) ?? new Error("Drive not found");
    }
    drive = result.drive;
  } catch (e) {
    logger$1.error(e);
    throw new Error("Couldn't find drive info");
  }
  return drive;
}
async function fetchDocument(url, documentId, documentModelModule) {
  const { documentModel, utils } = documentModelModule;
  const stateFields = generateDocumentStateQueryFields(documentModel);
  const name2 = pascalCase(documentModel.name);
  const result = await requestGraphql(url, gql`
            query ($id: String!) {
                document(id: $id) {
                    id
                    name
                    created
                    documentType
                    lastModified
                    revision
                    operations {
                        id
                        error
                        hash
                        index
                        skip
                        timestamp
                        type
                        inputText
                        context {
                            signer {
                                user {
                                    address
                                    networkId
                                    chainId
                                }
                                app {
                                    name
                                    key
                                }
                                signatures
                            }
                        }
                    }
                    ... on ${name2} {
                        state {
                            ${stateFields}
                        }
                        initialState {
                            ${stateFields}
                        }
                    }
                }
            }
        `, { id: documentId });
  const document = result.document ? {
    ...result.document,
    revision: {
      global: result.document.revision.global,
      local: 0
    },
    state: result.document.state,
    operations: {
      global: result.document.operations.map(({ inputText, ...o }) => ({
        ...o,
        error: o.error ?? void 0,
        scope: "global",
        input: JSON.parse(inputText)
      })),
      local: []
    },
    attachments: {},
    initialState: utils.createExtendedState({
      // TODO: getDocument should return all the initial state fields
      created: result.document.created,
      lastModified: result.document.created,
      state: utils.createState({
        global: result.document.initialState.state.global
      })
    }),
    clipboard: []
  } : null;
  return {
    ...result,
    document
  };
}
class ReadModeService {
  constructor(getDocumentModelModule) {
    __privateAdd(this, _ReadModeService_instances);
    __privateAdd(this, _getDocumentModelModule);
    __privateAdd(this, _drives, /* @__PURE__ */ new Map());
    __privateSet(this, _getDocumentModelModule, getDocumentModelModule);
  }
  async fetchDrive(id) {
    const drive = __privateGet(this, _drives).get(id);
    if (!drive) {
      return new ReadDriveNotFoundError(id);
    }
    const document = await this.fetchDocument(id, id, documentType);
    if (document instanceof Error) {
      return document;
    }
    const result = { ...document, readContext: drive.context };
    drive.drive = result;
    return result;
  }
  async fetchDocument(driveId, documentId, documentType2) {
    const drive = __privateGet(this, _drives).get(driveId);
    if (!drive) {
      return new ReadDriveNotFoundError(driveId);
    }
    let documentModelModule = void 0;
    try {
      documentModelModule = __privateGet(this, _getDocumentModelModule).call(this, documentType2);
    } catch (error) {
      return new DocumentModelNotFoundError(documentType2, error);
    }
    const { url } = drive.context;
    const { errors, document } = await fetchDocument(url, documentId, documentModelModule);
    if (errors) {
      const error = __privateMethod(this, _ReadModeService_instances, parseGraphQLErrors_fn).call(this, errors, driveId, documentId);
      if (error instanceof ReadDriveError) {
        return error;
      } else if (error) {
        throw error;
      }
    }
    if (!document) {
      return new ReadDocumentNotFoundError(driveId, documentId);
    }
    return document;
  }
  async addReadDrive(url, options) {
    const { id } = (options == null ? void 0 : options.expectedDriveInfo) ?? await requestPublicDrive(url);
    const result = await __privateMethod(this, _ReadModeService_instances, fetchDrive_fn).call(this, id, url);
    if (result instanceof Error) {
      throw result;
    } else if (!result) {
      throw new ReadDriveNotFoundError(id);
    }
    __privateGet(this, _drives).set(id, {
      drive: result,
      context: {
        ...options,
        url
      }
    });
  }
  async getReadDrives() {
    return Promise.resolve([...__privateGet(this, _drives).keys()]);
  }
  async getReadDrive(id) {
    const result = __privateGet(this, _drives).get(id);
    return Promise.resolve(result ? { ...result.drive, readContext: result.context } : new ReadDriveNotFoundError(id));
  }
  async getReadDriveBySlug(slug) {
    const readDrive = [...__privateGet(this, _drives).values()].find(({ drive }) => drive.state.global.slug === slug);
    return Promise.resolve(readDrive ? { ...readDrive.drive, readContext: readDrive.context } : new ReadDriveSlugNotFoundError(slug));
  }
  getReadDriveContext(id) {
    var _a2;
    return Promise.resolve(((_a2 = __privateGet(this, _drives).get(id)) == null ? void 0 : _a2.context) ?? new ReadDriveNotFoundError(id));
  }
  deleteReadDrive(id) {
    const deleted = __privateGet(this, _drives).delete(id);
    return Promise.resolve(deleted ? void 0 : new ReadDriveNotFoundError(id));
  }
}
_getDocumentModelModule = new WeakMap();
_drives = new WeakMap();
_ReadModeService_instances = new WeakSet();
parseGraphQLErrors_fn = function(errors, driveId, documentId) {
  for (const error of errors) {
    if (error.message === `Drive with id ${driveId} not found`) {
      return new ReadDriveNotFoundError(driveId);
    } else if (documentId && error.message === `Document with id ${documentId} not found`) {
      return new ReadDocumentNotFoundError(driveId, documentId);
    }
  }
  const firstError = errors.at(0);
  if (firstError) {
    return firstError;
  }
};
fetchDrive_fn = async function(id, url) {
  const { errors, document } = await fetchDocument(url, id, driveDocumentModelModule);
  const error = errors ? __privateMethod(this, _ReadModeService_instances, parseGraphQLErrors_fn).call(this, errors, id) : void 0;
  return error || document;
};
function ReadModeServer(Base) {
  var _readModeStorage, _listeners, _ReadMode_instances, buildDrives_fn, notifyListeners_fn, _a2;
  return _a2 = class extends Base {
    constructor(...args) {
      super(...args);
      __privateAdd(this, _ReadMode_instances);
      __privateAdd(this, _readModeStorage);
      __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
      __privateSet(this, _readModeStorage, new ReadModeService(this.getDocumentModelModule.bind(this)));
      __privateMethod(this, _ReadMode_instances, buildDrives_fn).call(this).then((drives) => {
        if (drives.length) {
          __privateMethod(this, _ReadMode_instances, notifyListeners_fn).call(this, drives, "add");
        }
      }).catch(logger$1.error);
    }
    getReadDrives() {
      return __privateGet(this, _readModeStorage).getReadDrives();
    }
    getReadDrive(id) {
      return __privateGet(this, _readModeStorage).getReadDrive(id);
    }
    getReadDriveBySlug(slug) {
      return __privateGet(this, _readModeStorage).getReadDriveBySlug(slug);
    }
    getReadDriveContext(id) {
      return __privateGet(this, _readModeStorage).getReadDriveContext(id);
    }
    async addReadDrive(url, options) {
      await __privateGet(this, _readModeStorage).addReadDrive(url, options);
      __privateMethod(this, _ReadMode_instances, notifyListeners_fn).call(this, await __privateMethod(this, _ReadMode_instances, buildDrives_fn).call(this), "add");
    }
    fetchDrive(id) {
      return __privateGet(this, _readModeStorage).fetchDrive(id);
    }
    fetchDocument(driveId, documentId, documentType2) {
      return __privateGet(this, _readModeStorage).fetchDocument(driveId, documentId, documentType2);
    }
    async deleteReadDrive(id) {
      const error = await __privateGet(this, _readModeStorage).deleteReadDrive(id);
      if (error) {
        return error;
      }
      __privateMethod(this, _ReadMode_instances, notifyListeners_fn).call(this, await __privateMethod(this, _ReadMode_instances, buildDrives_fn).call(this), "delete");
    }
    async migrateReadDrive(id, options) {
      const result = await this.getReadDriveContext(id);
      if (result instanceof Error) {
        return result;
      }
      const { url, ...readOptions } = result;
      try {
        const newDrive = await this.addRemoteDrive(url, options);
        return newDrive;
      } catch (error) {
        logger$1.error(error);
        await this.addReadDrive(result.url, readOptions);
        throw error;
      }
    }
    onReadDrivesUpdate(listener) {
      __privateGet(this, _listeners).add(listener);
      return Promise.resolve(() => __privateGet(this, _listeners).delete(listener));
    }
  }, _readModeStorage = new WeakMap(), _listeners = new WeakMap(), _ReadMode_instances = new WeakSet(), buildDrives_fn = async function() {
    const driveIds = await this.getReadDrives();
    const drives = (await Promise.all(driveIds.map((driveId) => this.getReadDrive(driveId)))).filter((drive) => !(drive instanceof Error));
    return drives;
  }, notifyListeners_fn = function(drives, operation) {
    __privateGet(this, _listeners).forEach((listener) => listener(drives, operation));
  }, _a2;
}
function isReadModeDriveServer(obj) {
  return typeof obj.getReadDrives === "function";
}
class DefaultDrivesManager {
  constructor(server, delegate, options) {
    __publicField(this, "server");
    __publicField(this, "delegate");
    __publicField(this, "defaultRemoteDrives", /* @__PURE__ */ new Map());
    __publicField(this, "removeOldRemoteDrivesConfig");
    this.server = server;
    this.delegate = delegate;
    if (options == null ? void 0 : options.defaultDrives.remoteDrives) {
      for (const defaultDrive of options.defaultDrives.remoteDrives) {
        this.defaultRemoteDrives.set(defaultDrive.url, {
          ...defaultDrive,
          status: "PENDING"
        });
      }
    }
    this.removeOldRemoteDrivesConfig = (options == null ? void 0 : options.defaultDrives.removeOldRemoteDrives) || {
      strategy: "preserve-all"
    };
  }
  getDefaultRemoteDrives() {
    return new Map(JSON.parse(JSON.stringify(Array.from(this.defaultRemoteDrives))));
  }
  async deleteDriveById(driveId) {
    try {
      await this.server.deleteDrive(driveId);
    } catch (error) {
      if (!(error instanceof DriveNotFoundError)) {
        logger$1.error(error);
      }
    }
  }
  async preserveDrivesById(driveIdsToPreserve, drives, removeStrategy = "detach") {
    const getAllDrives = drives.map((driveId) => this.server.getDrive(driveId));
    const drivesToRemove = (await Promise.all(getAllDrives)).filter((drive) => drive.state.local.listeners.length > 0 || drive.state.local.triggers.length > 0).filter((drive) => !driveIdsToPreserve.includes(drive.state.global.id));
    const driveIds = drivesToRemove.map((drive) => drive.state.global.id);
    if (removeStrategy === "detach") {
      await this.detachDrivesById(driveIds);
    } else {
      await this.removeDrivesById(driveIds);
    }
  }
  async removeDrivesById(driveIds) {
    for (const driveId of driveIds) {
      await this.deleteDriveById(driveId);
    }
  }
  async detachDrivesById(driveIds) {
    const detachDrivesPromises = driveIds.map((driveId) => this.delegate.detachDrive(driveId));
    await Promise.all(detachDrivesPromises);
  }
  async removeOldremoteDrives() {
    const driveids = await this.server.getDrives();
    switch (this.removeOldRemoteDrivesConfig.strategy) {
      case "preserve-by-id-and-detach":
      case "preserve-by-id": {
        const detach = this.removeOldRemoteDrivesConfig.strategy === "preserve-by-id-and-detach" ? "detach" : "remove";
        await this.preserveDrivesById(this.removeOldRemoteDrivesConfig.ids, driveids, detach);
        break;
      }
      case "preserve-by-url-and-detach":
      case "preserve-by-url": {
        const detach = this.removeOldRemoteDrivesConfig.strategy === "preserve-by-url-and-detach" ? "detach" : "remove";
        const getDrivesInfo = this.removeOldRemoteDrivesConfig.urls.map((url) => requestPublicDrive(url));
        const drivesIdsToPreserve = (await Promise.all(getDrivesInfo)).map((driveInfo) => driveInfo.id);
        await this.preserveDrivesById(drivesIdsToPreserve, driveids, detach);
        break;
      }
      case "remove-by-id": {
        const drivesIdsToRemove = this.removeOldRemoteDrivesConfig.ids.filter((driveId) => driveids.includes(driveId));
        await this.removeDrivesById(drivesIdsToRemove);
        break;
      }
      case "remove-by-url": {
        const getDrivesInfo = this.removeOldRemoteDrivesConfig.urls.map((driveUrl) => requestPublicDrive(driveUrl));
        const drivesInfo = await Promise.all(getDrivesInfo);
        const drivesIdsToRemove = drivesInfo.map((driveInfo) => driveInfo.id).filter((driveId) => driveids.includes(driveId));
        await this.removeDrivesById(drivesIdsToRemove);
        break;
      }
      case "remove-all": {
        const getDrives = driveids.map((driveId) => this.server.getDrive(driveId));
        const drives = await Promise.all(getDrives);
        const drivesToRemove = drives.filter((drive) => drive.state.local.listeners.length > 0 || drive.state.local.triggers.length > 0).map((drive) => drive.state.global.id);
        await this.removeDrivesById(drivesToRemove);
        break;
      }
      case "detach-by-id": {
        const drivesIdsToRemove = this.removeOldRemoteDrivesConfig.ids.filter((driveId) => driveids.includes(driveId));
        const detachDrivesPromises = drivesIdsToRemove.map((driveId) => this.delegate.detachDrive(driveId));
        await Promise.all(detachDrivesPromises);
        break;
      }
      case "detach-by-url": {
        const getDrivesInfo = this.removeOldRemoteDrivesConfig.urls.map((driveUrl) => requestPublicDrive(driveUrl));
        const drivesInfo = await Promise.all(getDrivesInfo);
        const drivesIdsToRemove = drivesInfo.map((driveInfo) => driveInfo.id).filter((driveId) => driveids.includes(driveId));
        const detachDrivesPromises = drivesIdsToRemove.map((driveId) => this.delegate.detachDrive(driveId));
        await Promise.all(detachDrivesPromises);
        break;
      }
    }
  }
  async setAllDefaultDrivesAccessLevel(level) {
    const drives = this.defaultRemoteDrives.values();
    for (const drive of drives) {
      await this.setDefaultDriveAccessLevel(drive.url, level);
    }
  }
  async setDefaultDriveAccessLevel(url, level) {
    const drive = this.defaultRemoteDrives.get(url);
    if (drive && drive.options.accessLevel !== level) {
      const newDriveValue = {
        ...drive,
        options: { ...drive.options, accessLevel: level }
      };
      this.defaultRemoteDrives.set(url, newDriveValue);
      await this.initializeDefaultRemoteDrives([newDriveValue]);
    }
  }
  async initializeDefaultRemoteDrives(defaultDrives = Array.from(this.defaultRemoteDrives.values())) {
    const drives = await this.server.getDrives();
    const readServer = isReadModeDriveServer(this.server) ? this.server : void 0;
    const readDrives = await (readServer == null ? void 0 : readServer.getReadDrives());
    for (const remoteDrive of defaultDrives) {
      let remoteDriveInfo = { ...remoteDrive };
      try {
        const driveInfo = remoteDrive.metadata ?? await requestPublicDrive(remoteDrive.url);
        remoteDriveInfo = { ...remoteDrive, metadata: driveInfo };
        this.defaultRemoteDrives.set(remoteDrive.url, remoteDriveInfo);
        const driveIsAdded = drives.includes(driveInfo.id);
        const readDriveIsAdded = readDrives == null ? void 0 : readDrives.includes(driveInfo.id);
        const hasAccessLevel = remoteDrive.options.accessLevel !== void 0;
        const readMode = readServer && remoteDrive.options.accessLevel === "READ";
        const isAdded = readMode ? readDriveIsAdded : driveIsAdded;
        const driveToDelete = hasAccessLevel && (readMode ? driveIsAdded : readDriveIsAdded);
        if (driveToDelete) {
          try {
            await (readMode ? this.server.deleteDrive(driveInfo.id) : readServer == null ? void 0 : readServer.deleteReadDrive(driveInfo.id));
          } catch (e) {
            logger$1.error(e);
          }
        }
        if (isAdded) {
          remoteDriveInfo.status = "ALREADY_ADDED";
          this.defaultRemoteDrives.set(remoteDrive.url, remoteDriveInfo);
          this.delegate.emit("ALREADY_ADDED", this.defaultRemoteDrives, remoteDriveInfo, driveInfo.id, driveInfo.name);
          continue;
        }
        remoteDriveInfo.status = "ADDING";
        this.defaultRemoteDrives.set(remoteDrive.url, remoteDriveInfo);
        this.delegate.emit("ADDING", this.defaultRemoteDrives, remoteDriveInfo);
        if (!hasAccessLevel && readServer || readMode) {
          await readServer.addReadDrive(remoteDrive.url, {
            ...remoteDrive.options,
            expectedDriveInfo: driveInfo
          });
        } else {
          await this.server.addRemoteDrive(remoteDrive.url, {
            ...remoteDrive.options,
            expectedDriveInfo: driveInfo
          });
        }
        remoteDriveInfo.status = "SUCCESS";
        this.defaultRemoteDrives.set(remoteDrive.url, remoteDriveInfo);
        this.delegate.emit("SUCCESS", this.defaultRemoteDrives, remoteDriveInfo, driveInfo.id, driveInfo.name);
      } catch (error) {
        remoteDriveInfo.status = "ERROR";
        this.defaultRemoteDrives.set(remoteDrive.url, remoteDriveInfo);
        this.delegate.emit("ERROR", this.defaultRemoteDrives, remoteDriveInfo, void 0, void 0, error);
      }
    }
  }
}
const PULL_DRIVE_INTERVAL = 1500;
const MAX_REVISIONS_PER_ACK = 100;
const _PullResponderTransmitter = class _PullResponderTransmitter {
  constructor(listener, manager) {
    __publicField(this, "logger", childLogger([
      "PullResponderTransmitter",
      Math.floor(Math.random() * 999).toString()
    ]));
    __publicField(this, "listener");
    __publicField(this, "manager");
    this.listener = listener;
    this.manager = manager;
    this.logger.verbose(`constructor(listener: ${listener.listenerId})`);
  }
  getStrands(options) {
    this.logger.verbose(`getStrands(drive: ${this.listener.driveId}, listener: ${this.listener.listenerId})`);
    return this.manager.getStrands(this.listener.driveId, this.listener.listenerId, options);
  }
  disconnect() {
    return Promise.resolve();
  }
  async processAcknowledge(driveId, listenerId, revisions) {
    this.logger.verbose(`processAcknowledge(drive: ${driveId}, listener: ${listenerId})`, revisions);
    const syncUnits = await this.manager.getListenerSyncUnitIds(driveId, listenerId);
    let success = true;
    for (const revision of revisions) {
      const syncUnit = syncUnits.find((s) => s.scope === revision.scope && s.branch === revision.branch && s.driveId === revision.driveId && s.documentId == revision.documentId);
      if (!syncUnit) {
        this.logger.warn("Unknown sync unit was acknowledged", revision);
        success = false;
        continue;
      }
      await this.manager.updateListenerRevision(listenerId, driveId, syncUnit.syncId, revision.revision);
    }
    return success;
  }
  static async registerPullResponder(driveId, url, filter) {
    var _a2;
    _PullResponderTransmitter.staticLogger.verbose(`registerPullResponder(url: ${url})`, filter);
    const result = await requestGraphql(url, gql`
        mutation registerPullResponderListener($filter: InputListenerFilter!) {
          registerPullResponderListener(filter: $filter) {
            listenerId
          }
        }
      `, { filter });
    const error = (_a2 = result.errors) == null ? void 0 : _a2.at(0);
    if (error) {
      throw error;
    }
    if (!result.registerPullResponderListener) {
      throw new Error("Error registering listener");
    }
    return result.registerPullResponderListener.listenerId;
  }
  static async pullStrands(driveId, url, listenerId, options) {
    var _a2;
    this.staticLogger.verbose(`pullStrands(url: ${url}, listener: ${listenerId})`);
    const result = await requestGraphql(url, gql`
        query strands($listenerId: ID!) {
          system {
            sync {
              strands(listenerId: $listenerId) {
                driveId
                documentId
                scope
                branch
                operations {
                  id
                  timestamp
                  skip
                  type
                  input
                  hash
                  index
                  context {
                    signer {
                      user {
                        address
                        networkId
                        chainId
                      }
                      app {
                        name
                        key
                      }
                      signatures
                    }
                  }
                }
              }
            }
          }
        }
      `, { listenerId });
    const error = (_a2 = result.errors) == null ? void 0 : _a2.at(0);
    if (error) {
      throw error;
    }
    if (!result.system) {
      return [];
    }
    return result.system.sync.strands.map((s) => ({
      ...s,
      operations: s.operations.map((o) => ({
        ...o,
        input: JSON.parse(o.input)
      }))
    }));
  }
  static async acknowledgeStrands(url, listenerId, revisions) {
    this.staticLogger.verbose(`acknowledgeStrands(url: ${url}, listener: ${listenerId})`, revisions);
    const chunks = [];
    for (let i = 0; i < revisions.length; i += MAX_REVISIONS_PER_ACK) {
      chunks.push(revisions.slice(i, i + MAX_REVISIONS_PER_ACK));
    }
    if (chunks.length > 1) {
      this.staticLogger.verbose(`Breaking strand acknowledgement into ${chunks.length} chunks...`);
    }
    const results = await Promise.allSettled(chunks.map(async (chunk) => {
      var _a2;
      const result = await requestGraphql(url, gql`
            mutation acknowledge(
              $listenerId: String!
              $revisions: [ListenerRevisionInput]
            ) {
              acknowledge(listenerId: $listenerId, revisions: $revisions)
            }
          `, { listenerId, revisions: chunk });
      const error = (_a2 = result.errors) == null ? void 0 : _a2.at(0);
      if (error) {
        throw error;
      }
      if (result.acknowledge === null || !result.acknowledge) {
        throw new Error("Error acknowledging strands");
      }
    }));
    const errors = results.filter((result) => result.status === "rejected");
    if (errors.length > 0) {
      throw new Error("Error acknowledging strands");
    }
  }
  static async executePull(driveId, trigger, onStrandUpdate, onError, onRevisions, onAcknowledge) {
    var _a2;
    this.staticLogger.verbose(`executePull(driveId: ${driveId}), trigger:`, trigger);
    try {
      const { url, listenerId } = trigger.data;
      const strands = await _PullResponderTransmitter.pullStrands(driveId, url, listenerId);
      this.staticLogger.verbose("Pulled strands...");
      if (!strands.length) {
        onRevisions == null ? void 0 : onRevisions([]);
        this.staticLogger.verbose("No new strands, skipping...");
        return;
      }
      const listenerRevisions = [];
      for (const strand of strands) {
        const operations = strand.operations.map((op) => ({
          ...op,
          scope: strand.scope,
          branch: strand.branch
        }));
        this.staticLogger.verbose("Processing strand...");
        let error = void 0;
        try {
          const result = await onStrandUpdate(strand, {
            type: "trigger",
            trigger
          });
          if (result.error) {
            throw result.error;
          }
        } catch (e) {
          error = e;
          onError(error);
        }
        listenerRevisions.push({
          branch: strand.branch,
          documentId: strand.documentId || "",
          driveId: strand.driveId,
          revision: ((_a2 = operations.pop()) == null ? void 0 : _a2.index) ?? -1,
          scope: strand.scope,
          status: error ? error instanceof OperationError ? error.status : "ERROR" : "SUCCESS",
          error
        });
      }
      this.staticLogger.verbose("Processed strands...");
      onRevisions == null ? void 0 : onRevisions(listenerRevisions);
      this.staticLogger.verbose("Acknowledging strands...");
      let success = false;
      try {
        await _PullResponderTransmitter.acknowledgeStrands(url, listenerId, listenerRevisions.map((revision) => {
          const { error, ...rest } = revision;
          return rest;
        }));
        success = true;
      } catch (error) {
        this.staticLogger.error("ACK error", error);
      }
      if (success) {
        this.staticLogger.verbose("Acknowledged strands successfully.");
      } else {
        this.staticLogger.error("Failed to acknowledge strands");
      }
      onAcknowledge == null ? void 0 : onAcknowledge(success);
    } catch (error) {
      this.staticLogger.error("Pull error", error);
      onError(error);
    }
  }
  static setupPull(driveId, trigger, onStrandUpdate, onError, onRevisions, onAcknowledge) {
    this.staticLogger.verbose(`setupPull(drive: ${driveId}), trigger:`, trigger);
    const { interval } = trigger.data;
    let loopInterval = PULL_DRIVE_INTERVAL;
    if (interval) {
      try {
        const intervalNumber = parseInt(interval);
        if (intervalNumber) {
          loopInterval = intervalNumber;
        }
      } catch {
      }
    }
    let isCancelled = false;
    let timeout;
    const executeLoop = async () => {
      while (!isCancelled) {
        this.staticLogger.verbose("Execute loop...");
        await this.executePull(driveId, trigger, onStrandUpdate, onError, onRevisions, onAcknowledge);
        await new Promise((resolve) => {
          this.staticLogger.verbose(`Scheduling next pull in ${loopInterval} ms`);
          timeout = setTimeout(resolve, loopInterval);
        });
      }
    };
    executeLoop().catch(this.staticLogger.error);
    return () => {
      isCancelled = true;
      if (timeout !== void 0) {
        clearTimeout(timeout);
      }
    };
  }
  static async createPullResponderTrigger(driveId, url, options) {
    this.staticLogger.verbose(`createPullResponderTrigger(drive: ${driveId}, url: ${url})`);
    const { pullFilter, pullInterval } = options;
    const listenerId = await _PullResponderTransmitter.registerPullResponder(driveId, url, pullFilter ?? {
      documentId: ["*"],
      documentType: ["*"],
      branch: ["*"],
      scope: ["*"]
    });
    const pullTrigger = {
      id: generateUUID(),
      type: "PullResponder",
      data: {
        url,
        listenerId,
        interval: (pullInterval == null ? void 0 : pullInterval.toString()) ?? ""
      }
    };
    return pullTrigger;
  }
  static isPullResponderTrigger(trigger) {
    return trigger.type === "PullResponder";
  }
};
__publicField(_PullResponderTransmitter, "staticLogger", childLogger([
  "PullResponderTransmitter",
  "static"
]));
let PullResponderTransmitter = _PullResponderTransmitter;
var TransmitterType;
(function(TransmitterType2) {
  TransmitterType2[TransmitterType2["Internal"] = 0] = "Internal";
  TransmitterType2[TransmitterType2["SwitchboardPush"] = 1] = "SwitchboardPush";
  TransmitterType2[TransmitterType2["PullResponder"] = 2] = "PullResponder";
  TransmitterType2[TransmitterType2["SecureConnect"] = 3] = "SecureConnect";
  TransmitterType2[TransmitterType2["MatrixConnect"] = 4] = "MatrixConnect";
  TransmitterType2[TransmitterType2["RESTWebhook"] = 5] = "RESTWebhook";
})(TransmitterType || (TransmitterType = {}));
const DefaultListenerManagerOptions = {
  sequentialUpdates: true
};
function filterOperationsByRevision(operations, revisions) {
  if (!revisions) {
    return operations;
  }
  return Object.keys(operations).reduce((acc, scope) => {
    const revision = revisions[scope];
    if (revision !== void 0) {
      acc[scope] = operations[scope].filter((op) => op.index <= revision);
    }
    return acc;
  }, { global: [], local: [] });
}
function isAtRevision(document, revisions) {
  return !revisions || Object.entries(revisions).find(([scope, revision]) => {
    const operation = document.operations[scope].at(-1);
    if (revision === -1) {
      return operation !== void 0;
    }
    return (operation == null ? void 0 : operation.index) !== revision;
  }) === void 0;
}
class BaseDocumentDriveServer {
  constructor(documentModelModules, storage, documentStorage, cache, queueManager, eventEmitter, synchronizationManager, listenerManager, options) {
    // external dependencies
    __publicField(this, "documentModelModules");
    __publicField(this, "storage");
    __publicField(this, "documentStorage");
    __publicField(this, "cache");
    __publicField(this, "queueManager");
    __publicField(this, "eventEmitter");
    __publicField(this, "options");
    __publicField(this, "listenerManager");
    __publicField(this, "synchronizationManager");
    // internal dependencies
    __publicField(this, "defaultDrivesManager");
    __publicField(this, "defaultDrivesManagerDelegate", {
      detachDrive: this.detachDrive.bind(this),
      emit: (...args) => this.eventEmitter.emit("defaultRemoteDrive", ...args)
    });
    __publicField(this, "queueDelegate", {
      checkDocumentExists: (documentId) => this.documentStorage.exists(documentId),
      processOperationJob: async ({ driveId, documentId, operations, options }) => {
        return documentId ? this.addOperations(driveId, documentId, operations, options) : this.addDriveOperations(driveId, operations, options);
      },
      processActionJob: async ({ driveId, documentId, actions: actions2, options }) => {
        return documentId ? this.addActions(driveId, documentId, actions2, options) : this.addDriveActions(driveId, actions2, options);
      },
      processJob: async (job) => {
        if (isOperationJob(job)) {
          return this.queueDelegate.processOperationJob(job);
        } else if (isActionJob(job)) {
          return this.queueDelegate.processActionJob(job);
        } else {
          throw new Error("Unknown job type", job);
        }
      }
    });
    // internal state
    __publicField(this, "triggerMap", /* @__PURE__ */ new Map());
    __publicField(this, "initializePromise");
    var _a2, _b;
    this.documentModelModules = documentModelModules;
    this.storage = storage;
    this.documentStorage = documentStorage;
    this.cache = cache;
    this.queueManager = queueManager;
    this.eventEmitter = eventEmitter;
    this.synchronizationManager = synchronizationManager;
    this.listenerManager = listenerManager;
    this.options = {
      ...options,
      defaultDrives: {
        ...options == null ? void 0 : options.defaultDrives
      },
      listenerManager: {
        ...DefaultListenerManagerOptions,
        ...options == null ? void 0 : options.listenerManager
      },
      taskQueueMethod: (options == null ? void 0 : options.taskQueueMethod) === void 0 ? RunAsap.runAsap : options.taskQueueMethod
    };
    this.defaultDrivesManager = new DefaultDrivesManager(this, this.defaultDrivesManagerDelegate, options);
    (_b = (_a2 = this.storage).setStorageDelegate) == null ? void 0 : _b.call(_a2, {
      getCachedOperations: async (drive, id) => {
        try {
          const document = await this.cache.getDocument(drive, id);
          return document == null ? void 0 : document.operations;
        } catch (error) {
          logger$1.error(error);
          return void 0;
        }
      }
    });
    this.initializePromise = this._initialize();
  }
  // workaround for testing the ephemeral listeners -- we don't have DI in place yet
  // todo: remove this once we have DI
  get listeners() {
    return this.listenerManager;
  }
  initialize() {
    return this.initializePromise;
  }
  async _initialize() {
    await this.listenerManager.initialize(this.handleListenerError);
    await this.queueManager.init(this.queueDelegate, (error) => {
      logger$1.error(`Error initializing queue manager`, error);
      errors.push(error);
    });
    try {
      await this.defaultDrivesManager.removeOldremoteDrives();
    } catch (error) {
      logger$1.error(error);
    }
    const errors = [];
    const drives = await this.getDrives();
    for (const drive of drives) {
      await this._initializeDrive(drive).catch((error) => {
        logger$1.error(`Error initializing drive ${drive}`, error);
        errors.push(error);
      });
    }
    if (this.options.defaultDrives.loadOnInit !== false) {
      await this.defaultDrivesManager.initializeDefaultRemoteDrives();
    }
    return errors.length === 0 ? null : errors;
  }
  setDocumentModelModules(modules) {
    this.documentModelModules = [...modules];
    this.synchronizationManager.setDocumentModelModules([...modules]);
    this.eventEmitter.emit("documentModelModules", [...modules]);
  }
  initializeDefaultRemoteDrives() {
    return this.defaultDrivesManager.initializeDefaultRemoteDrives();
  }
  getDefaultRemoteDrives() {
    return this.defaultDrivesManager.getDefaultRemoteDrives();
  }
  setDefaultDriveAccessLevel(url, level) {
    return this.defaultDrivesManager.setDefaultDriveAccessLevel(url, level);
  }
  setAllDefaultDrivesAccessLevel(level) {
    return this.defaultDrivesManager.setAllDefaultDrivesAccessLevel(level);
  }
  getOperationSource(source) {
    return source.type === "local" ? "push" : "pull";
  }
  handleListenerError(error, driveId, listener) {
    logger$1.error(`Listener ${listener.listener.label ?? listener.listener.listenerId} error:`, error);
    const status = error instanceof OperationError ? error.status : "ERROR";
    this.synchronizationManager.updateSyncStatus(driveId, { push: status }, error);
  }
  shouldSyncRemoteDrive(drive) {
    return drive.state.local.availableOffline && drive.state.local.triggers.length > 0;
  }
  async startSyncRemoteDrive(driveId) {
    let driveTriggers = this.triggerMap.get(driveId);
    const syncUnits = await this.getSynchronizationUnitsIds(driveId);
    const drive = await this.getDrive(driveId);
    for (const trigger of drive.state.local.triggers) {
      if (driveTriggers == null ? void 0 : driveTriggers.get(trigger.id)) {
        continue;
      }
      if (!driveTriggers) {
        driveTriggers = /* @__PURE__ */ new Map();
      }
      this.synchronizationManager.updateSyncStatus(driveId, {
        pull: "SYNCING"
      });
      for (const syncUnit of syncUnits) {
        this.synchronizationManager.updateSyncStatus(syncUnit.syncId, {
          pull: "SYNCING"
        });
      }
      if (PullResponderTransmitter.isPullResponderTrigger(trigger)) {
        let firstPull = true;
        const cancelPullLoop = PullResponderTransmitter.setupPull(driveId, trigger, this.saveStrand.bind(this), (error) => {
          const statusError = error instanceof OperationError ? error.status : "ERROR";
          this.synchronizationManager.updateSyncStatus(driveId, { pull: statusError }, error);
          if (error instanceof ClientError) {
            this.eventEmitter.emit("clientStrandsError", driveId, trigger, error.response.status, error.message);
          }
        }, (revisions) => {
          const errorRevision = revisions.filter((r) => r.status !== "SUCCESS");
          if (errorRevision.length < 1) {
            this.synchronizationManager.updateSyncStatus(driveId, {
              pull: "SUCCESS"
            });
          }
          const documentIdsFromRevision = revisions.filter((rev) => rev.documentId !== "").map((rev) => rev.documentId);
          this.getSynchronizationUnitsIds(driveId, documentIdsFromRevision).then((revSyncUnits) => {
            for (const syncUnit of revSyncUnits) {
              const fileErrorRevision = errorRevision.find((r) => r.documentId === syncUnit.documentId);
              if (fileErrorRevision) {
                this.synchronizationManager.updateSyncStatus(syncUnit.syncId, { pull: fileErrorRevision.status }, fileErrorRevision.error);
              } else {
                this.synchronizationManager.updateSyncStatus(syncUnit.syncId, {
                  pull: "SUCCESS"
                });
              }
            }
          }).catch(console.error);
          if (firstPull) {
            firstPull = false;
            const pushListener = drive.state.local.listeners.find((listener) => {
              var _a2;
              return trigger.data.url === ((_a2 = listener.callInfo) == null ? void 0 : _a2.data);
            });
            if (pushListener) {
              this.getSynchronizationUnitsRevision(driveId, syncUnits).then((syncUnitRevisions) => {
                for (const revision of syncUnitRevisions) {
                  this.listenerManager.updateListenerRevision(pushListener.listenerId, driveId, revision.syncId, revision.revision).catch(logger$1.error);
                }
              }).catch(logger$1.error);
            }
          }
        });
        driveTriggers.set(trigger.id, cancelPullLoop);
        this.triggerMap.set(driveId, driveTriggers);
      }
    }
  }
  async stopSyncRemoteDrive(driveId) {
    const syncUnits = await this.getSynchronizationUnitsIds(driveId);
    const filesNodeSyncId = syncUnits.filter((syncUnit) => syncUnit.documentId !== "").map((syncUnit) => syncUnit.syncId);
    const triggers = this.triggerMap.get(driveId);
    triggers == null ? void 0 : triggers.forEach((cancel) => cancel());
    this.synchronizationManager.updateSyncStatus(driveId, null);
    for (const fileNodeSyncId of filesNodeSyncId) {
      this.synchronizationManager.updateSyncStatus(fileNodeSyncId, null);
    }
    return this.triggerMap.delete(driveId);
  }
  async _initializeDrive(driveId) {
    const drive = await this.getDrive(driveId);
    await this.synchronizationManager.initializeDriveSyncStatus(driveId, drive);
    if (this.shouldSyncRemoteDrive(drive)) {
      await this.startSyncRemoteDrive(driveId);
    }
  }
  // Delegate synchronization methods to synchronizationManager
  getSynchronizationUnits(driveId, documentId, scope, branch, documentType2) {
    return this.synchronizationManager.getSynchronizationUnits(driveId, documentId, scope, branch, documentType2);
  }
  getSynchronizationUnitsIds(driveId, documentId, scope, branch, documentType2) {
    return this.synchronizationManager.getSynchronizationUnitsIds(driveId, documentId, scope, branch, documentType2);
  }
  getOperationData(driveId, syncId, filter) {
    return this.synchronizationManager.getOperationData(driveId, syncId, filter);
  }
  getSynchronizationUnitsRevision(driveId, syncUnitsQuery) {
    return this.synchronizationManager.getSynchronizationUnitsRevision(driveId, syncUnitsQuery);
  }
  getDocumentModelModule(documentType2) {
    const documentModelModule = this.documentModelModules.find((module) => module.documentModel.id === documentType2);
    if (!documentModelModule) {
      throw new Error(`Document type ${documentType2} not supported`);
    }
    return documentModelModule;
  }
  getDocumentModelModules() {
    return [...this.documentModelModules];
  }
  async addDrive(input, preferredEditor) {
    const id = input.global.id || generateUUID();
    if (!id) {
      throw new Error("Invalid Drive Id");
    }
    const drives = await this.storage.getDrives();
    if (drives.includes(id)) {
      throw new DriveAlreadyExistsError(id);
    }
    const document = createDocument({
      state: input
    });
    document.meta = {
      preferredEditor
    };
    await this.storage.createDrive(id, document);
    if (input.global.slug) {
      await this.cache.deleteDocument("drives-slug", input.global.slug);
    }
    await this._initializeDrive(id);
    this.eventEmitter.emit("driveAdded", document);
    return document;
  }
  async addRemoteDrive(url, options) {
    const { id, name: name2, slug, icon, meta } = options.expectedDriveInfo || await requestPublicDrive(url);
    const { pullFilter, pullInterval, availableOffline, sharingType, listeners, triggers } = options;
    const pullTrigger = await PullResponderTransmitter.createPullResponderTrigger(id, url, {
      pullFilter,
      pullInterval
    });
    return await this.addDrive({
      global: {
        id,
        name: name2,
        slug,
        icon: icon ?? null
      },
      local: {
        triggers: [...triggers, pullTrigger],
        listeners,
        availableOffline,
        sharingType
      }
    }, meta == null ? void 0 : meta.preferredEditor);
  }
  async deleteDrive(driveId) {
    const result = await Promise.allSettled([
      this.stopSyncRemoteDrive(driveId),
      this.listenerManager.removeDrive(driveId),
      this.cache.deleteDocument("drives", driveId),
      this.storage.deleteDrive(driveId)
    ]);
    result.forEach((r) => {
      if (r.status === "rejected") {
        throw r.reason;
      }
    });
  }
  getDrives() {
    return this.storage.getDrives();
  }
  async getDrive(driveId, options) {
    let document;
    try {
      const cachedDocument = await this.cache.getDocument("drives", driveId);
      if (cachedDocument && isDocumentDrive(cachedDocument)) {
        document = cachedDocument;
        if (isAtRevision(document, options == null ? void 0 : options.revisions)) {
          return document;
        }
      }
    } catch (e) {
      logger$1.error("Error getting drive from cache", e);
    }
    const driveStorage = document ?? await this.storage.getDrive(driveId);
    const result = this._buildDocument(driveStorage, options);
    if (!isDocumentDrive(result)) {
      throw new Error(`Document with id ${driveId} is not a Document Drive`);
    } else {
      if (!(options == null ? void 0 : options.revisions)) {
        this.cache.setDocument("drives", driveId, result).catch(logger$1.error);
      }
      return result;
    }
  }
  async getDriveBySlug(slug, options) {
    try {
      const document2 = await this.cache.getDocument("drives-slug", slug);
      if (document2 && isDocumentDrive(document2)) {
        return document2;
      }
    } catch (e) {
      logger$1.error("Error getting drive from cache", e);
    }
    const driveStorage = await this.storage.getDriveBySlug(slug);
    const document = this._buildDocument(driveStorage, options);
    if (!isDocumentDrive(document)) {
      throw new Error(`Document with slug ${slug} is not a Document Drive`);
    } else {
      this.cache.setDocument("drives-slug", slug, document).catch(logger$1.error);
      return document;
    }
  }
  async getDocument(driveId, documentId, options) {
    let cachedDocument;
    try {
      cachedDocument = await this.cache.getDocument(driveId, documentId);
      if (cachedDocument && isAtRevision(cachedDocument, options == null ? void 0 : options.revisions)) {
        return cachedDocument;
      }
    } catch (e) {
      logger$1.error("Error getting document from cache", e);
    }
    const documentStorage = cachedDocument ?? await this.storage.getDocument(driveId, documentId);
    const document = this._buildDocument(documentStorage, options);
    if (!(options == null ? void 0 : options.revisions)) {
      this.cache.setDocument(driveId, documentId, document).catch(logger$1.error);
    }
    return document;
  }
  getDocuments(driveId) {
    return this.storage.getDocuments(driveId);
  }
  async createDocument(driveId, input) {
    let state = void 0;
    if (input.document) {
      if (input.documentType !== input.document.documentType) {
        throw new Error(`Provided document is not ${input.documentType}`);
      }
      const doc = this._buildDocument(input.document);
      state = doc.state;
    }
    const document = input.document ?? this.getDocumentModelModule(input.documentType).utils.createDocument();
    const documentStorage = {
      name: document.name,
      revision: document.revision,
      documentType: document.documentType,
      created: document.created,
      lastModified: document.lastModified,
      operations: { global: [], local: [] },
      initialState: document.initialState,
      clipboard: [],
      state: state ?? document.state
    };
    await this.storage.createDocument(driveId, input.id, documentStorage);
    for (const syncUnit of input.synchronizationUnits) {
      this.synchronizationManager.updateSyncStatus(syncUnit.syncId, {
        pull: this.triggerMap.get(driveId) ? "INITIAL_SYNC" : void 0,
        push: this.listenerManager.driveHasListeners(driveId) ? "SUCCESS" : void 0
      });
    }
    const operations = Object.values(document.operations).flat();
    if (operations.length) {
      if (isDocumentDrive(document)) {
        await this.storage.addDriveOperations(driveId, operations, document);
      } else {
        await this.storage.addDocumentOperations(driveId, input.id, operations, document);
      }
    }
    return document;
  }
  async deleteDocument(driveId, documentId) {
    try {
      const syncUnits = await this.getSynchronizationUnitsIds(driveId, [
        documentId
      ]);
      for (const syncUnit of syncUnits) {
        this.synchronizationManager.updateSyncStatus(syncUnit.syncId, null);
      }
      await this.listenerManager.removeSyncUnits(driveId, syncUnits);
    } catch (error) {
      logger$1.warn("Error deleting document", error);
    }
    await this.cache.deleteDocument(driveId, documentId);
    return this.storage.deleteDocument(driveId, documentId);
  }
  async _processOperations(driveId, documentId, documentStorage, operations) {
    const operationsApplied = [];
    const signals = [];
    const documentStorageWithState = await this._addDocumentResultingStage(documentStorage, driveId, documentId);
    let document = this._buildDocument(documentStorageWithState);
    let error;
    const operationsByScope = groupOperationsByScope(operations);
    for (const scope of Object.keys(operationsByScope)) {
      const storageDocumentOperations = documentStorage.operations[scope];
      const branch = removeExistingOperations(operationsByScope[scope] || [], storageDocumentOperations);
      if (branch.length < 1) {
        continue;
      }
      const trunk = garbageCollect(sortOperations(storageDocumentOperations));
      const [invertedTrunk, tail] = attachBranch(trunk, branch);
      const newHistory = tail.length < 1 ? invertedTrunk : merge(trunk, invertedTrunk, reshuffleByTimestamp);
      const newOperations = newHistory.filter((op) => trunk.length < 1 || precedes(trunk[trunk.length - 1], op));
      for (const nextOperation of newOperations) {
        let skipHashValidation = false;
        if (tail.length > 0) {
          const sourceOperation = operations.find((op) => op.hash === nextOperation.hash);
          skipHashValidation = !sourceOperation || sourceOperation.index !== nextOperation.index || sourceOperation.skip !== nextOperation.skip;
        }
        try {
          const taskQueueMethod = this.options.taskQueueMethod;
          const task = () => this._performOperation(driveId, documentId, document, nextOperation, skipHashValidation);
          const appliedResult = await (taskQueueMethod ? runAsapAsync(task, taskQueueMethod) : task());
          document = appliedResult.document;
          signals.push(...appliedResult.signals);
          operationsApplied.push(appliedResult.operation);
        } catch (e) {
          error = e instanceof OperationError ? e : new OperationError("ERROR", nextOperation, e.message, e.cause);
          break;
        }
      }
    }
    return {
      document,
      operationsApplied,
      signals,
      error
    };
  }
  async _addDocumentResultingStage(document, driveId, documentId, options) {
    var _a2, _b, _c, _d;
    const operations = (options == null ? void 0 : options.revisions) !== void 0 ? filterOperationsByRevision(document.operations, options.revisions) : document.operations;
    const documentOperations = garbageCollectDocumentOperations(operations);
    for (const scope of Object.keys(documentOperations)) {
      const lastRemainingOperation = documentOperations[scope].at(-1);
      if (lastRemainingOperation && !lastRemainingOperation.resultingState) {
        lastRemainingOperation.resultingState = await (documentId ? (_b = (_a2 = this.storage).getOperationResultingState) == null ? void 0 : _b.call(_a2, driveId, documentId, lastRemainingOperation.index, lastRemainingOperation.scope, "main") : (_d = (_c = this.storage).getDriveOperationResultingState) == null ? void 0 : _d.call(_c, driveId, lastRemainingOperation.index, lastRemainingOperation.scope, "main"));
      }
    }
    return {
      ...document,
      operations: documentOperations
    };
  }
  _buildDocument(documentStorage, options) {
    if (documentStorage.state && (!options || options.checkHashes === false) && isAtRevision(documentStorage, options == null ? void 0 : options.revisions)) {
      return documentStorage;
    }
    const documentModelModule = this.getDocumentModelModule(documentStorage.documentType);
    const revisionOperations = (options == null ? void 0 : options.revisions) !== void 0 ? filterOperationsByRevision(documentStorage.operations, options.revisions) : documentStorage.operations;
    const operations = garbageCollectDocumentOperations(revisionOperations);
    return replayDocument(documentStorage.initialState, operations, documentModelModule.reducer, void 0, documentStorage, void 0, {
      ...options,
      checkHashes: (options == null ? void 0 : options.checkHashes) ?? true,
      reuseOperationResultingState: (options == null ? void 0 : options.checkHashes) ?? true
    });
  }
  async _performOperation(driveId, documentId, document, operation, skipHashValidation = false) {
    var _a2, _b, _c, _d;
    const documentModelModule = this.getDocumentModelModule(document.documentType);
    const signalResults = [];
    let newDocument = document;
    const scope = operation.scope;
    const documentOperations = garbageCollectDocumentOperations({
      ...document.operations,
      [scope]: skipHeaderOperations(document.operations[scope], operation)
    });
    const lastRemainingOperation = documentOperations[scope].at(-1);
    if (lastRemainingOperation && !lastRemainingOperation.resultingState) {
      lastRemainingOperation.resultingState = await (documentId ? (_b = (_a2 = this.storage).getOperationResultingState) == null ? void 0 : _b.call(_a2, driveId, documentId, lastRemainingOperation.index, lastRemainingOperation.scope, "main") : (_d = (_c = this.storage).getDriveOperationResultingState) == null ? void 0 : _d.call(_c, driveId, lastRemainingOperation.index, lastRemainingOperation.scope, "main"));
    }
    const operationSignals = [];
    newDocument = documentModelModule.reducer(newDocument, operation, (signal) => {
      let handler = void 0;
      switch (signal.type) {
        case "CREATE_CHILD_DOCUMENT":
          handler = () => this.createDocument(driveId, signal.input);
          break;
        case "DELETE_CHILD_DOCUMENT":
          handler = () => this.deleteDocument(driveId, signal.input.id);
          break;
        case "COPY_CHILD_DOCUMENT":
          handler = () => this.getDocument(driveId, signal.input.id).then((documentToCopy) => this.createDocument(driveId, {
            id: signal.input.newId,
            documentType: documentToCopy.documentType,
            document: documentToCopy,
            synchronizationUnits: signal.input.synchronizationUnits
          }));
          break;
      }
      if (handler) {
        operationSignals.push(() => handler().then((result) => ({ signal, result })));
      }
    }, { skip: operation.skip, reuseOperationResultingState: true });
    const appliedOperations = newDocument.operations[operation.scope].filter((op) => op.index == operation.index && op.skip == operation.skip);
    const appliedOperation = appliedOperations.at(0);
    if (!appliedOperation) {
      throw new OperationError("ERROR", operation, `Operation with index ${operation.index}:${operation.skip} was not applied.`);
    }
    if (!appliedOperation.error && appliedOperation.hash !== operation.hash && !skipHashValidation) {
      throw new ConflictOperationError(operation, appliedOperation);
    }
    for (const signalHandler of operationSignals) {
      const result = await signalHandler();
      signalResults.push(result);
    }
    return {
      document: newDocument,
      signals: signalResults,
      operation: appliedOperation
    };
  }
  addOperation(driveId, documentId, operation, options) {
    return this.addOperations(driveId, documentId, [operation], options);
  }
  async _addOperations(driveId, documentId, callback) {
    if (!this.storage.addDocumentOperationsWithTransaction) {
      const documentStorage = await this.storage.getDocument(driveId, documentId);
      const result = await callback(documentStorage);
      if (result.operations.length > 0) {
        await this.storage.addDocumentOperations(driveId, documentId, result.operations, result.header);
      }
    } else {
      await this.storage.addDocumentOperationsWithTransaction(driveId, documentId, callback);
    }
  }
  queueOperation(driveId, documentId, operation, options) {
    return this.queueOperations(driveId, documentId, [operation], options);
  }
  async resultIfExistingOperations(drive, id, operations) {
    try {
      const document = await this.getDocument(drive, id);
      const newOperation = operations.find((op) => !op.id || !document.operations[op.scope].find((existingOp) => existingOp.id === op.id && existingOp.index === op.index && existingOp.type === op.type && existingOp.hash === op.hash));
      if (!newOperation) {
        return {
          status: "SUCCESS",
          document,
          operations,
          signals: []
        };
      } else {
        return void 0;
      }
    } catch (error) {
      if (!error.message.includes(`Document with id ${id} not found`)) {
        console.error(error);
      }
      return void 0;
    }
  }
  async queueOperations(driveId, documentId, operations, options) {
    const result = await this.resultIfExistingOperations(driveId, documentId, operations);
    if (result) {
      return result;
    }
    try {
      const jobId = await this.queueManager.addJob({
        driveId,
        documentId,
        operations,
        options
      });
      return new Promise((resolve, reject) => {
        const unsubscribe = this.queueManager.on("jobCompleted", (job, result2) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            resolve(result2);
          }
        });
        const unsubscribeError = this.queueManager.on("jobFailed", (job, error) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            reject(error);
          }
        });
      });
    } catch (error) {
      logger$1.error("Error adding job", error);
      throw error;
    }
  }
  async queueAction(driveId, documentId, action, options) {
    return this.queueActions(driveId, documentId, [action], options);
  }
  async queueActions(driveId, documentId, actions2, options) {
    try {
      const jobId = await this.queueManager.addJob({
        driveId,
        documentId,
        actions: actions2,
        options
      });
      return new Promise((resolve, reject) => {
        const unsubscribe = this.queueManager.on("jobCompleted", (job, result) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            resolve(result);
          }
        });
        const unsubscribeError = this.queueManager.on("jobFailed", (job, error) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            reject(error);
          }
        });
      });
    } catch (error) {
      logger$1.error("Error adding job", error);
      throw error;
    }
  }
  async queueDriveAction(driveId, action, options) {
    return this.queueDriveActions(driveId, [action], options);
  }
  async queueDriveActions(driveId, actions2, options) {
    try {
      const jobId = await this.queueManager.addJob({
        driveId,
        actions: actions2,
        options
      });
      return new Promise((resolve, reject) => {
        const unsubscribe = this.queueManager.on("jobCompleted", (job, result) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            resolve(result);
          }
        });
        const unsubscribeError = this.queueManager.on("jobFailed", (job, error) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            reject(error);
          }
        });
      });
    } catch (error) {
      logger$1.error("Error adding drive job", error);
      throw error;
    }
  }
  async addOperations(driveId, documentId, operations, options) {
    const result = await this.resultIfExistingOperations(driveId, documentId, operations);
    if (result) {
      return result;
    }
    let document;
    const operationsApplied = [];
    const signals = [];
    let error;
    try {
      await this._addOperations(driveId, documentId, async (documentStorage) => {
        const result2 = await this._processOperations(driveId, documentId, documentStorage, operations);
        if (!result2.document) {
          logger$1.error("Invalid document");
          throw result2.error ?? new Error("Invalid document");
        }
        document = result2.document;
        error = result2.error;
        signals.push(...result2.signals);
        operationsApplied.push(...result2.operationsApplied);
        return {
          operations: result2.operationsApplied,
          header: result2.document,
          newState: document.state
        };
      });
      if (document) {
        this.cache.setDocument(driveId, documentId, document).catch(logger$1.error);
      }
      const { scopes, branches } = operationsApplied.reduce((acc, operation) => {
        if (!acc.scopes.includes(operation.scope)) {
          acc.scopes.push(operation.scope);
        }
        return acc;
      }, { scopes: [], branches: ["main"] });
      const syncUnits = await this.getSynchronizationUnits(driveId, [documentId], scopes, branches);
      const newOp = operationsApplied.find((appliedOp) => !operations.find((o) => o.id === appliedOp.id && o.index === appliedOp.index && o.skip === appliedOp.skip && o.hash === appliedOp.hash));
      const source = newOp ? { type: "local" } : (options == null ? void 0 : options.source) ?? { type: "local" };
      const operationSource = this.getOperationSource(source);
      this.listenerManager.updateSynchronizationRevisions(driveId, syncUnits, source, () => {
        this.synchronizationManager.updateSyncStatus(driveId, {
          [operationSource]: "SYNCING"
        });
        for (const syncUnit of syncUnits) {
          this.synchronizationManager.updateSyncStatus(syncUnit.syncId, {
            [operationSource]: "SYNCING"
          });
        }
      }, this.handleListenerError.bind(this), (options == null ? void 0 : options.forceSync) ?? source.type === "local").then((updates) => {
        if (updates.length) {
          this.synchronizationManager.updateSyncStatus(driveId, {
            [operationSource]: "SUCCESS"
          });
        }
        for (const syncUnit of syncUnits) {
          this.synchronizationManager.updateSyncStatus(syncUnit.syncId, {
            [operationSource]: "SUCCESS"
          });
        }
      }).catch((error2) => {
        logger$1.error("Non handled error updating sync revision", error2);
        this.synchronizationManager.updateSyncStatus(driveId, {
          [operationSource]: "ERROR"
        }, error2);
        for (const syncUnit of syncUnits) {
          this.synchronizationManager.updateSyncStatus(syncUnit.syncId, {
            [operationSource]: "ERROR"
          }, error2);
        }
      });
      if (error) {
        throw error;
      }
      return {
        status: "SUCCESS",
        document,
        operations: operationsApplied,
        signals
      };
    } catch (error2) {
      const operationError = error2 instanceof OperationError ? error2 : new OperationError("ERROR", void 0, error2.message, error2.cause);
      return {
        status: operationError.status,
        error: operationError,
        document,
        operations: operationsApplied,
        signals
      };
    }
  }
  addDriveOperation(driveId, operation, options) {
    return this.addDriveOperations(driveId, [operation], options);
  }
  async clearStorage() {
    var _a2, _b;
    for (const drive of await this.getDrives()) {
      await this.deleteDrive(drive);
    }
    await ((_b = (_a2 = this.storage).clearStorage) == null ? void 0 : _b.call(_a2));
  }
  async _addDriveOperations(driveId, callback) {
    if (!this.storage.addDriveOperationsWithTransaction) {
      const documentStorage = await this.storage.getDrive(driveId);
      const result = await callback(documentStorage);
      if (result.operations.length > 0) {
        await this.storage.addDriveOperations(driveId, result.operations, result.header);
      }
      return result;
    } else {
      return this.storage.addDriveOperationsWithTransaction(driveId, callback);
    }
  }
  queueDriveOperation(driveId, operation, options) {
    return this.queueDriveOperations(driveId, [operation], options);
  }
  async resultIfExistingDriveOperations(driveId, operations) {
    try {
      const drive = await this.getDrive(driveId);
      const newOperation = operations.find((op) => !op.id || !drive.operations[op.scope].find((existingOp) => existingOp.id === op.id && existingOp.index === op.index && existingOp.type === op.type && existingOp.hash === op.hash));
      if (!newOperation) {
        return {
          status: "SUCCESS",
          document: drive,
          operations,
          signals: []
        };
      } else {
        return void 0;
      }
    } catch (error) {
      console.error(error);
      return void 0;
    }
  }
  async queueDriveOperations(driveId, operations, options) {
    const result = await this.resultIfExistingDriveOperations(driveId, operations);
    if (result) {
      return result;
    }
    try {
      const jobId = await this.queueManager.addJob({
        driveId,
        operations,
        options
      });
      return new Promise((resolve, reject) => {
        const unsubscribe = this.queueManager.on("jobCompleted", (job, result2) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            resolve(result2);
          }
        });
        const unsubscribeError = this.queueManager.on("jobFailed", (job, error) => {
          if (job.jobId === jobId) {
            unsubscribe();
            unsubscribeError();
            reject(error);
          }
        });
      });
    } catch (error) {
      logger$1.error("Error adding drive job", error);
      throw error;
    }
  }
  async addDriveOperations(driveId, operations, options) {
    let document;
    const operationsApplied = [];
    const signals = [];
    let error;
    const result = await this.resultIfExistingDriveOperations(driveId, operations);
    if (result) {
      return result;
    }
    try {
      await this._addDriveOperations(driveId, async (documentStorage) => {
        const result2 = await this._processOperations(driveId, void 0, documentStorage, operations.slice());
        document = result2.document;
        operationsApplied.push(...result2.operationsApplied);
        signals.push(...result2.signals);
        error = result2.error;
        return {
          operations: result2.operationsApplied,
          header: result2.document
        };
      });
      if (!document || !isDocumentDrive(document)) {
        throw error ?? new Error("Invalid Document Drive document");
      }
      this.cache.setDocument("drives", driveId, document).catch(logger$1.error);
      const lastOperation = operationsApplied.filter((op) => op.scope === "global").slice().pop();
      if (lastOperation) {
        const newOp = operationsApplied.find((appliedOp) => !operations.find((o) => o.id === appliedOp.id && o.index === appliedOp.index && o.skip === appliedOp.skip && o.hash === appliedOp.hash));
        const source = newOp ? { type: "local" } : (options == null ? void 0 : options.source) ?? { type: "local" };
        const operationSource = this.getOperationSource(source);
        this.listenerManager.updateSynchronizationRevisions(driveId, [
          {
            syncId: "0",
            driveId,
            documentId: "",
            scope: "global",
            branch: "main",
            documentType: "powerhouse/document-drive",
            lastUpdated: lastOperation.timestamp,
            revision: lastOperation.index
          }
        ], source, () => {
          this.synchronizationManager.updateSyncStatus(driveId, {
            [operationSource]: "SYNCING"
          });
        }, this.handleListenerError.bind(this), (options == null ? void 0 : options.forceSync) ?? source.type === "local").then((updates) => {
          if (updates.length) {
            this.synchronizationManager.updateSyncStatus(driveId, {
              [operationSource]: "SUCCESS"
            });
          }
        }).catch((error2) => {
          logger$1.error("Non handled error updating sync revision", error2);
          this.synchronizationManager.updateSyncStatus(driveId, {
            [operationSource]: "ERROR"
          }, error2);
        });
      }
      if (this.shouldSyncRemoteDrive(document)) {
        this.startSyncRemoteDrive(driveId);
      } else {
        this.stopSyncRemoteDrive(driveId);
      }
      if (error) {
        throw error;
      }
      return {
        status: "SUCCESS",
        document,
        operations: operationsApplied,
        signals
      };
    } catch (error2) {
      const operationError = error2 instanceof OperationError ? error2 : new OperationError("ERROR", void 0, error2.message, error2.cause);
      return {
        status: operationError.status,
        error: operationError,
        document,
        operations: operationsApplied,
        signals
      };
    }
  }
  _buildOperations(documentId, actions2) {
    const operations = [];
    const { reducer: reducer2 } = this.getDocumentModelModule(documentId.documentType);
    for (const action of actions2) {
      documentId = reducer2(documentId, action);
      const operation = documentId.operations[action.scope].slice().pop();
      if (!operation) {
        throw new Error("Error creating operations");
      }
      operations.push(operation);
    }
    return operations;
  }
  async addAction(driveId, documentId, action, options) {
    return this.addActions(driveId, documentId, [action], options);
  }
  async addActions(driveId, documentId, actions2, options) {
    const document = await this.getDocument(driveId, documentId);
    const operations = this._buildOperations(document, actions2);
    return this.addOperations(driveId, documentId, operations, options);
  }
  async addDriveAction(driveId, action, options) {
    return this.addDriveActions(driveId, [action], options);
  }
  async addDriveActions(driveId, actions2, options) {
    const document = await this.getDrive(driveId);
    const operations = this._buildOperations(document, actions2);
    const result = await this.addDriveOperations(driveId, operations, options);
    return result;
  }
  async detachDrive(driveId) {
    const documentDrive = await this.getDrive(driveId);
    const listeners = documentDrive.state.local.listeners || [];
    const triggers = documentDrive.state.local.triggers || [];
    for (const listener of listeners) {
      await this.addDriveAction(driveId, removeListener({ listenerId: listener.listenerId }));
    }
    for (const trigger of triggers) {
      await this.addDriveAction(driveId, removeTrigger({ triggerId: trigger.id }));
    }
    await this.addDriveAction(driveId, setSharingType({ type: "LOCAL" }));
  }
  getSyncStatus(syncUnitId) {
    return this.synchronizationManager.getSyncStatus(syncUnitId);
  }
  on(event, cb) {
    return this.eventEmitter.on(event, cb);
  }
  emit(event, ...args) {
    return this.eventEmitter.emit(event, ...args);
  }
  getSynchronizationUnit(driveId, syncId) {
    return this.synchronizationManager.getSynchronizationUnit(driveId, syncId);
  }
  // Add delegated methods to properly implement ISynchronizationManager
  updateSyncStatus(syncUnitId, status, error) {
    this.synchronizationManager.updateSyncStatus(syncUnitId, status, error);
  }
  initializeDriveSyncStatus(driveId, drive) {
    return this.synchronizationManager.initializeDriveSyncStatus(driveId, drive);
  }
  getCombinedSyncUnitStatus(syncUnitStatus) {
    return this.synchronizationManager.getCombinedSyncUnitStatus(syncUnitStatus);
  }
  // Add back the saveStrand method that was accidentally removed
  async saveStrand(strand, source) {
    const operations = strand.operations.map((op) => ({
      ...op,
      scope: strand.scope,
      branch: strand.branch
    }));
    const result = await (!strand.documentId ? this.queueDriveOperations(strand.driveId, operations, { source }) : this.queueOperations(strand.driveId, strand.documentId, operations, {
      source
    }));
    if (result.status === "ERROR") {
      const syncUnits = strand.documentId !== "" ? (await this.getSynchronizationUnitsIds(strand.driveId, [strand.documentId], [strand.scope], [strand.branch])).map((s) => s.syncId) : [strand.driveId];
      const operationSource = this.getOperationSource(source);
      for (const syncUnit of syncUnits) {
        this.synchronizationManager.updateSyncStatus(syncUnit, { [operationSource]: result.status }, result.error);
      }
    }
    this.eventEmitter.emit("strandUpdate", strand);
    return result;
  }
}
const DocumentDriveServer = ReadModeServer(BaseDocumentDriveServer);
class MemoryStorage {
  constructor() {
    __publicField(this, "documents");
    __publicField(this, "drives");
    __publicField(this, "driveManifests");
    __publicField(this, "slugToDriveId", {});
    this.documents = {};
    this.drives = {};
    this.driveManifests = {};
  }
  ////////////////////////////////
  // IDocumentStorage
  ////////////////////////////////
  exists(documentId) {
    return Promise.resolve(!!this.documents[documentId]);
  }
  create(documentId, document) {
    this.documents[documentId] = document;
    return Promise.resolve();
  }
  get(documentId) {
    const document = this.documents[documentId];
    if (!document) {
      throw new Error(`Document with id ${documentId} not found`);
    }
    return Promise.resolve(document);
  }
  ////////////////////////////////
  // IDriveStorage
  ////////////////////////////////
  checkDocumentExists(drive, id) {
    return this.exists(id);
  }
  getDocuments(drive) {
    const manifest = this.getDriveManifest(drive);
    return Promise.resolve([...manifest.documentIds]);
  }
  getDocument(driveId, id) {
    return this.get(id);
  }
  async saveDocument(drive, id, document) {
    this.documents[id] = document;
    const manifest = this.getDriveManifest(drive);
    manifest.documentIds.add(id);
    this.updateDriveManifest(drive, manifest);
  }
  async clearStorage() {
    this.documents = {};
    this.drives = {};
    this.driveManifests = {};
    this.slugToDriveId = {};
  }
  async createDocument(drive, id, document) {
    await this.create(id, document);
    const manifest = this.getDriveManifest(drive);
    manifest.documentIds.add(id);
    this.updateDriveManifest(drive, manifest);
  }
  async addDocumentOperations(drive, id, operations, header) {
    const document = await this.getDocument(drive, id);
    if (!document) {
      throw new Error(`Document with id ${id} not found`);
    }
    const mergedOperations = mergeOperations(document.operations, operations);
    this.documents[id] = {
      ...document,
      ...header,
      operations: mergedOperations
    };
  }
  async deleteDocument(drive, id) {
    const drives = await this.getDrives();
    for (const driveId of drives) {
      const manifest = this.getDriveManifest(driveId);
      if (manifest.documentIds.has(id)) {
        manifest.documentIds.delete(id);
        this.updateDriveManifest(driveId, manifest);
      }
    }
    delete this.documents[id];
  }
  async getDrives() {
    return Object.keys(this.drives);
  }
  async getDrive(id) {
    const drive = this.drives[id];
    if (!drive) {
      throw new DriveNotFoundError(id);
    }
    return drive;
  }
  async getDriveBySlug(slug) {
    const driveId = this.slugToDriveId[slug];
    if (!driveId) {
      throw new Error(`Drive with slug ${slug} not found`);
    }
    return this.getDrive(driveId);
  }
  async createDrive(id, drive) {
    this.drives[id] = drive;
    this.updateDriveManifest(id, { documentIds: /* @__PURE__ */ new Set() });
    const { slug } = drive.initialState.state.global;
    if (slug) {
      this.slugToDriveId[slug] = id;
    }
  }
  async addDriveOperations(id, operations, header) {
    const drive = await this.getDrive(id);
    const mergedOperations = mergeOperations(drive.operations, operations);
    this.drives[id] = {
      ...drive,
      ...header,
      operations: mergedOperations
    };
  }
  async deleteDrive(id) {
    const manifest = this.getDriveManifest(id);
    const drives = await this.getDrives();
    await Promise.all([...manifest.documentIds].map((docId) => {
      for (const driveId of drives) {
        if (driveId === id) {
          continue;
        }
        const manifest2 = this.getDriveManifest(driveId);
        if (manifest2.documentIds.has(docId)) {
          return;
        }
      }
      delete this.documents[docId];
    }));
    delete this.driveManifests[id];
    delete this.drives[id];
    for (const [slug, driveId] of Object.entries(this.slugToDriveId)) {
      if (driveId === id) {
        delete this.slugToDriveId[slug];
      }
    }
  }
  async getSynchronizationUnitsRevision(units) {
    const results = await Promise.allSettled(units.map(async (unit) => {
      try {
        const document = await (unit.documentId ? this.getDocument(unit.driveId, unit.documentId) : this.getDrive(unit.driveId));
        if (!document) {
          return void 0;
        }
        const operation = document.operations[unit.scope].at(-1);
        if (operation) {
          return {
            driveId: unit.driveId,
            documentId: unit.documentId,
            scope: unit.scope,
            branch: unit.branch,
            lastUpdated: operation.timestamp,
            revision: operation.index
          };
        }
      } catch {
        return void 0;
      }
    }));
    return results.reduce((acc, curr) => {
      if (curr.status === "fulfilled" && curr.value !== void 0) {
        acc.push(curr.value);
      }
      return acc;
    }, []);
  }
  ////////////////////////////////
  // Private
  ////////////////////////////////
  getDriveManifest(driveId) {
    if (!this.driveManifests[driveId]) {
      this.driveManifests[driveId] = { documentIds: /* @__PURE__ */ new Set() };
    }
    return this.driveManifests[driveId];
  }
  updateDriveManifest(driveId, manifest) {
    this.driveManifests[driveId] = manifest;
  }
}
class DefaultEventEmitter {
  constructor() {
    __publicField(this, "emitter", createNanoEvents());
  }
  emit(event, ...args) {
    return this.emitter.emit(event, ...args);
  }
  on(event, cb) {
    return this.emitter.on(event, cb);
  }
}
function debounce(func, delay = 250) {
  let timer;
  return (immediate, ...args) => {
    if (timer) {
      clearTimeout(timer);
    }
    return new Promise((resolve, reject) => {
      if (immediate) {
        func(...args).then(resolve).catch(reject);
      } else {
        timer = setTimeout(() => {
          func(...args).then(resolve).catch(reject);
        }, delay);
      }
    });
  };
}
const _ListenerManager = class _ListenerManager {
  constructor(syncManager, options = DefaultListenerManagerOptions) {
    __publicField(this, "logger", childLogger([
      "ListenerManager",
      Math.floor(Math.random() * 999).toString()
    ]));
    __publicField(this, "syncManager");
    __publicField(this, "options");
    // driveId -> listenerId -> listenerState
    __publicField(this, "listenerStateByDriveId", /* @__PURE__ */ new Map());
    __publicField(this, "triggerUpdate", debounce(this._triggerUpdate.bind(this), _ListenerManager.LISTENER_UPDATE_DELAY));
    this.syncManager = syncManager;
    this.options = { ...DefaultListenerManagerOptions, ...options };
    this.logger.verbose(`constructor(...)`);
  }
  async initialize(handler) {
    this.logger.verbose("initialize(...)");
    if (typeof window !== "undefined") {
      window.addEventListener("online", () => {
        this.triggerUpdate(false, { type: "local" }, handler).catch((error) => {
          this.logger.error("Non handled error updating listeners", error);
        });
      });
    }
  }
  driveHasListeners(driveId) {
    return this.listenerStateByDriveId.has(driveId);
  }
  async setListener(driveId, listener) {
    this.logger.verbose(`setListener(drive: ${driveId}, listener: ${listener.listenerId})`);
    if (driveId !== listener.driveId) {
      throw new Error("Drive ID mismatch");
    }
    let existingState;
    try {
      existingState = this.getListenerState(driveId, listener.listenerId);
    } catch {
      existingState = {};
    }
    this.setListenerState(driveId, listener.listenerId, {
      ...existingState,
      block: listener.block,
      driveId: listener.driveId,
      pendingTimeout: "0",
      listener,
      listenerStatus: "CREATED",
      syncUnits: /* @__PURE__ */ new Map()
    });
    await this.triggerUpdate(true, { type: "local" });
  }
  async removeListener(driveId, listenerId) {
    this.logger.verbose("setListener()");
    const driveMap = this.listenerStateByDriveId.get(driveId);
    if (!driveMap) {
      return false;
    }
    return Promise.resolve(driveMap.delete(listenerId));
  }
  async removeSyncUnits(driveId, syncUnits) {
    const listeners = this.listenerStateByDriveId.get(driveId);
    if (!listeners) {
      return;
    }
    for (const [, listener] of listeners) {
      for (const syncUnit of syncUnits) {
        listener.syncUnits.delete(syncUnit.syncId);
      }
    }
    return Promise.resolve();
  }
  async updateSynchronizationRevisions(driveId, syncUnits, source, willUpdate, onError, forceSync = false) {
    const listenerIdToListenerState = this.listenerStateByDriveId.get(driveId);
    if (!listenerIdToListenerState) {
      return [];
    }
    const outdatedListeners = [];
    for (const [, listenerState] of listenerIdToListenerState) {
      if (outdatedListeners.find((l) => l.listenerId === listenerState.listener.listenerId)) {
        continue;
      }
      const transmitter = listenerState.listener.transmitter;
      if (!(transmitter == null ? void 0 : transmitter.transmit)) {
        continue;
      }
      for (const syncUnit of syncUnits) {
        if (!this._checkFilter(listenerState.listener.filter, syncUnit)) {
          continue;
        }
        const listenerRev = listenerState.syncUnits.get(syncUnit.syncId);
        if (!listenerRev || listenerRev.listenerRev < syncUnit.revision) {
          outdatedListeners.push(listenerState.listener);
          break;
        }
      }
    }
    if (outdatedListeners.length) {
      willUpdate == null ? void 0 : willUpdate(outdatedListeners);
      return this.triggerUpdate(forceSync, source, onError);
    }
    return [];
  }
  async updateListenerRevision(listenerId, driveId, syncId, listenerRev) {
    const drive = this.listenerStateByDriveId.get(driveId);
    if (!drive) {
      return;
    }
    const listener = drive.get(listenerId);
    if (!listener) {
      return;
    }
    const lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    const entry = listener.syncUnits.get(syncId);
    if (entry) {
      entry.listenerRev = listenerRev;
      entry.lastUpdated = lastUpdated;
    } else {
      listener.syncUnits.set(syncId, { listenerRev, lastUpdated });
    }
    return Promise.resolve();
  }
  async _triggerUpdate(source, onError, maxContinues = 500) {
    var _a2, _b;
    this.logger.verbose(`_triggerUpdate(source: ${source.type}, maxContinues: ${maxContinues})`, this.listenerStateByDriveId);
    if (maxContinues < 0) {
      throw new Error("Maximum retries exhausted.");
    }
    const listenerUpdates = [];
    for (const [driveId, drive] of this.listenerStateByDriveId) {
      for (const [listenerId, listenerState] of drive) {
        const transmitter = listenerState.listener.transmitter;
        if (!(transmitter == null ? void 0 : transmitter.transmit)) {
          this.logger.verbose(`Transmitter not set on listener: ${listenerId}`);
          continue;
        }
        const syncUnits = await this.getListenerSyncUnits(driveId, listenerId);
        const strandUpdates = [];
        this.logger.verbose("syncUnits", syncUnits);
        const tasks = syncUnits.map((syncUnit) => async () => {
          const unitState = listenerState.syncUnits.get(syncUnit.syncId);
          if (unitState && unitState.listenerRev >= syncUnit.revision) {
            this.logger.verbose(`Abandoning push for sync unit ${syncUnit.syncId}: already up-to-date (${unitState.listenerRev} >= ${syncUnit.revision})`);
            return;
          } else {
            this.logger.verbose(`Listener out-of-date for sync unit (${syncUnit.driveId}, ${syncUnit.scope}, ${syncUnit.documentId}): ${unitState == null ? void 0 : unitState.listenerRev} < ${syncUnit.revision}`);
          }
          const opData = [];
          try {
            const data = await this.syncManager.getOperationData(
              // TODO - join queries, DEAL WITH INVALID SYNC ID ERROR
              driveId,
              syncUnit.syncId,
              {
                fromRevision: unitState == null ? void 0 : unitState.listenerRev
              }
            );
            opData.push(...data);
          } catch (e) {
            this.logger.error(e);
          }
          if (!opData.length) {
            this.logger.verbose(`Abandoning push for ${syncUnit.syncId}: no operations found`);
            return;
          }
          strandUpdates.push({
            driveId,
            documentId: syncUnit.documentId,
            branch: syncUnit.branch,
            operations: opData,
            scope: syncUnit.scope
          });
        });
        if (this.options.sequentialUpdates) {
          this.logger.verbose(`Collecting ${tasks.length} syncUnit strandUpdates in sequence`);
          for (const task of tasks) {
            await task();
          }
        } else {
          this.logger.verbose(`Collecting ${tasks.length} syncUnit strandUpdates in parallel`);
          await Promise.all(tasks.map((task) => task()));
        }
        if (strandUpdates.length == 0) {
          this.logger.verbose(`No strandUpdates needed for listener ${listenerId}`);
          continue;
        }
        listenerState.pendingTimeout = new Date((/* @__PURE__ */ new Date()).getTime() / 1e3 + 300).toISOString();
        listenerState.listenerStatus = "PENDING";
        try {
          this.logger.verbose(`_triggerUpdate(source: ${source.type}) > transmitter.transmit`);
          const listenerRevisions = await transmitter.transmit(strandUpdates, source);
          this.logger.verbose(`_triggerUpdate(source: ${source.type}) > transmission succeeded`, listenerRevisions);
          listenerState.pendingTimeout = "0";
          listenerState.listenerStatus = "PENDING";
          const lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
          let continuationNeeded = false;
          for (const revision of listenerRevisions) {
            const syncUnit = syncUnits.find((unit) => revision.documentId === unit.documentId && revision.scope === unit.scope && revision.branch === unit.branch);
            if (syncUnit) {
              listenerState.syncUnits.set(syncUnit.syncId, {
                lastUpdated,
                listenerRev: revision.revision
              });
              const su = strandUpdates.find((su2) => su2.driveId === revision.driveId && su2.documentId === revision.documentId && su2.scope === revision.scope && su2.branch === revision.branch);
              if (su && su.operations.length > 0) {
                const suIndex = (_a2 = su.operations.at(su.operations.length - 1)) == null ? void 0 : _a2.index;
                if (suIndex !== revision.revision) {
                  this.logger.verbose(`Revision still out-of-date for ${su.documentId}:${su.scope}:${su.branch} ${suIndex} <> ${revision.revision}`);
                  continuationNeeded = true;
                } else {
                  this.logger.verbose(`Revision match for ${su.documentId}:${su.scope}:${su.branch} ${suIndex}`);
                }
              } else {
                this.logger.verbose(`Cannot find strand update for (${revision.documentId}:${revision.scope}:${revision.branch} in drive ${revision.driveId})`);
              }
            } else {
              this.logger.warn(`Received revision for untracked unit for listener ${listenerState.listener.listenerId}`, revision);
            }
          }
          for (const revision of listenerRevisions) {
            const error = revision.status === "ERROR";
            if ((_b = revision.error) == null ? void 0 : _b.includes("Missing operations")) {
              continuationNeeded = true;
            } else if (error) {
              throw new OperationError(revision.status, void 0, revision.error, revision.error);
            }
          }
          if (!continuationNeeded) {
            listenerUpdates.push({
              listenerId: listenerState.listener.listenerId,
              listenerRevisions
            });
          } else {
            const updates = await this._triggerUpdate(source, onError, maxContinues - 1);
            listenerUpdates.push(...updates);
          }
          listenerState.listenerStatus = "SUCCESS";
        } catch (e) {
          onError == null ? void 0 : onError(e, driveId, listenerState);
          listenerState.listenerStatus = e instanceof OperationError ? e.status : "ERROR";
        }
      }
    }
    this.logger.verbose(`Returning listener updates (maxContinues: ${maxContinues})`, listenerUpdates);
    return listenerUpdates;
  }
  _checkFilter(filter, syncUnit) {
    const { branch, documentId, scope, documentType: documentType2 } = syncUnit;
    if ((!filter.branch || filter.branch.includes(branch) || filter.branch.includes("*")) && (!filter.documentId || filter.documentId.includes(documentId) || filter.documentId.includes("*")) && (!filter.scope || filter.scope.includes(scope) || filter.scope.includes("*")) && (!filter.documentType || filter.documentType.includes(documentType2) || filter.documentType.includes("*"))) {
      return true;
    }
    return false;
  }
  getListenerSyncUnits(driveId, listenerId) {
    var _a2;
    const listener = (_a2 = this.listenerStateByDriveId.get(driveId)) == null ? void 0 : _a2.get(listenerId);
    if (!listener) {
      return [];
    }
    const filter = listener.listener.filter;
    return this.syncManager.getSynchronizationUnits(driveId, filter.documentId ?? ["*"], filter.scope ?? ["*"], filter.branch ?? ["*"], filter.documentType ?? ["*"]);
  }
  getListenerSyncUnitIds(driveId, listenerId) {
    var _a2;
    const listener = (_a2 = this.listenerStateByDriveId.get(driveId)) == null ? void 0 : _a2.get(listenerId);
    if (!listener) {
      return Promise.resolve([]);
    }
    const filter = listener.listener.filter;
    return this.syncManager.getSynchronizationUnitsIds(driveId, filter.documentId ?? ["*"], filter.scope ?? ["*"], filter.branch ?? ["*"], filter.documentType ?? ["*"]);
  }
  async removeDrive(driveId) {
    var _a2, _b;
    const listenerIdToListenerState = this.listenerStateByDriveId.get(driveId);
    if (!listenerIdToListenerState) {
      return;
    }
    this.listenerStateByDriveId.delete(driveId);
    for (const [_, listenerState] of listenerIdToListenerState) {
      try {
        await ((_b = (_a2 = listenerState.listener.transmitter) == null ? void 0 : _a2.disconnect) == null ? void 0 : _b.call(_a2));
      } catch (error) {
        this.logger.error(error);
      }
    }
  }
  async getStrands(driveId, listenerId, options) {
    const listenerState = this.getListenerState(driveId, listenerId);
    const strands = [];
    const syncUnits = await this.getListenerSyncUnits(driveId, listenerId);
    const limit = options == null ? void 0 : options.limit;
    let operationsCount = 0;
    const tasks = syncUnits.map((syncUnit) => async () => {
      if (limit && operationsCount >= limit) {
        return;
      }
      if (syncUnit.revision < 0) {
        return;
      }
      const entry = listenerState.syncUnits.get(syncUnit.syncId);
      if (entry && entry.listenerRev >= syncUnit.revision) {
        return;
      }
      const { documentId, driveId: driveId2, scope, branch } = syncUnit;
      try {
        const operations = await this.syncManager.getOperationData(
          // DEAL WITH INVALID SYNC ID ERROR
          driveId2,
          syncUnit.syncId,
          {
            since: options == null ? void 0 : options.since,
            fromRevision: (options == null ? void 0 : options.fromRevision) ?? (entry == null ? void 0 : entry.listenerRev),
            limit: limit ? limit - operationsCount : void 0
          }
        );
        if (!operations.length) {
          return;
        }
        operationsCount += operations.length;
        strands.push({
          driveId: driveId2,
          documentId,
          scope,
          branch,
          operations
        });
      } catch (error) {
        this.logger.error(error);
        return;
      }
    });
    if (this.options.sequentialUpdates) {
      for (const task of tasks) {
        await task();
      }
    } else {
      await Promise.all(tasks.map((task) => task()));
    }
    return strands;
  }
  getListenerState(driveId, listenerId) {
    let listenerStateByListenerId = this.listenerStateByDriveId.get(driveId);
    if (!listenerStateByListenerId) {
      listenerStateByListenerId = /* @__PURE__ */ new Map();
      this.listenerStateByDriveId.set(driveId, listenerStateByListenerId);
    }
    const listenerState = listenerStateByListenerId.get(listenerId);
    if (!listenerState) {
      throw new Error("Listener not found");
    }
    return listenerState;
  }
  setListenerState(driveId, listenerId, listenerState) {
    let listenerStateByListenerId = this.listenerStateByDriveId.get(driveId);
    if (!listenerStateByListenerId) {
      listenerStateByListenerId = /* @__PURE__ */ new Map();
      this.listenerStateByDriveId.set(driveId, listenerStateByListenerId);
    }
    listenerStateByListenerId.set(listenerId, listenerState);
  }
};
__publicField(_ListenerManager, "LISTENER_UPDATE_DELAY", 250);
let ListenerManager = _ListenerManager;
var defaults;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  defaults = {
    space: "",
    cycles: false,
    replacer: (k, v) => v,
    stringify: JSON.stringify
  };
  return defaults;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  util = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (v) => typeof v === "object",
    isFunction: (v) => typeof v === "function",
    isBoolean: (v) => typeof v === "boolean",
    isRegex: (v) => v instanceof RegExp,
    keys: Object.keys
  };
  return util;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  const DEFAULTS = requireDefaults();
  const isFunction = requireUtil().isFunction;
  const isBoolean = requireUtil().isBoolean;
  const isObject = requireUtil().isObject;
  const isArray = requireUtil().isArray;
  const isRegex = requireUtil().isRegex;
  const assign = requireUtil().assign;
  const keys = requireUtil().keys;
  function serialize(obj) {
    if (obj === null || obj === void 0) return obj;
    if (isRegex(obj)) return obj.toString();
    return obj.toJSON ? obj.toJSON() : obj;
  }
  function stringifyDeterministic(obj, opts) {
    opts = opts || assign({}, DEFAULTS);
    if (isFunction(opts)) opts = { compare: opts };
    const space = opts.space || DEFAULTS.space;
    const cycles = isBoolean(opts.cycles) ? opts.cycles : DEFAULTS.cycles;
    const replacer = opts.replacer || DEFAULTS.replacer;
    const stringify2 = opts.stringify || DEFAULTS.stringify;
    const compare = opts.compare && /* @__PURE__ */ function(f) {
      return function(node) {
        return function(a, b) {
          const aobj = { key: a, value: node[a] };
          const bobj = { key: b, value: node[b] };
          return f(aobj, bobj);
        };
      };
    }(opts.compare);
    if (!cycles) stringify2(obj);
    const seen = [];
    return function _deterministic(parent, key, node, level) {
      const indent2 = space ? "\n" + new Array(level + 1).join(space) : "";
      const colonSeparator = space ? ": " : ":";
      node = serialize(node);
      node = replacer.call(parent, key, node);
      if (node === void 0) return;
      if (!isObject(node) || node === null) return stringify2(node);
      if (isArray(node)) {
        const out = [];
        for (let i = 0; i < node.length; i++) {
          const item = _deterministic(node, i, node[i], level + 1) || stringify2(null);
          out.push(indent2 + space + item);
        }
        return "[" + out.join(",") + indent2 + "]";
      } else {
        if (cycles) {
          if (seen.indexOf(node) !== -1) {
            return stringify2("[Circular]");
          } else {
            seen.push(node);
          }
        }
        const nodeKeys = keys(node).sort(compare && compare(node));
        const out = [];
        for (let i = 0; i < nodeKeys.length; i++) {
          const key2 = nodeKeys[i];
          const value = _deterministic(node, key2, node[key2], level + 1);
          if (!value) continue;
          const keyValue = stringify2(key2) + colonSeparator + value;
          out.push(indent2 + space + keyValue);
        }
        seen.splice(seen.indexOf(node), 1);
        return "{" + out.join(",") + indent2 + "}";
      }
    }({ "": obj }, "", obj, 0);
  }
  lib = stringifyDeterministic;
  return lib;
}
var libExports = requireLib();
const stringify = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
const SYNC_OPS_BATCH_LIMIT = 10;
class SwitchboardPushTransmitter {
  constructor(targetURL) {
    __publicField(this, "targetURL");
    __publicField(this, "logger", childLogger([
      "SwitchboardPushTransmitter",
      Math.floor(Math.random() * 999).toString()
    ]));
    this.targetURL = targetURL;
  }
  async transmit(strands, source) {
    var _a2;
    if (source.type === "trigger" && ((_a2 = source.trigger.data) == null ? void 0 : _a2.url) === this.targetURL) {
      this.logger.verbose(`Cutting trigger loop from ${this.targetURL}.`);
      return strands.map((strand) => {
        var _a3;
        return {
          driveId: strand.driveId,
          documentId: strand.documentId,
          scope: strand.scope,
          branch: strand.branch,
          status: "SUCCESS",
          revision: ((_a3 = strand.operations.at(-1)) == null ? void 0 : _a3.index) ?? -1
        };
      });
    }
    const culledStrands = [];
    let opsCounter = 0;
    for (let s = 0; opsCounter <= SYNC_OPS_BATCH_LIMIT && s < strands.length; s++) {
      const currentStrand = strands.at(s);
      if (!currentStrand) {
        break;
      }
      const newOps = Math.min(SYNC_OPS_BATCH_LIMIT - opsCounter, currentStrand.operations.length);
      culledStrands.push({
        ...currentStrand,
        operations: currentStrand.operations.slice(0, newOps)
      });
      opsCounter += newOps;
    }
    this.logger.verbose(` Total update: [${strands.map((s) => s.operations.length).join(", ")}] operations`);
    this.logger.verbose(`Culled update: [${culledStrands.map((s) => s.operations.length).join(", ")}] operations`);
    try {
      const { pushUpdates } = await requestGraphql(this.targetURL, gql`
          mutation pushUpdates($strands: [InputStrandUpdate!]) {
            pushUpdates(strands: $strands) {
              driveId
              documentId
              scope
              branch
              status
              revision
              error
            }
          }
        `, {
        strands: culledStrands.map((strand) => ({
          ...strand,
          operations: strand.operations.map((op) => ({
            ...op,
            input: stringify(op.input)
          }))
        }))
      });
      if (!pushUpdates) {
        throw new Error("Couldn't update listener revision");
      }
      return pushUpdates;
    } catch (e) {
      this.logger.error(e);
      throw e;
    }
    return [];
  }
}
class TransmitterFactory {
  constructor(listenerManager) {
    __publicField(this, "listenerManager");
    this.listenerManager = listenerManager;
  }
  instance(transmitterType, listener, driveServer) {
    var _a2;
    switch (transmitterType) {
      case "SwitchboardPush": {
        if (!((_a2 = listener.callInfo) == null ? void 0 : _a2.data)) {
          throw new Error("No call info data: " + JSON.stringify(listener));
        }
        return new SwitchboardPushTransmitter(listener.callInfo.data);
      }
      case "Internal": {
        throw new Error("Internal transmitter not implemented");
      }
      default: {
        return new PullResponderTransmitter(listener, this.listenerManager);
      }
    }
  }
}
class SynchronizationManager {
  constructor(storage, cache, documentModelModules, eventEmitter) {
    __publicField(this, "storage");
    __publicField(this, "cache");
    __publicField(this, "documentModelModules");
    __publicField(this, "eventEmitter");
    __publicField(this, "syncStatus", /* @__PURE__ */ new Map());
    __publicField(this, "logger", childLogger(["SynchronizationManager"]));
    this.storage = storage;
    this.cache = cache;
    this.documentModelModules = documentModelModules;
    this.eventEmitter = eventEmitter;
  }
  async getSynchronizationUnits(driveId, documentId, scope, branch, documentType2) {
    const synchronizationUnitsQuery = await this.getSynchronizationUnitsIds(driveId, documentId, scope, branch, documentType2);
    return this.getSynchronizationUnitsRevision(driveId, synchronizationUnitsQuery);
  }
  async getSynchronizationUnitsRevision(driveId, syncUnitsQuery) {
    const drive = await this.getDrive(driveId);
    const revisions = await this.storage.getSynchronizationUnitsRevision(syncUnitsQuery);
    const synchronizationUnits = syncUnitsQuery.map((s) => ({
      ...s,
      lastUpdated: drive.created,
      revision: -1
    }));
    for (const revision of revisions) {
      const syncUnit = synchronizationUnits.find((s) => revision.driveId === s.driveId && revision.documentId === s.documentId && revision.scope === s.scope && revision.branch === s.branch);
      if (syncUnit) {
        syncUnit.revision = revision.revision;
        syncUnit.lastUpdated = revision.lastUpdated;
      }
    }
    return synchronizationUnits;
  }
  async getSynchronizationUnitsIds(driveId, documentId, scope, branch, documentType2) {
    const drive = await this.getDrive(driveId);
    const nodes = drive.state.global.nodes.filter((node) => isFileNode(node) && (!(documentId == null ? void 0 : documentId.length) || documentId.includes(node.id) || documentId.includes("*")) && (!(documentType2 == null ? void 0 : documentType2.length) || documentType2.includes(node.documentType) || documentType2.includes("*")));
    if ((!documentId || documentId.includes("*") || documentId.includes("")) && (!(documentType2 == null ? void 0 : documentType2.length) || documentType2.includes("powerhouse/document-drive") || documentType2.includes("*"))) {
      nodes.unshift({
        id: "",
        documentType: "powerhouse/document-drive",
        synchronizationUnits: [
          {
            syncId: "0",
            scope: "global",
            branch: "main"
          }
        ]
      });
    }
    const synchronizationUnitsQuery = [];
    for (const node of nodes) {
      const nodeUnits = (scope == null ? void 0 : scope.length) || (branch == null ? void 0 : branch.length) ? node.synchronizationUnits.filter((unit) => (!(scope == null ? void 0 : scope.length) || scope.includes(unit.scope) || scope.includes("*")) && (!(branch == null ? void 0 : branch.length) || branch.includes(unit.branch) || branch.includes("*"))) : node.synchronizationUnits;
      if (!nodeUnits.length) {
        continue;
      }
      synchronizationUnitsQuery.push(...nodeUnits.map((n) => ({
        driveId,
        documentId: node.id,
        syncId: n.syncId,
        documentType: node.documentType,
        scope: n.scope,
        branch: n.branch
      })));
    }
    return synchronizationUnitsQuery;
  }
  async getSynchronizationUnitIdInfo(driveId, syncId) {
    const drive = await this.getDrive(driveId);
    const node = drive.state.global.nodes.find((node2) => isFileNode(node2) && node2.synchronizationUnits.find((unit) => unit.syncId === syncId));
    if (!node || !isFileNode(node)) {
      return void 0;
    }
    const syncUnit = node.synchronizationUnits.find((unit) => unit.syncId === syncId);
    if (!syncUnit) {
      return void 0;
    }
    return {
      syncId,
      scope: syncUnit.scope,
      branch: syncUnit.branch,
      driveId,
      documentId: node.id,
      documentType: node.documentType
    };
  }
  async getSynchronizationUnit(driveId, syncId) {
    const syncUnit = await this.getSynchronizationUnitIdInfo(driveId, syncId);
    if (!syncUnit) {
      return void 0;
    }
    const { scope, branch, documentId, documentType: documentType2 } = syncUnit;
    const document = await this.getDocument(driveId, documentId);
    const operations = document.operations[scope] ?? [];
    const lastOperation = operations[operations.length - 1];
    return {
      syncId,
      scope,
      branch,
      driveId,
      documentId,
      documentType: documentType2,
      lastUpdated: lastOperation.timestamp ?? document.lastModified,
      revision: lastOperation.index ?? 0
    };
  }
  async getOperationData(driveId, syncId, filter) {
    const syncUnit = syncId === "0" ? { documentId: "", scope: "global" } : await this.getSynchronizationUnitIdInfo(driveId, syncId);
    if (!syncUnit) {
      throw new Error(`Invalid Sync Id ${syncId} in drive ${driveId}`);
    }
    const document = syncId === "0" ? await this.getDrive(driveId) : await this.getDocument(driveId, syncUnit.documentId);
    const operations = document.operations[syncUnit.scope] ?? [];
    const filteredOperations = operations.filter((operation) => Object.keys(filter).length === 0 || (filter.since === void 0 || isBefore(filter.since, operation.timestamp)) && (filter.fromRevision === void 0 || operation.index > filter.fromRevision));
    const limitedOperations = filter.limit ? filteredOperations.slice(0, filter.limit) : filteredOperations;
    return limitedOperations.map((operation) => ({
      hash: operation.hash,
      index: operation.index,
      timestamp: operation.timestamp,
      type: operation.type,
      input: operation.input,
      skip: operation.skip,
      context: operation.context,
      id: operation.id
    }));
  }
  async getDrive(driveId) {
    try {
      const cachedDocument = await this.cache.getDocument("drives", driveId);
      if (cachedDocument && isDocumentDrive(cachedDocument)) {
        return cachedDocument;
      }
    } catch (e) {
      this.logger.error("Error getting drive from cache", e);
    }
    const driveStorage = await this.storage.getDrive(driveId);
    const result = this._buildDocument(driveStorage);
    if (!isDocumentDrive(result)) {
      throw new Error(`Document with id ${driveId} is not a Document Drive`);
    }
    return result;
  }
  async getDocument(driveId, documentId) {
    try {
      const cachedDocument = await this.cache.getDocument(driveId, documentId);
      if (cachedDocument) {
        return cachedDocument;
      }
    } catch (e) {
      this.logger.error("Error getting document from cache", e);
    }
    const documentStorage = await this.storage.getDocument(driveId, documentId);
    return this._buildDocument(documentStorage);
  }
  _buildDocument(documentStorage) {
    const documentModelModule = this.getDocumentModelModule(documentStorage.documentType);
    const operations = garbageCollectDocumentOperations(documentStorage.operations);
    return replayDocument(documentStorage.initialState, operations, documentModelModule.reducer, void 0, documentStorage, void 0, {
      checkHashes: true,
      reuseOperationResultingState: true
    });
  }
  setDocumentModelModules(modules) {
    this.documentModelModules = modules;
  }
  getDocumentModelModule(documentType2) {
    const documentModelModule = this.documentModelModules.find((m) => m.documentModel.id === documentType2);
    if (!documentModelModule) {
      throw new Error(`Document type ${documentType2} not supported`);
    }
    return documentModelModule;
  }
  getCombinedSyncUnitStatus(syncUnitStatus) {
    if (!syncUnitStatus.pull && !syncUnitStatus.push)
      return "INITIAL_SYNC";
    if (syncUnitStatus.pull === "INITIAL_SYNC")
      return "INITIAL_SYNC";
    if (syncUnitStatus.push === "INITIAL_SYNC")
      return syncUnitStatus.pull || "INITIAL_SYNC";
    const order = [
      "ERROR",
      "MISSING",
      "CONFLICT",
      "SYNCING",
      "SUCCESS"
    ];
    const sortedStatus = Object.values(syncUnitStatus).sort((a, b) => order.indexOf(a) - order.indexOf(b));
    return sortedStatus[0];
  }
  getSyncStatus(syncUnitId) {
    const status = this.syncStatus.get(syncUnitId);
    if (!status) {
      return new SynchronizationUnitNotFoundError(`Sync status not found for syncUnitId: ${syncUnitId}`, syncUnitId);
    }
    return this.getCombinedSyncUnitStatus(status);
  }
  updateSyncStatus(syncUnitId, status, error) {
    if (status === null) {
      this.syncStatus.delete(syncUnitId);
      return;
    }
    const syncUnitStatus = this.syncStatus.get(syncUnitId);
    if (!syncUnitStatus) {
      this.initSyncStatus(syncUnitId, status);
      return;
    }
    const shouldUpdateStatus = Object.entries(status).some(([key, _status]) => syncUnitStatus[key] !== _status);
    if (shouldUpdateStatus) {
      const newstatus = Object.entries(status).reduce((acc, [key, _status]) => {
        return {
          ...acc,
          // do not replace initial_syncing if it has not finished yet
          [key]: acc[key] === "INITIAL_SYNC" && _status === "SYNCING" ? "INITIAL_SYNC" : _status
        };
      }, syncUnitStatus);
      const previousCombinedStatus = this.getCombinedSyncUnitStatus(syncUnitStatus);
      const newCombinedStatus = this.getCombinedSyncUnitStatus(newstatus);
      this.syncStatus.set(syncUnitId, newstatus);
      if (previousCombinedStatus !== newCombinedStatus && this.eventEmitter) {
        this.eventEmitter.emit("syncStatus", syncUnitId, this.getCombinedSyncUnitStatus(newstatus), error, newstatus);
      }
    }
  }
  initSyncStatus(syncUnitId, status) {
    const defaultSyncUnitStatus = Object.entries(status).reduce((acc, [key, _status]) => {
      return {
        ...acc,
        [key]: _status !== "SYNCING" ? _status : "INITIAL_SYNC"
      };
    }, {});
    this.syncStatus.set(syncUnitId, defaultSyncUnitStatus);
    if (this.eventEmitter) {
      this.eventEmitter.emit("syncStatus", syncUnitId, this.getCombinedSyncUnitStatus(defaultSyncUnitStatus), void 0, defaultSyncUnitStatus);
    }
  }
  async initializeDriveSyncStatus(driveId, drive) {
    const syncUnits = await this.getSynchronizationUnitsIds(driveId);
    const syncStatus = {
      pull: drive.state.local.triggers.length > 0 ? "INITIAL_SYNC" : void 0,
      push: drive.state.local.listeners.length > 0 ? "SUCCESS" : void 0
    };
    if (!syncStatus.pull && !syncStatus.push)
      return;
    const syncUnitsIds = [driveId, ...syncUnits.map((s) => s.syncId)];
    for (const syncUnitId of syncUnitsIds) {
      this.initSyncStatus(syncUnitId, syncStatus);
    }
  }
}
class ReactorBuilder {
  constructor(documentModelModules) {
    __publicField(this, "documentModelModules", []);
    __publicField(this, "storage");
    __publicField(this, "cache");
    __publicField(this, "queueManager");
    __publicField(this, "eventEmitter");
    __publicField(this, "options");
    __publicField(this, "synchronizationManager");
    __publicField(this, "listenerManager");
    __publicField(this, "transmitterFactory");
    this.documentModelModules = documentModelModules;
  }
  withStorage(storage) {
    this.storage = storage;
    return this;
  }
  withCache(cache) {
    this.cache = cache;
    return this;
  }
  withQueueManager(queueManager) {
    this.queueManager = queueManager;
    return this;
  }
  withEventEmitter(eventEmitter) {
    this.eventEmitter = eventEmitter;
    return this;
  }
  withSynchronizationManager(synchronizationManager) {
    this.synchronizationManager = synchronizationManager;
    return this;
  }
  withListenerManager(listenerManager) {
    this.listenerManager = listenerManager;
    return this;
  }
  withTransmitterFactory(transmitterFactory) {
    this.transmitterFactory = transmitterFactory;
    return this;
  }
  withOptions(options) {
    this.options = options;
    return this;
  }
  build() {
    var _a2;
    if (!this.documentModelModules.length) {
      throw new Error("Document models are required to build the server");
    }
    if (!this.storage) {
      this.storage = new MemoryStorage();
    }
    if (!this.cache) {
      this.cache = new InMemoryCache();
    }
    if (!this.queueManager) {
      this.queueManager = new BaseQueueManager();
    }
    if (!this.eventEmitter) {
      this.eventEmitter = new DefaultEventEmitter();
    }
    if (!this.synchronizationManager) {
      this.synchronizationManager = new SynchronizationManager(this.storage, this.cache, this.documentModelModules, this.eventEmitter);
    }
    if (!this.listenerManager) {
      const config = {
        ...DefaultListenerManagerOptions,
        ...(_a2 = this.options) == null ? void 0 : _a2.listenerManager
      };
      this.listenerManager = new ListenerManager(this.synchronizationManager, config);
    }
    if (!this.transmitterFactory) {
      this.transmitterFactory = new TransmitterFactory(this.listenerManager);
    }
    return new DocumentDriveServer(
      this.documentModelModules,
      this.storage,
      // as we refactor, we're secretly making all the IStorage implementations also implement IDocumentStorage
      this.storage,
      this.cache,
      this.queueManager,
      this.eventEmitter,
      this.synchronizationManager,
      this.listenerManager,
      this.options
    );
  }
}
const logger = childLogger([
  "utils/document-model",
  Math.floor(Math.random() * 999).toString()
]);
const FILE_UPLOAD_OPERATIONS_CHUNK_SIZE = parseInt(
  window.__VITE_ENVS.FILE_UPLOAD_OPERATIONS_CHUNK_SIZE || "50"
);
function useDocumentDispatch(documentReducer, initialState, onError = logger.error) {
  const [state, setState] = useState(initialState);
  const [error, setError] = useState();
  const onErrorHandler = (error2) => {
    setError(error2);
    onError(error2);
  };
  useEffect(() => {
    setState(initialState);
    setError(void 0);
  }, [initialState]);
  const dispatch = (action, callback, onErrorCallback) => {
    setError(void 0);
    setState((_state) => {
      if (!documentReducer || !_state) return _state;
      try {
        const newState = documentReducer(_state, action);
        const scope = action.scope ?? "global";
        const operations = newState.operations[scope];
        const operation = operations[operations.length - 1];
        if (operation.error) {
          const error2 = new Error(operation.error);
          onErrorHandler(error2);
          onErrorCallback == null ? void 0 : onErrorCallback(error2);
        }
        callback == null ? void 0 : callback(operation, {
          prevState: { ..._state },
          newState: { ...newState }
        });
        return newState;
      } catch (error2) {
        onErrorHandler(error2);
        onErrorCallback == null ? void 0 : onErrorCallback(error2);
        return _state;
      }
    });
  };
  return [state, dispatch, error];
}
async function uploadDocumentOperations(drive, documentId, document, reactor, pushOperations, options) {
  const operationsLimit = (options == null ? void 0 : options.operationsLimit) || FILE_UPLOAD_OPERATIONS_CHUNK_SIZE;
  logger.verbose(
    `uploadDocumentOperations(drive: ${drive}, documentId:${documentId}, ops: ${Object.keys(document.operations).join(",")}, limit:${operationsLimit})`
  );
  for (const operations of Object.values(document.operations)) {
    for (let i = 0; i < operations.length; i += operationsLimit) {
      logger.verbose(
        `uploadDocumentOperations:for(i:${i}, ops:${operations.length}, limit:${operationsLimit}): START`
      );
      const chunk = operations.slice(i, i + operationsLimit);
      const operation = chunk.at(-1);
      if (!operation) {
        break;
      }
      const { scope } = operation;
      await pushOperations(drive, documentId, chunk);
      logger.verbose(
        `uploadDocumentOperations:for:waitForUpdate(${documentId}:${scope} rev ${operation.index}): NEXT`
      );
    }
  }
  logger.verbose(
    `uploadDocumentOperations:for:waitForUpdate(${documentId}): END`
  );
}
function CalendarTime(props) {
  return jsx("svg", { ...props, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("g", { id: "Calendar", children: jsx("path", { id: "Shape", fillRule: "evenodd", clipRule: "evenodd", d: "M4.79998 1.06665C5.09454 1.06665 5.33332 1.30543 5.33332 1.59998V2.13332H10.6667V1.59998C10.6667 1.30543 10.9054 1.06665 11.2 1.06665C11.4945 1.06665 11.7333 1.30543 11.7333 1.59998V2.13332H13.3333C14.217 2.13332 14.9333 2.84966 14.9333 3.73332V13.3333C14.9333 14.217 14.217 14.9333 13.3333 14.9333H2.66665C1.783 14.9333 1.06665 14.217 1.06665 13.3333V3.73332C1.06665 2.84966 1.78299 2.13332 2.66665 2.13332H4.26665V1.59998C4.26665 1.30543 4.50543 1.06665 4.79998 1.06665ZM10.6667 3.19998V3.73332C10.6667 4.02787 10.9054 4.26665 11.2 4.26665C11.4945 4.26665 11.7333 4.02787 11.7333 3.73332V3.19998H13.3333C13.6279 3.19998 13.8667 3.43877 13.8667 3.73332V5.33332H2.13332V3.73332C2.13332 3.43877 2.3721 3.19998 2.66665 3.19998H4.26665V3.73332C4.26665 4.02787 4.50543 4.26665 4.79998 4.26665C5.09454 4.26665 5.33332 4.02787 5.33332 3.73332V3.19998H10.6667ZM2.13332 6.39998V13.3333C2.13332 13.6279 2.3721 13.8667 2.66665 13.8667H13.3333C13.6279 13.8667 13.8667 13.6279 13.8667 13.3333V6.39998H2.13332ZM7.46665 7.99998C7.46665 7.70543 7.70543 7.46665 7.99999 7.46665C8.29454 7.46665 8.53332 7.70543 8.53332 7.99998C8.53332 8.29454 8.29454 8.53332 7.99999 8.53332C7.70543 8.53332 7.46665 8.29454 7.46665 7.99998ZM10.1333 7.46665C9.83877 7.46665 9.59999 7.70543 9.59999 7.99998C9.59999 8.29454 9.83877 8.53332 10.1333 8.53332C10.4279 8.53332 10.6667 8.29454 10.6667 7.99998C10.6667 7.70543 10.4279 7.46665 10.1333 7.46665ZM11.7333 7.99998C11.7333 7.70543 11.9721 7.46665 12.2667 7.46665C12.5612 7.46665 12.8 7.70543 12.8 7.99998C12.8 8.29454 12.5612 8.53332 12.2667 8.53332C11.9721 8.53332 11.7333 8.29454 11.7333 7.99998ZM12.2667 9.59998C11.9721 9.59998 11.7333 9.83877 11.7333 10.1333C11.7333 10.4279 11.9721 10.6667 12.2667 10.6667C12.5612 10.6667 12.8 10.4279 12.8 10.1333C12.8 9.83877 12.5612 9.59998 12.2667 9.59998ZM9.59999 10.1333C9.59999 9.83877 9.83877 9.59998 10.1333 9.59998C10.4279 9.59998 10.6667 9.83877 10.6667 10.1333C10.6667 10.4279 10.4279 10.6667 10.1333 10.6667C9.83877 10.6667 9.59999 10.4279 9.59999 10.1333ZM7.99999 9.59998C7.70543 9.59998 7.46665 9.83877 7.46665 10.1333C7.46665 10.4279 7.70543 10.6667 7.99999 10.6667C8.29454 10.6667 8.53332 10.4279 8.53332 10.1333C8.53332 9.83877 8.29454 9.59998 7.99999 9.59998ZM5.33332 10.1333C5.33332 9.83877 5.5721 9.59998 5.86665 9.59998C6.1612 9.59998 6.39998 9.83877 6.39998 10.1333C6.39998 10.4279 6.1612 10.6667 5.86665 10.6667C5.5721 10.6667 5.33332 10.4279 5.33332 10.1333ZM3.73332 9.59998C3.43877 9.59998 3.19999 9.83877 3.19999 10.1333C3.19999 10.4279 3.43877 10.6667 3.73332 10.6667C4.02787 10.6667 4.26665 10.4279 4.26665 10.1333C4.26665 9.83877 4.02787 9.59998 3.73332 9.59998ZM3.19999 12.2667C3.19999 11.9721 3.43877 11.7333 3.73332 11.7333C4.02787 11.7333 4.26665 11.9721 4.26665 12.2667C4.26665 12.5612 4.02787 12.8 3.73332 12.8C3.43877 12.8 3.19999 12.5612 3.19999 12.2667ZM5.86665 11.7333C5.5721 11.7333 5.33332 11.9721 5.33332 12.2667C5.33332 12.5612 5.5721 12.8 5.86665 12.8C6.1612 12.8 6.39998 12.5612 6.39998 12.2667C6.39998 11.9721 6.1612 11.7333 5.86665 11.7333ZM7.46665 12.2667C7.46665 11.9721 7.70543 11.7333 7.99999 11.7333C8.29454 11.7333 8.53332 11.9721 8.53332 12.2667C8.53332 12.5612 8.29454 12.8 7.99999 12.8C7.70543 12.8 7.46665 12.5612 7.46665 12.2667ZM10.1333 11.7333C9.83877 11.7333 9.59999 11.9721 9.59999 12.2667C9.59999 12.5612 9.83877 12.8 10.1333 12.8C10.4279 12.8 10.6667 12.5612 10.6667 12.2667C10.6667 11.9721 10.4279 11.7333 10.1333 11.7333Z", fill: "currentcolor" }) }) });
}
function CaretLeft(props) {
  return jsx("svg", { ...props, width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("g", { id: "Caret Left", children: jsx("path", { id: "Shape", fillRule: "evenodd", clipRule: "evenodd", d: "M10.5819 5.01815C10.7928 5.22903 10.7928 5.57094 10.5819 5.78182L7.36373 8.99999L10.5819 12.2181C10.7928 12.429 10.7928 12.7709 10.5819 12.9818C10.371 13.1927 10.0291 13.1927 9.81822 12.9818L6.21822 9.38182C6.11695 9.28055 6.06006 9.1432 6.06006 8.99999C6.06006 8.85677 6.11695 8.71942 6.21822 8.61815L9.81822 5.01815C10.0291 4.80726 10.371 4.80726 10.5819 5.01815Z", fill: "currentColor" }) }) });
}
function CaretRight(props) {
  return jsx("svg", { ...props, width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("g", { id: "Caret Right", children: jsx("path", { id: "Shape", fillRule: "evenodd", clipRule: "evenodd", d: "M7.4181 5.01821C7.62899 4.80733 7.9709 4.80733 8.18178 5.01821L11.7818 8.61821C11.883 8.71948 11.9399 8.85683 11.9399 9.00005C11.9399 9.14326 11.883 9.28061 11.7818 9.38188L8.18178 12.9819C7.9709 13.1928 7.62899 13.1928 7.4181 12.9819C7.20722 12.771 7.20722 12.4291 7.4181 12.2182L10.6363 9.00005L7.4181 5.78188C7.20722 5.571 7.20722 5.22909 7.4181 5.01821Z", fill: "currentColor" }) }) });
}
function ArrowFilledRight(props) {
  return jsx("svg", { ...props, viewBox: "0 0 9 12", fill: "currentcolor", children: jsx("path", { d: "M8.31744 6.36794C8.56085 6.17515 8.56085 5.82482 8.31744 5.63203L1.3527 0.115704C1.01647 -0.150574 0.499999 0.072258 0.499999 0.483647L0.5 11.5163C0.5 11.9277 1.01647 12.1506 1.3527 11.8843L8.31744 6.36794Z" }) });
}
function ArrowLeft(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", stroke: "currentcolor", children: jsx("path", { d: "M8 1L0.999998 8M0.999998 8L8 15M0.999998 8L15 8", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) });
}
function ArrowUp(props) {
  return jsx("svg", { ...props, viewBox: "0 0 20 21", fill: "currentcolor", children: jsx("path", { d: "M9.98893 18.8223C14.5914 18.8223 18.3223 15.0913 18.3223 10.4889C18.3223 5.88642 14.5914 2.15559 9.98893 2.15559C5.38643 2.15559 1.6556 5.88642 1.6556 10.4889C1.6556 15.0913 5.38643 18.8223 9.98893 18.8223ZM9.98893 14.6556C9.52893 14.6556 9.1556 14.2825 9.1556 13.8223L9.1556 9.65559L6.6556 9.65559L9.98893 6.32226L13.3223 9.65559L10.8223 9.65559L10.8223 13.8223C10.8223 14.2825 10.4489 14.6556 9.98893 14.6556Z" }) });
}
function BarChart(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M12.0104 2.66602C11.2738 2.66602 10.6771 3.26268 10.6771 3.99935V11.9993C10.6771 12.736 11.2738 13.3327 12.0104 13.3327H13.3438C14.0804 13.3327 14.6771 12.736 14.6771 11.9993V3.99935C14.6771 3.26268 14.0804 2.66602 13.3438 2.66602H12.0104ZM7.34375 5.33268C6.60708 5.33268 6.01042 5.92935 6.01042 6.66602V11.9993C6.01042 12.736 6.60708 13.3327 7.34375 13.3327H8.67708C9.41375 13.3327 10.0104 12.736 10.0104 11.9993V6.66602C10.0104 5.92935 9.41375 5.33268 8.67708 5.33268H7.34375ZM2.67708 7.99935C1.94042 7.99935 1.34375 8.59602 1.34375 9.33268V11.9993C1.34375 12.736 1.94042 13.3327 2.67708 13.3327H4.01042C4.74708 13.3327 5.34375 12.736 5.34375 11.9993V9.33268C5.34375 8.59602 4.74708 7.99935 4.01042 7.99935H2.67708Z" }) });
}
function BaseArrowLeft(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M16.1557 6.42331C16.6148 5.98332 16.6148 5.26997 16.1557 4.82999C15.6967 4.39 14.9525 4.39 14.4935 4.82999L7.84438 11.2033C7.83003 11.217 7.81614 11.231 7.80268 11.2453C7.79259 11.256 7.78275 11.2669 7.77314 11.2779C7.38661 11.7205 7.41032 12.3808 7.84427 12.7967L14.4933 19.17C14.9524 19.61 15.6966 19.61 16.1556 19.17C16.6146 18.7301 16.6146 18.0167 16.1556 17.5767L10.3377 12.0001L16.1557 6.42331Z" }) });
}
function BaseArrowRight(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M7.84427 17.5767C7.38524 18.0167 7.38524 18.73 7.84427 19.17C8.30329 19.61 9.04752 19.61 9.50653 19.17L16.1556 12.7967C16.17 12.783 16.1839 12.769 16.1973 12.7547C16.2074 12.744 16.2173 12.7331 16.2269 12.7221C16.6134 12.2795 16.5897 11.6192 16.1557 11.2033L9.50665 4.82997C9.04762 4.39001 8.3034 4.39001 7.84438 4.82997C7.38535 5.26992 7.38535 5.98332 7.84438 6.42328L13.6623 11.9999L7.84427 17.5767Z" }) });
}
function Braces(props) {
  return jsx("svg", { ...props, width: "16", height: "16", viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M4.67064 1.99414C3.19797 1.99414 2.00397 3.18814 2.00397 4.66081V11.3275C2.00397 12.8001 3.19797 13.9941 4.67064 13.9941H11.3373C12.81 13.9941 14.004 12.8001 14.004 11.3275V4.66081C14.004 3.18814 12.81 1.99414 11.3373 1.99414H4.67064ZM6.64997 3.32747C7.01797 3.32147 7.33131 3.60547 7.33731 3.97347C7.34331 4.34147 7.05931 4.65481 6.69131 4.66081C6.30331 4.66747 6.00864 4.94547 6.00397 5.32747C6.00264 5.42081 6.0053 5.42681 6.00397 5.51481C5.99464 6.23681 5.98063 6.49414 5.89997 6.82747C5.82863 7.11947 5.6493 7.48214 5.39997 7.99414C5.65197 8.51147 5.82797 8.87081 5.89997 9.16081C5.98663 9.51147 5.9993 9.77014 6.00397 10.5775C6.00397 10.6215 6.00397 10.6155 6.00397 10.6608C6.00664 11.0635 6.2673 11.3275 6.67064 11.3275C7.03864 11.3275 7.33731 11.6261 7.33731 11.9941C7.33731 12.3621 7.03864 12.6608 6.67064 12.6608C5.52464 12.6601 4.6773 11.7881 4.67064 10.6608C4.67064 10.6155 4.67064 10.6215 4.67064 10.5775C4.66664 9.88414 4.65997 9.70281 4.60797 9.49414C4.55197 9.26814 4.44797 9.0488 4.06663 8.28613C3.97263 8.09813 3.97263 7.89015 4.06663 7.70215C4.4393 6.95748 4.55264 6.72281 4.60797 6.49414C4.65664 6.29481 4.66264 6.11081 4.67064 5.49414C4.67197 5.40681 4.6693 5.42147 4.67064 5.32747C4.68464 4.22481 5.53997 3.34614 6.64997 3.32747ZM9.33731 3.32747C10.4606 3.33747 11.3466 4.21947 11.3373 5.32747C11.3306 6.07347 11.3446 6.27614 11.4 6.49414C11.456 6.71481 11.5366 6.89282 11.9413 7.70215C12.0353 7.89015 12.0353 8.09813 11.9413 8.28613C11.5466 9.07547 11.456 9.27147 11.4 9.49414C11.3453 9.71147 11.3353 9.89814 11.3373 10.6608C11.3406 11.7935 10.4746 12.6655 9.33731 12.6608C8.96931 12.6595 8.66931 12.3621 8.67064 11.9941C8.67197 11.6261 8.96931 11.3261 9.33731 11.3275C9.73264 11.3288 10.0053 11.0555 10.004 10.6608C10.0013 9.77481 10.0153 9.52881 10.108 9.16081C10.18 8.87414 10.3513 8.51947 10.608 7.99414C10.3473 7.46281 10.1806 7.11214 10.108 6.82747C10.0133 6.45547 9.99664 6.19747 10.004 5.32747C10.0073 4.95814 9.72731 4.66414 9.33731 4.66081C8.96931 4.65747 8.66731 4.36214 8.67064 3.99414C8.67397 3.62614 8.96931 3.32414 9.33731 3.32747Z" }) });
}
function Branch(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M12.0283 1.99805C10.3713 1.99805 9.02832 3.34105 9.02832 4.99805C9.02832 6.26605 9.86732 7.40607 11.0263 7.82507L11.0283 10.998H7.02832C6.47632 10.998 6.02832 11.446 6.02832 11.998L6.02731 16.173C4.87631 16.569 4.02832 17.73 4.02832 18.998C4.02832 20.655 5.37132 21.998 7.02832 21.998C8.68532 21.998 10.0283 20.655 10.0283 18.998C10.0283 17.73 9.23332 16.612 8.03932 16.16L8.02832 12.998H12.0283H16.0283L16.0353 16.175C14.8343 16.592 14.0283 17.73 14.0283 18.998C14.0283 20.655 15.3713 21.998 17.0283 21.998C18.6853 21.998 20.0283 20.655 20.0283 18.998C20.0283 17.73 19.2093 16.614 18.0363 16.17L18.0283 11.998C18.0283 11.446 17.5803 10.998 17.0283 10.998H13.0283L13.0253 7.82104C14.1893 7.41004 15.0283 6.26605 15.0283 4.99805C15.0283 3.34105 13.6853 1.99805 12.0283 1.99805Z" }) });
}
function BrickGlobe(props) {
  return jsx("svg", { ...props, viewBox: "0 0 18 19", fill: "currentcolor", children: jsx("path", { d: "M8.27293 3.26461C8.46408 3.26461 8.61903 3.10949 8.61904 2.91815L8.6191 0.500008C6.2185 0.599662 4.06088 1.64036 2.50446 3.26475L8.27293 3.26461ZM10.6957 6.82116C10.6957 7.0125 10.5407 7.16762 10.3496 7.16762L0.304562 7.16782C0.613333 6.01248 1.14583 4.94828 1.85198 4.02532L10.3496 4.02518C10.5408 4.02518 10.6957 4.1803 10.6957 4.37166L10.6957 6.82116ZM15.4943 15.7353C13.9385 17.3591 11.7809 18.3997 9.37968 18.5L9.37974 16.0819C9.37974 15.8905 9.5347 15.7354 9.72585 15.7354L15.4943 15.7353ZM8.61928 18.4994C6.21868 18.3999 4.06051 17.3587 2.50477 15.735L8.2732 15.7348C8.46437 15.7348 8.61934 15.89 8.61933 16.0813L8.61928 18.4994ZM13.196 12.1777C13.196 11.9864 13.3509 11.8313 13.5421 11.8312L17.6942 11.831C17.3854 12.9863 16.8536 14.0499 16.1468 14.9735L13.5421 14.9737C13.3509 14.9737 13.1959 14.8186 13.1959 14.6272L13.196 12.1777ZM6.63574 8.26583C6.64045 8.07793 6.79397 7.92806 6.98174 7.92805L17.8631 7.92797C17.953 8.43803 18 8.96317 18 9.49919C18 10.0352 17.9529 10.5604 17.8631 11.0704L6.98317 11.07C6.79504 11.0699 6.64138 10.9195 6.63718 10.7312L6.6074 9.39625L6.63574 8.26583ZM12.5542 14.6279C12.5542 14.8192 12.3992 14.9743 12.2081 14.9743L1.85233 14.9744C1.14562 14.0509 0.613778 12.9873 0.305062 11.832L12.2081 11.8319C12.3993 11.8319 12.5543 11.987 12.5543 12.1784L12.5542 14.6279ZM0.136912 7.92839L5.5227 7.92809C5.71386 7.92809 5.86883 8.08321 5.86883 8.27457L5.86877 10.7241C5.86877 10.9154 5.71381 11.0705 5.52266 11.0706L0.136834 11.0708C0.046996 10.5608 -1.44252e-05 10.0356 -1.12058e-06 9.49961C1.02767e-05 8.9636 0.0470512 8.43845 0.136912 7.92839ZM11.4567 4.3716C11.4567 4.18026 11.6117 4.02515 11.8028 4.02514L16.1471 4.02498C16.8538 4.94851 17.3856 6.01207 17.6943 7.1674L11.8028 7.1676C11.6116 7.1676 11.4567 7.01248 11.4567 6.82112L11.4567 4.3716ZM9.3801 0.500001C11.7807 0.599542 13.9389 1.64073 15.4946 3.26444L9.72617 3.26457C9.53501 3.26458 9.38004 3.10945 9.38004 2.9181L9.3801 0.500001Z" }) });
}
function Briefcase(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M7.33203 1.99414C5.85936 1.99414 4.66536 3.18814 4.66536 4.66081H3.9987C2.61203 4.66081 1.50204 5.72481 1.37337 7.07747C1.71071 7.19281 6.22803 8.70282 6.22803 8.70215C7.18469 9.02148 8.8127 9.02148 9.76937 8.70215C9.76937 8.70215 13.224 7.54881 14.6447 7.07747C14.5214 5.71947 13.3887 4.66081 11.9987 4.66081H11.332C11.332 3.18814 10.138 1.99414 8.66536 1.99414H7.33203ZM7.33203 3.32747H8.66536C9.40203 3.32747 9.9987 3.92414 9.9987 4.66081H5.9987C5.9987 3.92414 6.59536 3.32747 7.33203 3.32747ZM1.33203 8.47347V11.3275C1.33203 12.8001 2.52603 13.9941 3.9987 13.9941H11.9987C13.4714 13.9941 14.6654 12.8001 14.6654 11.3275V8.47347L10.186 9.97347C8.95603 10.3835 7.04136 10.3835 5.81136 9.97347L1.33203 8.47347Z" }) });
}
function Calendar(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M8.00586 2.01367C7.45356 2.01367 7.00586 2.46167 7.00586 3.01367C4.79676 3.01367 3.00576 4.80467 3.00586 7.01367V8.07568L21.0059 8.01367V7.01367C21.0059 4.80467 19.215 3.01367 17.0059 3.01367C17.0059 2.46167 16.5582 2.01367 16.0059 2.01367C15.4536 2.01367 15.0059 2.46167 15.0059 3.01367H9.00586C9.00586 2.46167 8.55816 2.01367 8.00586 2.01367ZM3.00586 10.0137V17.0137C3.00586 19.2227 4.79676 21.0137 7.00586 21.0137H17.0059C19.215 21.0137 21.006 19.2227 21.0059 17.0137V10.0137H3.00586ZM8.00586 12.0137C8.55816 12.0137 9.00586 12.4617 9.00586 13.0137C9.00586 13.5657 8.55816 14.0137 8.00586 14.0137C7.45356 14.0137 7.00586 13.5657 7.00586 13.0137C7.00586 12.4617 7.45356 12.0137 8.00586 12.0137ZM12.0059 12.0137C12.5582 12.0137 13.0059 12.4617 13.0059 13.0137C13.0059 13.5657 12.5582 14.0137 12.0059 14.0137C11.4536 14.0137 11.0059 13.5657 11.0059 13.0137C11.0059 12.4617 11.4536 12.0137 12.0059 12.0137ZM16.0059 12.0137C16.5582 12.0137 17.0059 12.4617 17.0059 13.0137C17.0059 13.5657 16.5582 14.0137 16.0059 14.0137C15.4536 14.0137 15.0059 13.5657 15.0059 13.0137C15.0059 12.4617 15.4536 12.0137 16.0059 12.0137ZM8.00586 15.0137C8.55816 15.0137 9.00586 15.4617 9.00586 16.0137C9.00586 16.5657 8.55816 17.0137 8.00586 17.0137C7.45356 17.0137 7.00586 16.5657 7.00586 16.0137C7.00586 15.4617 7.45356 15.0137 8.00586 15.0137ZM12.0059 15.0137C12.5582 15.0137 13.0059 15.4617 13.0059 16.0137C13.0059 16.5657 12.5582 17.0137 12.0059 17.0137C11.4536 17.0137 11.0059 16.5657 11.0059 16.0137C11.0059 15.4617 11.4536 15.0137 12.0059 15.0137ZM16.0059 15.0137C16.5582 15.0137 17.0059 15.4617 17.0059 16.0137C17.0059 16.5657 16.5582 17.0137 16.0059 17.0137C15.4536 17.0137 15.0059 16.5657 15.0059 16.0137C15.0059 15.4617 15.4536 15.0137 16.0059 15.0137Z" }) });
}
function CaretDown(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.28221 5.22951C3.98888 4.9235 3.51331 4.9235 3.21999 5.22951C2.92667 5.53552 2.92667 6.03168 3.21999 6.33769L7.46885 10.7704C7.47802 10.78 7.48736 10.7892 7.49688 10.7982C7.50402 10.8049 7.51125 10.8115 7.51858 10.8179C7.81368 11.0756 8.25385 11.0598 8.53115 10.7705L12.78 6.33777C13.0733 6.03175 13.0733 5.5356 12.78 5.22958C12.4867 4.92357 12.0111 4.92357 11.7178 5.22958L8.00004 9.10822L4.28221 5.22951Z" }) });
}
function CaretSort(props) {
  return jsx("svg", { ...props, viewBox: "0 0 15 16", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.93185 5.93185C4.75611 6.10759 4.75611 6.39251 4.93185 6.56825C5.10759 6.74398 5.39251 6.74398 5.56825 6.56825L7.50005 4.63644L9.43185 6.56825C9.60759 6.74398 9.89251 6.74398 10.0682 6.56825C10.244 6.39251 10.244 6.10759 10.0682 5.93185L7.81825 3.68185C7.73386 3.59746 7.6194 3.55005 7.50005 3.55005C7.3807 3.55005 7.26624 3.59746 7.18185 3.68185L4.93185 5.93185ZM10.0682 10.0682C10.244 9.89251 10.244 9.60759 10.0682 9.43185C9.89251 9.25612 9.60759 9.25612 9.43185 9.43185L7.50005 11.3637L5.56825 9.43185C5.39251 9.25612 5.10759 9.25612 4.93185 9.43185C4.75612 9.60759 4.75612 9.89251 4.93185 10.0682L7.18185 12.3182C7.35759 12.494 7.64251 12.494 7.81825 12.3182L10.0682 10.0682Z" }) });
}
function Caret(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M10 16L10 12.8L10 11.2L10 8L14 12L10 16Z" }) });
}
function CheckCircleFill(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M12 3C7.0293 3 3 7.0293 3 12C3 16.9707 7.0293 21 12 21C16.9707 21 21 16.9707 21 12C21 7.0293 16.9707 3 12 3ZM15.6 9.3C15.8304 9.3 16.0707 9.37741 16.2471 9.55291C16.5981 9.90481 16.5981 10.4952 16.2471 10.8471L12.8721 14.1942C11.8362 15.2292 10.2531 15.0744 9.4404 13.8558L8.54041 12.5058C8.26501 12.0927 8.38019 11.5167 8.79419 11.2404C9.20729 10.965 9.78329 11.0802 10.0596 11.4942L10.9596 12.8442C11.1414 13.1169 11.3745 13.1601 11.6058 12.9279L14.9529 9.55291C15.1293 9.37741 15.3696 9.3 15.6 9.3Z" }) });
}
function CheckCircle(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 24 24", fill: "none", children: [jsx("circle", { cx: "12", cy: "12", r: "10", fill: "none" }), jsx("path", { d: "M10.1575 16.8849C10.5032 16.8849 10.8257 16.7467 11.0562 16.5162L18.3142 9.25817L16.517 7.46094L10.1575 13.8204L7.48473 11.1476L5.6875 12.9448L9.25893 16.5162C9.48934 16.7467 9.81192 16.8849 10.1575 16.8849Z", fill: "currentcolor" }), jsx("path", { d: "M2.51367 12C2.51367 6.75314 6.76701 2.5 12.0137 2.5C17.2603 2.5 21.5137 6.75314 21.5137 12C21.5137 17.2468 17.2603 21.5 12.0137 21.5C6.76701 21.5 2.51367 17.2468 2.51367 12Z", stroke: "currentcolor" })] });
}
function Check(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M10.1575 16.8849C10.5032 16.8849 10.8257 16.7467 11.0562 16.5162L18.3142 9.25817L16.517 7.46094L10.1575 13.8204L7.48473 11.1476L5.6875 12.9448L9.25893 16.5162C9.48934 16.7467 9.81192 16.8849 10.1575 16.8849Z" }) });
}
function Checkmark(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.2086 4.01018C12.4975 4.19908 12.5786 4.58642 12.3897 4.87532L7.85635 11.8087C7.75619 11.9618 7.59392 12.0634 7.41237 12.0866C7.23083 12.1098 7.04824 12.0522 6.91282 11.9291L3.97949 9.26242C3.72408 9.03023 3.70525 8.63495 3.93744 8.37954C4.16964 8.12413 4.56492 8.1053 4.82033 8.33749L7.21128 10.5111L11.3435 4.19126C11.5324 3.90236 11.9197 3.82129 12.2086 4.01018Z" }) });
}
function ChevronDown(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "none", stroke: "currentcolor", children: jsx("path", { d: "M6 9L12 15L18 9", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) });
}
function CircleInfo(props) {
  return jsxs("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", fill: "none", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 2C4.8934 2 2 4.8934 2 8C2 11.1066 4.8934 14 8 14C11.1066 14 14 11.1066 14 8C14 4.8934 11.1066 2 8 2ZM0.5 8C0.5 3.85786 3.85786 0.5 8 0.5C12.1422 0.5 15.5 3.85786 15.5 8C15.5 12.1422 12.1422 15.5 8 15.5C3.85786 15.5 0.5 12.1422 0.5 8Z", fill: "currentcolor" }), jsx("path", { d: "M8 12.5C7.58579 12.5 7.25 12.1642 7.25 11.75V8C7.25 7.58579 7.58579 7.25 8 7.25C8.41421 7.25 8.75 7.58579 8.75 8V11.75C8.75 12.1642 8.41421 12.5 8 12.5Z", fill: "currentcolor" }), jsx("path", { d: "M8 5.75C7.58579 5.75 7.25 5.41421 7.25 5C7.25 4.58579 7.58579 4.25 8 4.25C8.41421 4.25 8.75 4.58579 8.75 5C8.75 5.41421 8.41421 5.75 8 5.75Z", fill: "currentcolor" })] });
}
function Circle(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("circle", { cx: "8", cy: "8", r: "6.665" }) });
}
function ClockFill(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M12 3C7.02948 3 3 7.0293 3 12C3 16.9707 7.02948 21 12 21C16.9705 21 21 16.9707 21 12C21 7.0293 16.9705 3 12 3ZM12 6.6C12.4971 6.6 12.9 7.0032 12.9 7.5V11.6058L15.3469 14.0529C15.6984 14.4048 15.6984 14.9952 15.3469 15.3471C14.9954 15.6981 14.4046 15.6981 14.0531 15.3471L11.3531 12.6471C11.1843 12.4779 11.1 12.2385 11.1 12V7.5C11.1 7.0032 11.5029 6.6 12 6.6Z" }) });
}
function Clock(props) {
  return jsx("svg", { ...props, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.00022 0.967133C4.11618 0.967133 0.967529 4.11578 0.967529 7.99982C0.967529 11.8838 4.11617 15.0325 8.00022 15.0325C11.8842 15.0325 15.0329 11.8838 15.0329 7.99982C15.0329 4.11578 11.8842 0.967133 8.00022 0.967133ZM1.91753 7.99982C1.91753 4.64045 4.64085 1.91713 8.00022 1.91713C11.3596 1.91713 14.0829 4.64045 14.0829 7.99982C14.0829 11.3592 11.3596 14.0825 8.00022 14.0825C4.64085 14.0825 1.91753 11.3592 1.91753 7.99982ZM8.50012 4.8C8.50012 4.52386 8.27626 4.3 8.00012 4.3C7.72398 4.3 7.50012 4.52386 7.50012 4.8V8C7.50012 8.13261 7.5528 8.25979 7.64657 8.35355L9.7799 10.4869C9.97516 10.6821 10.2917 10.6821 10.487 10.4869C10.6823 10.2916 10.6823 9.97504 10.487 9.77978L8.50012 7.79289V4.8Z", fill: "currentColor" }) });
}
function CloudSlash(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M12.0137 3.99043C10.8277 4.00043 9.59167 4.33942 8.51367 4.95942C8.03467 5.23442 7.86367 5.85542 8.13867 6.33442C8.41367 6.81342 9.03467 6.95347 9.51367 6.67847C10.2927 6.23047 11.1717 5.99742 12.0137 5.99042C14.6947 5.96942 17.0347 8.27742 17.0137 10.9904C17.0137 11.0504 17.0137 11.8534 17.0137 12.0844C17.0137 12.5504 17.3097 12.9794 17.7637 13.0844C19.0797 13.3884 20.0137 14.3904 20.0137 15.4904C20.0137 15.8464 19.9357 16.2034 19.7637 16.5224C19.5017 17.0074 19.6837 17.6034 20.1697 17.8654C20.6557 18.1284 21.2517 17.9454 21.5137 17.4594C21.8417 16.8524 22.0137 16.1824 22.0137 15.4904C22.0137 13.6764 20.8217 12.1095 19.0097 11.3765C19.0117 11.1985 19.0137 11.0174 19.0137 10.9904C19.0437 7.15542 15.8047 3.96143 12.0137 3.99043ZM5.01367 5.99042C4.75767 5.99042 4.48968 6.07647 4.29468 6.27247C3.90468 6.66247 3.90468 7.31941 4.29468 7.70941L5.40268 8.80542C5.29468 9.03042 5.24667 9.28445 5.19067 9.54345C3.28667 10.3735 2.01367 12.2084 2.01367 14.3654C2.01367 17.3754 4.38968 19.9904 7.32568 19.9904H16.5757L17.2947 20.7094C17.6857 21.1004 18.3417 21.1004 18.7327 20.7094C19.1227 20.3194 19.1227 19.6624 18.7327 19.2724L17.7327 18.2724L5.73267 6.27247C5.53667 6.07647 5.26967 5.99042 5.01367 5.99042ZM7.04169 10.4495L14.5757 17.9904H7.32568C5.53868 17.9904 4.01367 16.3124 4.01367 14.3654C4.01367 12.8734 4.94767 11.6624 6.35767 11.2404C6.71567 11.1334 6.99369 10.8025 7.04169 10.4495Z" }) });
}
function Collapse(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M13.3351 1.99414C13.1645 1.99414 12.9858 2.05148 12.8558 2.18148L10.1891 4.84814L8.66847 3.32747V7.32747H12.6685L11.1478 5.8068L13.8145 3.14014C14.0745 2.87947 14.0745 2.44214 13.8145 2.18148C13.6845 2.05148 13.5058 1.99414 13.3351 1.99414ZM3.33514 8.66081L4.85581 10.1815L2.18914 12.8481C1.92914 13.1088 1.92914 13.5461 2.18914 13.8068C2.31914 13.9368 2.4978 13.9941 2.66847 13.9941C2.83914 13.9941 3.0178 13.9368 3.1478 13.8068L5.81446 11.1401L7.33513 12.6608V8.66081H3.33514Z" }) });
}
function Compass(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("g", { clipPath: "url(#clip0_1808_6629)", children: jsx("path", { d: "M16 14.2563C15.0125 14.2563 14.2563 15.0688 14.2563 16C14.2563 16.9312 15.0688 17.7437 16 17.7437C16.9312 17.7437 17.7437 16.9312 17.7437 16C17.7437 15.0688 16.9875 14.2563 16 14.2563ZM16 0C7.2125 0 0 7.2125 0 16C0 24.7875 7.2125 32 16 32C24.7875 32 32 24.7875 32 16C32 7.2125 24.7875 0 16 0ZM20.4774 17.5343C19.8789 18.8351 18.8351 19.8789 17.5343 20.4774L8.86286 24.4669C8.0186 24.8553 7.14732 23.9826 7.53712 23.139L11.5267 14.5045C12.1228 13.2144 13.1575 12.1777 14.4464 11.5792L23.134 7.54512C23.9777 7.15332 24.8524 8.02495 24.4636 8.87006L20.4774 17.5343Z", fill: "currentcolor" }) }), jsx("defs", { children: jsx("clipPath", { id: "clip0_1808_6629", children: jsx("rect", { width: "32", height: "32", fill: "white" }) }) })] });
}
function ConnectSmall(props) {
  return jsx("svg", { ...props, width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M11.0306 3.68615C11.2854 3.68614 11.492 3.47932 11.4921 3.2242L11.4921 9.03413e-06C8.29133 0.132881 5.41451 1.52048 3.33928 3.68633L11.0306 3.68615ZM14.2609 8.42821C14.2609 8.68334 14.0543 8.89016 13.7994 8.89016L0.406086 8.89043C0.81778 7.34998 1.52777 5.93103 2.46931 4.70043L13.7995 4.70024C14.0544 4.70023 14.261 4.90707 14.261 5.16221L14.2609 8.42821ZM20.6591 20.3137C18.5847 22.4787 15.7079 23.8663 12.5062 24L12.5063 20.7758C12.5063 20.5207 12.7129 20.3139 12.9678 20.3139L20.6591 20.3137ZM11.4924 23.9992C8.29157 23.8665 5.41401 22.4782 3.33969 20.3133L11.0309 20.3131C11.2858 20.3131 11.4924 20.52 11.4924 20.7751L11.4924 23.9992ZM17.5946 15.5703C17.5947 15.3152 17.8013 15.1083 18.0561 15.1083L23.5923 15.108C23.1806 16.6484 22.4714 18.0666 21.5291 19.298L18.0561 19.2983C17.8012 19.2983 17.5946 19.0914 17.5946 18.8363L17.5946 15.5703ZM8.84765 10.3544C8.85393 10.1039 9.05863 9.90407 9.30899 9.90407L23.8175 9.90396C23.9373 10.584 24 11.2842 24 11.9989C24 12.7136 23.9372 13.4138 23.8174 14.0939L9.31089 14.0933C9.06005 14.0932 8.85517 13.8927 8.84957 13.6416L8.80986 11.8617L8.84765 10.3544ZM16.7389 18.8372C16.7389 19.0923 16.5323 19.2991 16.2774 19.2991L2.46978 19.2992C1.52749 18.0679 0.818373 16.6498 0.406752 15.1093L16.2775 15.1092C16.5324 15.1092 16.739 15.316 16.739 15.5712L16.7389 18.8372ZM0.182552 9.90452L7.3636 9.90412C7.61849 9.90411 7.82511 10.1109 7.82511 10.3661L7.82503 13.6321C7.82503 13.8872 7.61842 14.0941 7.36355 14.0941L0.182447 14.0945C0.062664 13.4144 -1.71661e-05 12.7142 0 11.9995C1.71661e-05 11.2848 0.0627384 10.5846 0.182552 9.90452ZM15.2756 5.16214C15.2757 4.90701 15.4823 4.70019 15.7371 4.70019L21.5294 4.69998C22.4717 5.93135 23.1808 7.34943 23.5924 8.88987L15.7371 8.89013C15.4822 8.89014 15.2756 8.6833 15.2756 8.42816L15.2756 5.16214ZM12.5068 0C15.7076 0.132721 18.5852 1.52098 20.6595 3.68592L12.9682 3.6861C12.7133 3.6861 12.5067 3.47927 12.5067 3.22413L12.5068 0Z", fill: "#9EA0A1" }) });
}
function Connect(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 242 62", fill: "currentcolor", children: [jsx("path", { d: "M29.2499 16.0724C29.526 16.0724 29.7499 15.8485 29.7499 15.5724L29.75 9.45358C23.9969 9.69217 18.8261 12.1837 15.0961 16.0727L29.2499 16.0724ZM21.6271 24.9167C21.6271 25.1928 21.4033 25.4167 21.1271 25.4167L9.82394 25.4172C10.5639 22.6511 11.8401 20.1033 13.5324 17.8936L21.1272 17.8933C21.4034 17.8933 21.6272 18.1171 21.6272 18.3933L21.6271 24.9167ZM46.2267 45.9287C42.4981 49.8163 37.3274 52.3078 31.5728 52.5478L31.5729 46.4291C31.5729 46.1529 31.7968 45.9291 32.0729 45.9291L46.2267 45.9287ZM29.7504 52.5464C23.9973 52.3081 18.8252 49.8154 15.0968 45.928L29.2506 45.9277C29.5267 45.9277 29.7506 46.1516 29.7506 46.4277L29.7504 52.5464ZM24.1289 37.082C24.1289 36.8059 24.3527 36.582 24.6289 36.582L51.4988 36.5814C50.7589 39.3474 49.4842 41.8938 47.7904 44.1049L24.6287 44.1055C24.3526 44.1055 24.1287 43.8816 24.1287 43.6054L24.1289 37.082ZM41.5947 27.7247C41.6015 27.4536 41.8233 27.2373 42.0945 27.2373L51.9037 27.2371C52.119 28.4582 52.2317 29.7155 52.2317 30.9988C52.2316 32.282 52.1189 33.5393 51.9035 34.7605L42.0971 34.7593C41.8253 34.7593 41.6033 34.5422 41.5973 34.2705L41.5187 30.7523L41.5947 27.7247ZM22.5908 43.607C22.5908 43.8831 22.3669 44.107 22.0908 44.107L13.5332 44.1071C11.8396 41.8961 10.565 39.3498 9.82514 36.5838L22.0909 36.5835C22.3671 36.5835 22.591 36.8074 22.5909 37.0835L22.5908 43.607ZM9.42216 27.2381L39.2487 27.2373C39.5249 27.2373 39.7487 27.4612 39.7487 27.7374L39.7486 34.2608C39.7486 34.5369 39.5247 34.7608 39.2486 34.7608L9.42197 34.7615C9.20667 33.5404 9.094 32.2831 9.09403 30.9998C9.09406 29.7165 9.2068 28.4592 9.42216 27.2381ZM23.451 18.3932C23.451 18.1171 23.6749 17.8932 23.951 17.8932L47.791 17.8928C49.4847 20.1039 50.7593 22.6502 51.4991 25.4162L23.9509 25.4166C23.6747 25.4167 23.4509 25.1928 23.4509 24.9166L23.451 18.3932ZM31.5738 9.45357C37.3269 9.69188 42.499 12.1846 46.2274 16.072L32.0737 16.0723C31.7975 16.0723 31.5736 15.8484 31.5736 15.5723L31.5738 9.45357Z" }), jsx("path", { d: "M66.6074 31.1806C66.6074 28.1869 67.2536 25.5242 68.5459 23.1925C69.8382 20.8321 71.6331 19.0042 73.9306 17.7089C76.2568 16.3847 78.8845 15.7227 81.8138 15.7227C85.4036 15.7227 88.4765 16.6726 91.0324 18.5724C93.5884 20.4723 95.2971 23.063 96.1587 26.3446H88.0601C87.457 25.078 86.5954 24.1137 85.4754 23.4516C84.3841 22.7895 83.1349 22.4585 81.7277 22.4585C79.4589 22.4585 77.6209 23.2501 76.2137 24.8333C74.8065 26.4165 74.1029 28.5323 74.1029 31.1806C74.1029 33.8289 74.8065 35.9446 76.2137 37.5278C77.6209 39.111 79.4589 39.9027 81.7277 39.9027C83.1349 39.9027 84.3841 39.5716 85.4754 38.9095C86.5954 38.2475 87.457 37.2832 88.0601 36.0166H96.1587C95.2971 39.2982 93.5884 41.8889 91.0324 43.7887C88.4765 45.6598 85.4036 46.5953 81.8138 46.5953C78.8845 46.5953 76.2568 45.9477 73.9306 44.6523C71.6331 43.3282 69.8382 41.5003 68.5459 39.1686C67.2536 36.837 66.6074 34.1743 66.6074 31.1806Z" }), jsx("path", { d: "M109.888 46.7249C107.533 46.7249 105.408 46.2211 103.513 45.2136C101.646 44.2061 100.167 42.7668 99.0758 40.8958C98.0132 39.0247 97.4819 36.837 97.4819 34.3326C97.4819 31.857 98.0276 29.6837 99.1189 27.8127C100.21 25.9128 101.704 24.4591 103.599 23.4516C105.494 22.4441 107.62 21.9404 109.974 21.9404C112.329 21.9404 114.455 22.4441 116.35 23.4516C118.245 24.4591 119.739 25.9128 120.83 27.8127C121.921 29.6837 122.467 31.857 122.467 34.3326C122.467 36.8082 121.907 38.9959 120.787 40.8958C119.696 42.7668 118.188 44.2061 116.264 45.2136C114.368 46.2211 112.243 46.7249 109.888 46.7249ZM109.888 40.3344C111.295 40.3344 112.487 39.8163 113.464 38.78C114.469 37.7437 114.971 36.2613 114.971 34.3326C114.971 32.404 114.483 30.9215 113.507 29.8852C112.559 28.8489 111.382 28.3308 109.974 28.3308C108.539 28.3308 107.347 28.8489 106.399 29.8852C105.451 30.8927 104.977 32.3752 104.977 34.3326C104.977 36.2613 105.437 37.7437 106.356 38.78C107.304 39.8163 108.481 40.3344 109.888 40.3344Z" }), jsx("path", { d: "M139.298 22.0267C142.113 22.0267 144.353 22.9479 146.018 24.7902C147.713 26.6037 148.56 29.108 148.56 32.3032V46.3794H141.237V33.2963C141.237 31.6843 140.82 30.4322 139.987 29.5398C139.155 28.6474 138.035 28.2013 136.627 28.2013C135.22 28.2013 134.1 28.6474 133.267 29.5398C132.434 30.4322 132.018 31.6843 132.018 33.2963V46.3794H124.652V22.2858H132.018V25.481C132.765 24.4159 133.77 23.5812 135.033 22.9767C136.297 22.3434 137.719 22.0267 139.298 22.0267Z" }), jsx("path", { d: "M166.602 22.0267C169.416 22.0267 171.656 22.9479 173.322 24.7902C175.016 26.6037 175.864 29.108 175.864 32.3032V46.3794H168.54V33.2963C168.54 31.6843 168.124 30.4322 167.291 29.5398C166.458 28.6474 165.338 28.2013 163.931 28.2013C162.524 28.2013 161.404 28.6474 160.571 29.5398C159.738 30.4322 159.322 31.6843 159.322 33.2963V46.3794H151.956V22.2858H159.322V25.481C160.069 24.4159 161.074 23.5812 162.337 22.9767C163.601 22.3434 165.022 22.0267 166.602 22.0267Z" }), jsx("path", { d: "M201.918 33.944C201.918 34.6349 201.875 35.3545 201.789 36.1029H185.118C185.233 37.5998 185.707 38.7512 186.539 39.5572C187.401 40.3344 188.449 40.723 189.684 40.723C191.522 40.723 192.8 39.9458 193.518 38.3914H201.358C200.956 39.9746 200.224 41.3995 199.161 42.6661C198.127 43.9327 196.821 44.9258 195.241 45.6454C193.662 46.365 191.895 46.7249 189.943 46.7249C187.588 46.7249 185.491 46.2211 183.653 45.2136C181.815 44.2061 180.379 42.7668 179.346 40.8958C178.312 39.0247 177.795 36.837 177.795 34.3326C177.795 31.8283 178.297 29.6405 179.302 27.7695C180.336 25.8984 181.772 24.4591 183.61 23.4516C185.448 22.4441 187.559 21.9404 189.943 21.9404C192.269 21.9404 194.337 22.4297 196.146 23.4084C197.955 24.3872 199.362 25.7833 200.367 27.5968C201.401 29.4103 201.918 31.526 201.918 33.944ZM194.38 32.001C194.38 30.7344 193.949 29.7269 193.087 28.9785C192.226 28.23 191.149 27.8558 189.856 27.8558C188.622 27.8558 187.573 28.2157 186.712 28.9353C185.879 29.6549 185.362 30.6768 185.161 32.001H194.38Z" }), jsx("path", { d: "M202.617 34.3326C202.617 31.8283 203.119 29.6405 204.124 27.7695C205.158 25.8984 206.58 24.4591 208.389 23.4516C210.227 22.4441 212.323 21.9404 214.678 21.9404C217.694 21.9404 220.207 22.732 222.217 24.3152C224.256 25.8984 225.591 28.1293 226.223 31.0079H218.383C217.722 29.1656 216.444 28.2444 214.549 28.2444C213.199 28.2444 212.122 28.777 211.318 29.842C210.514 30.8783 210.112 32.3752 210.112 34.3326C210.112 36.29 210.514 37.8013 211.318 38.8664C212.122 39.9027 213.199 40.4208 214.549 40.4208C216.444 40.4208 217.722 39.4997 218.383 37.6574H226.223C225.591 40.4784 224.256 42.6949 222.217 44.3069C220.178 45.9189 217.665 46.7249 214.678 46.7249C212.323 46.7249 210.227 46.2211 208.389 45.2136C206.58 44.2061 205.158 42.7668 204.124 40.8958C203.119 39.0247 202.617 36.837 202.617 34.3326Z" }), jsx("path", { d: "M241.837 40.1185V46.3794H238.09C235.419 46.3794 233.337 45.7318 231.843 44.4364C230.35 43.1123 229.603 40.9677 229.603 38.0028V28.4172H226.674V22.2858H229.603V16.4135H236.97V22.2858H241.794V28.4172H236.97V38.0892C236.97 38.8088 237.142 39.3269 237.486 39.6436C237.831 39.9602 238.405 40.1185 239.21 40.1185H241.837Z" })] });
}
function Copy(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.09998 10.2001C1.09998 11.0285 1.77155 11.7001 2.59998 11.7001H4.26664V10.7001H2.59998C2.32383 10.7001 2.09998 10.4762 2.09998 10.2001L2.09998 2.6001C2.09998 2.32396 2.32383 2.1001 2.59998 2.1001L10.2 2.1001C10.4761 2.1001 10.7 2.32395 10.7 2.6001V4.26676H11.7V2.6001C11.7 1.77167 11.0284 1.1001 10.2 1.1001L2.59998 1.1001C1.77155 1.1001 1.09998 1.77167 1.09998 2.6001L1.09998 10.2001ZM5.79998 4.30006C4.97155 4.30006 4.29998 4.97163 4.29998 5.80005V13.4001C4.29998 14.2285 4.97155 14.9001 5.79998 14.9001H13.4C14.2284 14.9001 14.9 14.2285 14.9 13.4001V5.80006C14.9 4.97163 14.2284 4.30006 13.4 4.30006H5.79998ZM5.29998 5.80005C5.29998 5.52391 5.52384 5.30006 5.79998 5.30006H13.4C13.6761 5.30006 13.9 5.52391 13.9 5.80006V13.4001C13.9 13.6762 13.6761 13.9001 13.4 13.9001H5.79998C5.52384 13.9001 5.29998 13.6762 5.29998 13.4001V5.80005Z" }) });
}
function Created(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { x: "1.5", y: "1.5", width: "13", height: "13", rx: "3.5", stroke: "currentcolor" }), jsx("path", { d: "M4 8H12", stroke: "currentcolor", strokeLinecap: "round" }), jsx("path", { d: "M8 12V4", stroke: "currentcolor", strokeLinecap: "round" })] });
}
function CrossCircle(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("g", { clipPath: "url(#clip0_14287_3626)", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0.935547 7.9999C0.935547 4.09837 4.09837 0.935547 7.9999 0.935547C11.9014 0.935547 15.0643 4.09837 15.0643 7.9999C15.0643 11.9014 11.9014 15.0643 7.9999 15.0643C4.09837 15.0643 0.935547 11.9014 0.935547 7.9999ZM7.9999 1.94888C4.65802 1.94888 1.94888 4.65802 1.94888 7.9999C1.94888 11.3418 4.65802 14.0509 7.9999 14.0509C11.3418 14.0509 14.0509 11.3418 14.0509 7.9999C14.0509 4.65802 11.3418 1.94888 7.9999 1.94888ZM10.5105 5.48957C10.7188 5.69785 10.7188 6.03554 10.5105 6.24382L8.75427 8.00003L10.5105 9.75624C10.7188 9.96451 10.7188 10.3022 10.5105 10.5105C10.3022 10.7188 9.96451 10.7188 9.75624 10.5105L8.00003 8.75427L6.24382 10.5105C6.03554 10.7188 5.69785 10.7188 5.48957 10.5105C5.28129 10.3022 5.28129 9.96451 5.48957 9.75624L7.24578 8.00003L5.48957 6.24382C5.28129 6.03554 5.28129 5.69785 5.48957 5.48957C5.69785 5.28129 6.03554 5.28129 6.24382 5.48957L8.00003 7.24578L9.75624 5.48957C9.96451 5.28129 10.3022 5.28129 10.5105 5.48957Z", fill: "currentcolor" }) }), jsx("defs", { children: jsx("clipPath", { id: "clip0_14287_3626", children: jsx("rect", { width: "16", height: "16", fill: "white" }) }) })] });
}
function Danger(props) {
  return jsx("svg", { ...props, width: "14", height: "13", viewBox: "0 0 14 13", fill: "currentcolor", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M7.00951 0.332642C5.90244 0.333309 5.06924 0.911309 4.40531 2.08264L1.09284 8.1453C0.580175 9.0393 0.338108 9.66798 0.342842 10.3326C0.353442 11.8206 1.54977 12.994 3.00951 12.9993H11.0095C12.471 12.9993 13.6706 11.8433 13.6762 10.3326C13.6786 9.66998 13.4178 9.0013 12.9053 8.1453L9.63451 2.12463C9.02057 0.951968 8.13171 0.331975 7.00951 0.332642ZM7.00951 4.33264C7.37771 4.33264 7.67617 4.63131 7.67617 4.99931V7.66598C7.67617 8.03398 7.37771 8.33264 7.00951 8.33264C6.64131 8.33264 6.34284 8.03398 6.34284 7.66598V4.99931C6.34284 4.63131 6.64131 4.33264 7.00951 4.33264ZM7.00951 8.99931C7.37771 8.99931 7.67617 9.29797 7.67617 9.66597C7.67617 10.034 7.37771 10.3326 7.00951 10.3326C6.64131 10.3326 6.34284 10.034 6.34284 9.66597C6.34284 9.29797 6.64131 8.99931 7.00951 8.99931Z" }) });
}
function DescendenceModified(props) {
  return jsxs("svg", { ...props, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { x: "1.5", y: "1.5", width: "13", height: "13", rx: "3.5", stroke: "currentcolor" }), jsx("rect", { x: "4", y: "7", width: "2", height: "2", rx: "1", fill: "currentcolor" }), jsx("rect", { x: "7", y: "7", width: "2", height: "2", rx: "1", fill: "currentcolor" }), jsx("rect", { x: "10", y: "7", width: "2", height: "2", rx: "1", fill: "currentcolor" })] });
}
function Disconnect(props) {
  return jsx("svg", { ...props, viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M12.6604 5.9939C12.6604 5.6259 12.3618 5.32723 11.9938 5.32723H5.99377V3.32723L3.32711 5.9939L5.99377 8.66056V6.66056H11.9938C12.3618 6.66056 12.6604 6.3619 12.6604 5.9939ZM10.6604 2.66056C10.6604 1.1879 9.46644 -0.00610352 7.99377 -0.00610352H2.66044C1.18777 -0.00610352 -0.00622559 1.1879 -0.00622559 2.66056V9.32723C-0.00622559 10.7999 1.18777 11.9939 2.66044 11.9939H7.99377C9.46644 11.9939 10.6604 10.7999 10.6604 9.32723C10.6604 8.95923 10.3618 8.66056 9.99377 8.66056C9.62577 8.66056 9.32711 8.95923 9.32711 9.32723C9.32711 10.0639 8.73044 10.6606 7.99377 10.6606H2.66044C1.92377 10.6606 1.32711 10.0639 1.32711 9.32723V2.66056C1.32711 1.9239 1.92377 1.32723 2.66044 1.32723H7.99377C8.73044 1.32723 9.32711 1.9239 9.32711 2.66056C9.32711 3.02856 9.62577 3.32723 9.99377 3.32723C10.3618 3.32723 10.6604 3.02856 10.6604 2.66056Z", fill: "currentcolor" }) });
}
function Discord(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M6.646 7.31348C6.28467 7.31348 6 7.63014 6 8.01681C6 8.40214 6.29133 8.72014 6.646 8.72014C7.00667 8.72014 7.29133 8.40214 7.29133 8.01681C7.29867 7.62948 7.00667 7.31348 6.646 7.31348ZM8.958 7.31348C8.59667 7.31348 8.312 7.63014 8.312 8.01681C8.312 8.40214 8.60333 8.72014 8.958 8.72014C9.31867 8.72014 9.60333 8.40214 9.60333 8.01681C9.60267 7.62948 9.31867 7.31348 8.958 7.31348Z", fill: "currentcolor" }), jsx("path", { d: "M11.4978 2.99902H4.12721C3.97881 2.9994 3.83193 3.02901 3.69496 3.08615C3.558 3.1433 3.43363 3.22686 3.32896 3.33207C3.22428 3.43728 3.14136 3.56207 3.08492 3.69933C3.02848 3.83659 2.99962 3.98362 3 4.13202V11.568C3 12.195 3.506 12.701 4.12721 12.701H10.3642L10.0718 11.6827L10.7764 12.3374L11.4416 12.9534L12.625 13.999V4.13202C12.6254 3.98362 12.5965 3.83659 12.5401 3.69933C12.4836 3.56207 12.4007 3.43728 12.2961 3.33207C12.1914 3.22686 12.067 3.1433 11.93 3.08615C11.7931 3.02901 11.6462 2.9994 11.4978 2.99902ZM9.37421 10.182C9.37421 10.182 9.17621 9.94581 9.01179 9.73565C9.732 9.53187 10.007 9.08144 10.007 9.08144C9.78121 9.22965 9.567 9.33502 9.37421 9.40681C8.67235 9.70055 7.89942 9.78071 7.15221 9.63723C6.87612 9.583 6.60558 9.50354 6.344 9.39987C6.20605 9.34746 6.07198 9.28536 5.94279 9.21402C5.926 9.20187 5.90979 9.19723 5.89358 9.18623C5.88491 9.18211 5.87721 9.17619 5.871 9.16887C5.772 9.11444 5.717 9.07623 5.717 9.07623C5.717 9.07623 5.981 9.51623 6.67979 9.72523C6.51479 9.93365 6.311 10.182 6.311 10.182C5.09579 10.1432 4.63437 9.34602 4.63437 9.34602C4.63437 7.57502 5.42637 6.13981 5.42637 6.13981C6.21837 5.54523 6.97158 5.56202 6.97158 5.56202L7.02658 5.62802C6.03658 5.9146 5.57979 6.34881 5.57979 6.34881C5.57979 6.34881 5.70137 6.28281 5.90458 6.1896C6.49279 5.93139 6.96 5.8596 7.15279 5.84281C7.18579 5.8376 7.21358 5.83181 7.24658 5.83181C8.20023 5.7033 9.16994 5.88453 10.0128 6.34881C10.0128 6.34881 9.578 5.9366 8.643 5.6506L8.72 5.5626C8.72 5.5626 9.47379 5.54581 10.2652 6.14039C10.2652 6.14039 11.0572 7.5756 11.0572 9.3466C11.0572 9.34602 10.59 10.1432 9.37421 10.182Z", fill: "currentcolor" })] });
}
function DownloadFile(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("mask", { id: "mask0_4381_5452", maskUnits: "userSpaceOnUse", x: "1", y: "0", width: "30", height: "32", children: jsx("path", { d: "M31 0H1V32H31V0Z", fill: "white" }) }), jsxs("g", { mask: "url(#mask0_4381_5452)", children: [jsx("path", { d: "M19.5149 2.99247C19.2102 2.65617 18.8406 2.3869 18.4289 2.20135C18.0173 2.01581 17.5724 1.91796 17.1219 1.91388H7.95228C7.31271 1.93183 6.70624 2.20591 6.26573 2.67607C5.82522 3.14624 5.58659 3.77415 5.60212 4.42224V29.4916C5.58659 30.1397 5.82522 30.7676 6.26573 31.2378C6.70624 31.708 7.31271 31.982 7.95228 32H24.8201C25.4597 31.982 26.0662 31.708 26.5067 31.2378C26.9472 30.7676 27.1858 30.1397 27.1703 29.4916V12.837C27.1765 11.8989 26.8315 10.9932 26.2048 10.3027L19.5149 2.99247ZM18.9455 4.5811L24.1302 10.245H20.265C20.0916 10.245 19.92 10.2104 19.7598 10.1431C19.5996 10.0759 19.454 9.97738 19.3314 9.85315C19.2088 9.72893 19.1116 9.58145 19.0452 9.41914C18.9789 9.25683 18.9447 9.08287 18.9447 8.90719L18.9455 4.5811ZM25.6857 29.4916C25.7007 29.7406 25.6183 29.9856 25.4562 30.1734C25.2942 30.3612 25.0657 30.4767 24.8201 30.495H7.95228C7.70689 30.4765 7.47855 30.3609 7.31669 30.1731C7.15483 29.9853 7.07248 29.7405 7.08748 29.4916V4.42224C7.07249 4.17325 7.15495 3.9283 7.31698 3.74049C7.47902 3.55268 7.70757 3.43713 7.95311 3.4189H17.1186C17.2337 3.41924 17.3484 3.43156 17.461 3.45569V8.91137C17.461 9.66533 17.7566 10.3884 18.2828 10.9215C18.8089 11.4547 19.5226 11.7542 20.2667 11.7542H25.014C25.1371 11.7532 25.258 11.721 25.3656 11.6605C25.5768 12.0165 25.6884 12.4241 25.6882 12.8395L25.6857 29.4916Z", fill: "#343839" }), jsx("path", { d: "M18.9455 4.5811L24.1302 10.245H20.265C20.0916 10.245 19.9199 10.2104 19.7598 10.1432C19.5996 10.0759 19.454 9.97738 19.3314 9.85315C19.2088 9.72893 19.1116 9.58145 19.0452 9.41914C18.9789 9.25683 18.9447 9.08287 18.9447 8.90719L18.9455 4.5811Z", fill: "#343839" })] }), jsx("path", { d: "M21 19.7L16 26L11 19.7L14.3333 19.7L14.3333 14.1C14.3333 12.9408 15.0795 12 16 12C16.9205 12 17.6667 12.9408 17.6667 14.1L17.6667 19.7L21 19.7Z", fill: "#343839" })] });
}
function Drive(props) {
  return jsx("svg", { ...props, viewBox: "0 0 20 16", fill: "currentcolor", children: jsx("path", { d: "M20 1.84472C20 1.46377 19.7836 1.11591 19.4418 0.94761L18.088 0.28089C17.7399 0.109485 17.3242 0.154861 17.0213 0.397305L10.9046 5.29345L13.3938 7.26606L16.9338 4.43246V11.5763L2.94616 0.468456C2.64307 0.227771 2.22832 0.183587 1.88133 0.355019L0.557054 1.00929C0.215927 1.17782 0 1.52534 0 1.90583V14.1546C0 14.5354 0.216328 14.8832 0.557941 15.0516L1.9119 15.7189C2.26 15.8904 2.67592 15.8451 2.97888 15.6026L9.05159 10.7415L6.56234 8.76886L3.06621 11.5675V4.48484L17.0477 15.5957C17.3508 15.8366 17.7658 15.8809 18.1129 15.7093L19.4431 15.0519C19.7841 14.8833 20 14.5358 20 14.1554V1.84472Z" }) });
}
function Duplicated(props) {
  return jsxs("svg", { ...props, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 2H11C12.6569 2 14 3.34315 14 5V12H15V5C15 2.79086 13.2091 1 11 1H4V2Z", fill: "currentcolor" }), jsx("rect", { x: "1.5", y: "3.5", width: "11", height: "11", rx: "2.5", stroke: "currentcolor" })] });
}
function Edit(props) {
  return jsx("svg", { ...props, width: "13", height: "13", viewBox: "0 0 13 13", fill: "currentcolor", children: jsx("path", { d: "M10.0763 0.308773C9.86968 0.279439 9.66236 0.34811 9.51436 0.49611C9.36169 0.648776 3.5177 6.49277 3.5177 6.49277C3.39303 6.61743 3.33036 6.79478 3.33036 6.97144V8.9701C3.33036 9.3381 3.62903 9.63676 3.99703 9.63676C4.24636 9.63676 5.74568 9.63676 5.99568 9.63676C6.17235 9.63676 6.34969 9.57409 6.47436 9.44943C6.47436 9.44943 12.3197 3.6041 12.471 3.45277C12.6204 3.30344 12.689 3.0781 12.6584 2.86944C12.5557 2.17411 12.2617 1.65011 11.805 1.18345C11.3464 0.71478 10.7863 0.408773 10.0763 0.308773ZM2.66435 0.974788C1.19235 0.974788 -0.000976562 2.16811 -0.000976562 3.64011V10.3028C-0.000976562 11.7748 0.52569 12.9681 1.99769 12.9681H9.32702C10.799 12.9681 11.9923 11.7748 11.9923 10.3028V5.80543L7.41168 10.3861C7.03034 10.7674 6.51968 10.9694 5.99568 10.9694C5.65235 10.9694 4.34036 10.9694 3.99703 10.9694C2.89303 10.9694 1.99769 10.0741 1.99769 8.9701V6.97144C1.99769 6.44744 2.17903 5.93676 2.56036 5.55543L7.14103 0.974788H2.66435ZM10.199 1.69879C10.4537 1.77879 10.657 1.90546 10.847 2.09946C11.043 2.29946 11.179 2.50347 11.2603 2.75547C10.971 3.04213 10.651 3.35345 10.315 3.68678L9.25903 2.6301C9.59769 2.2961 9.90701 1.98679 10.199 1.69879Z" }) });
}
function Ellipsis(props) {
  return jsx("svg", { ...props, viewBox: "0 0 10 2", fill: "currentcolor", children: jsx("path", { d: "M1 0C1.552 0 2 0.448 2 1C2 1.552 1.552 2 1 2C0.448 2 0 1.552 0 1C0 0.448 0.448 0 1 0ZM5 0C5.552 0 6 0.448 6 1C6 1.552 5.552 2 5 2C4.448 2 4 1.552 4 1C4 0.448 4.448 0 5 0ZM9 0C9.552 0 10 0.448 10 1C10 1.552 9.552 2 9 2C8.448 2 8 1.552 8 1C8 0.448 8.448 0 9 0Z" }) });
}
function Error$1(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M8.00846 1.33203C4.32646 1.33203 1.3418 4.3167 1.3418 7.9987C1.3418 11.6807 4.32646 14.6654 8.00846 14.6654C11.6905 14.6654 14.6751 11.6807 14.6751 7.9987C14.6751 4.3167 11.6905 1.33203 8.00846 1.33203ZM8.00846 4.66536C8.37646 4.66536 8.67513 4.96403 8.67513 5.33203V8.66536C8.67513 9.03336 8.37646 9.33203 8.00846 9.33203C7.64046 9.33203 7.3418 9.03336 7.3418 8.66536V5.33203C7.3418 4.96403 7.64046 4.66536 8.00846 4.66536ZM8.00846 9.9987C8.37646 9.9987 8.67513 10.2974 8.67513 10.6654C8.67513 11.0334 8.37646 11.332 8.00846 11.332C7.64046 11.332 7.3418 11.0334 7.3418 10.6654C7.3418 10.2974 7.64046 9.9987 8.00846 9.9987Z" }) });
}
function Ethscan(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 14 14", fill: "none", children: [jsx("path", { d: "M2.95373 6.63309C2.95374 6.55555 2.96907 6.47878 2.99884 6.40718C3.02861 6.33558 3.07222 6.27056 3.12719 6.21587C3.18215 6.16117 3.24737 6.11787 3.31912 6.08845C3.39086 6.05903 3.46771 6.04407 3.54525 6.04444L4.52593 6.04764C4.68229 6.04764 4.83225 6.10975 4.94282 6.22032C5.05338 6.33089 5.1155 6.48085 5.1155 6.63721V10.3457C5.22595 10.3129 5.36731 10.278 5.52286 10.2414C5.63062 10.216 5.72667 10.155 5.79541 10.0682C5.86416 9.98147 5.90158 9.87401 5.9016 9.7633V5.16356C5.9016 5.00719 5.96371 4.85721 6.07428 4.74663C6.18484 4.63605 6.3348 4.5739 6.49118 4.57387H7.47483C7.63121 4.5739 7.78117 4.63605 7.89173 4.74663C8.00229 4.85721 8.0644 5.00719 8.0644 5.16356V9.43286C8.0644 9.43286 8.31049 9.33328 8.55005 9.2321C8.63907 9.19445 8.71504 9.13142 8.76847 9.05088C8.8219 8.97033 8.85043 8.87584 8.8505 8.77919V3.68957C8.8505 3.53322 8.91261 3.38328 9.02315 3.27272C9.13369 3.16215 9.28362 3.10002 9.43997 3.09999H10.4226C10.5789 3.10015 10.7287 3.16233 10.8391 3.27288C10.9496 3.38343 11.0116 3.5333 11.0116 3.68957V7.88069C11.8635 7.2633 12.7269 6.52069 13.412 5.62781C13.5114 5.4982 13.5772 5.346 13.6035 5.18479C13.6298 5.02358 13.6157 4.85837 13.5626 4.7039C13.2455 3.79145 12.7413 2.95526 12.0825 2.24883C11.4236 1.5424 10.6245 0.981296 9.73636 0.601415C8.84819 0.221534 7.8905 0.0312452 6.92458 0.0427266C5.95865 0.054208 5.00576 0.267206 4.12687 0.668091C3.24799 1.06898 2.46247 1.64892 1.82058 2.37081C1.17869 3.0927 0.694563 3.94064 0.399186 4.86037C0.103809 5.78009 0.00368315 6.75136 0.105216 7.712C0.206748 8.67265 0.507703 9.60152 0.988822 10.4392C1.07264 10.5837 1.19596 10.7013 1.3443 10.7781C1.49263 10.8549 1.65981 10.8879 1.8262 10.873C2.01208 10.8566 2.24351 10.8335 2.51867 10.8012C2.63843 10.7876 2.74899 10.7304 2.8293 10.6405C2.90961 10.5506 2.95406 10.4344 2.95419 10.3138V6.63309", fill: "currentcolor" }), jsx("path", { d: "M2.93274 12.5804C3.9685 13.3339 5.19251 13.7862 6.46936 13.8872C7.74621 13.9882 9.02612 13.7341 10.1675 13.1528C11.3088 12.5716 12.2672 11.6859 12.9364 10.5938C13.6057 9.50176 13.9598 8.24582 13.9595 6.96498C13.9595 6.80474 13.9521 6.64701 13.9415 6.48975C11.4047 10.2732 6.72085 12.0419 2.93274 12.5804Z", fill: "currentcolor" })] });
}
function Exclamation(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: [jsx("path", { d: "M9 4C9 3.448 8.552 3 8 3C7.448 3 7 3.448 7 4V9C7 9.552 7.448 10 8 10C8.552 10 9 9.552 9 9V4Z" }), jsx("path", { d: "M9 12C9 11.448 8.552 11 8 11C7.448 11 7 11.448 7 12C7 12.552 7.448 13 8 13C8.552 13 9 12.552 9 12Z" })] });
}
function ExportCsv(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("mask", { id: "mask0_4379_5249", maskUnits: "userSpaceOnUse", x: "2", y: "0", width: "30", height: "32", children: jsx("path", { d: "M32 0H2V32H32V0Z", fill: "white" }) }), jsxs("g", { mask: "url(#mask0_4379_5249)", children: [jsx("path", { d: "M20.5149 2.99247C20.2102 2.65617 19.8406 2.3869 19.4289 2.20135C19.0173 2.01581 18.5724 1.91796 18.1219 1.91388H8.95228C8.31271 1.93183 7.70624 2.20591 7.26573 2.67607C6.82522 3.14624 6.58659 3.77415 6.60212 4.42224V29.4916C6.58659 30.1397 6.82522 30.7676 7.26573 31.2378C7.70624 31.708 8.31271 31.982 8.95228 32H25.8201C26.4597 31.982 27.0662 31.708 27.5067 31.2378C27.9472 30.7676 28.1858 30.1397 28.1703 29.4916V12.837C28.1765 11.8989 27.8315 10.9932 27.2048 10.3027L20.5149 2.99247ZM19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.92 10.2104 20.7598 10.1431C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811ZM26.6857 29.4916C26.7007 29.7406 26.6183 29.9856 26.4562 30.1734C26.2942 30.3612 26.0657 30.4767 25.8201 30.495H8.95228C8.70689 30.4765 8.47855 30.3609 8.31669 30.1731C8.15483 29.9853 8.07248 29.7405 8.08748 29.4916V4.42224C8.07249 4.17325 8.15495 3.9283 8.31698 3.74049C8.47902 3.55268 8.70757 3.43713 8.95311 3.4189H18.1186C18.2337 3.41924 18.3484 3.43156 18.461 3.45569V8.91137C18.461 9.66533 18.7566 10.3884 19.2828 10.9215C19.8089 11.4547 20.5226 11.7542 21.2667 11.7542H26.014C26.1371 11.7532 26.258 11.721 26.3656 11.6605C26.5768 12.0165 26.6884 12.4241 26.6882 12.8395L26.6857 29.4916Z", fill: "#343839" }), jsx("path", { d: "M19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1432C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811Z", fill: "#343839" }), jsx("path", { d: "M23.973 28.0326H3.13249C2.83206 28.0324 2.54401 27.9079 2.33165 27.6866C2.11929 27.4653 2 27.1653 2 26.8525V19.1801C2 18.8673 2.11929 18.5672 2.33165 18.3459C2.54401 18.1247 2.83206 18.0002 3.13249 18H23.973C24.2734 18.0002 24.5615 18.1247 24.7738 18.3459C24.9862 18.5672 25.1055 18.8673 25.1055 19.1801V26.8533C25.1055 27.1662 24.9862 27.4662 24.7738 27.6875C24.5615 27.9088 24.2734 28.0324 23.973 28.0326Z", fill: "#34A853" }), jsx("path", { d: "M17.4466 20.0798L18.8568 24.5128H18.911L20.3241 20.0798H21.6916L19.6802 25.9145H18.0904L16.0762 20.0798H17.4466Z", fill: "#FCFCFC" }), jsx("path", { d: "M14.3006 21.7578C14.2778 21.528 14.18 21.3495 14.0071 21.2222C13.8343 21.095 13.5997 21.0313 13.3034 21.0313C13.1021 21.0313 12.9321 21.0598 12.7934 21.1168C12.6548 21.1719 12.5484 21.2488 12.4744 21.3476C12.4022 21.4463 12.3661 21.5584 12.3661 21.6838C12.3623 21.7882 12.3841 21.8794 12.4316 21.9573C12.481 22.0351 12.5484 22.1026 12.6339 22.1595C12.7194 22.2146 12.8181 22.2631 12.9302 22.3048C13.0423 22.3447 13.1619 22.3789 13.2892 22.4074L13.8134 22.5328C14.0679 22.5897 14.3015 22.6657 14.5142 22.7607C14.727 22.8556 14.9112 22.9725 15.067 23.1111C15.2227 23.2498 15.3433 23.4131 15.4288 23.6011C15.5161 23.7892 15.5608 24.0047 15.5627 24.2479C15.5608 24.6049 15.4696 24.9145 15.2892 25.1766C15.1106 25.4368 14.8523 25.6391 14.5142 25.7835C14.1781 25.9259 13.7726 25.9971 13.2977 25.9971C12.8267 25.9971 12.4164 25.925 12.067 25.7806C11.7194 25.6363 11.4478 25.4226 11.2521 25.1396C11.0584 24.8547 10.9568 24.5024 10.9473 24.0826H12.141C12.1543 24.2782 12.2104 24.4416 12.3091 24.5726C12.4098 24.7018 12.5437 24.7996 12.7108 24.8661C12.8799 24.9307 13.0708 24.963 13.2835 24.963C13.4924 24.963 13.6738 24.9326 13.8276 24.8718C13.9834 24.811 14.104 24.7265 14.1895 24.6182C14.2749 24.51 14.3177 24.3856 14.3177 24.245C14.3177 24.114 14.2787 24.0038 14.2009 23.9145C14.1249 23.8253 14.0128 23.7493 13.8647 23.6866C13.7184 23.6239 13.5389 23.5669 13.3262 23.5157L12.6909 23.3561C12.199 23.2365 11.8105 23.0494 11.5256 22.7949C11.2407 22.5404 11.0992 22.1975 11.1011 21.7664C11.0992 21.4131 11.1933 21.1045 11.3832 20.8405C11.575 20.5764 11.8381 20.3704 12.1724 20.2222C12.5066 20.0741 12.8865 20 13.312 20C13.745 20 14.123 20.0741 14.4459 20.2222C14.7707 20.3704 15.0233 20.5764 15.2037 20.8405C15.3841 21.1045 15.4772 21.4103 15.4829 21.7578H14.3006Z", fill: "#FCFCFC" }), jsx("path", { d: "M10.2507 22.1225H9.00285C8.98005 21.9611 8.93352 21.8177 8.86324 21.6923C8.79297 21.5651 8.70275 21.4568 8.59259 21.3675C8.48243 21.2783 8.35517 21.2099 8.21082 21.1624C8.06837 21.1149 7.91358 21.0912 7.74644 21.0912C7.44444 21.0912 7.18138 21.1662 6.95726 21.3162C6.73314 21.4644 6.55935 21.6809 6.4359 21.9658C6.31244 22.2488 6.25071 22.5926 6.25071 22.9971C6.25071 23.4131 6.31244 23.7626 6.4359 24.0456C6.56125 24.3286 6.73599 24.5423 6.96011 24.6866C7.18423 24.831 7.44349 24.9031 7.73789 24.9031C7.90313 24.9031 8.05603 24.8813 8.19658 24.8376C8.33903 24.7939 8.46533 24.7303 8.5755 24.6467C8.68566 24.5612 8.77683 24.4577 8.849 24.3362C8.92307 24.2146 8.97436 24.076 9.00285 23.9202L10.2507 23.9259C10.2184 24.1937 10.1377 24.452 10.0085 24.7009C9.88129 24.9478 9.7094 25.169 9.49287 25.3647C9.27825 25.5584 9.02184 25.7122 8.72364 25.8262C8.42735 25.9383 8.09212 25.9943 7.71795 25.9943C7.19753 25.9943 6.73219 25.8765 6.32194 25.641C5.91358 25.4055 5.59069 25.0646 5.35328 24.6182C5.11776 24.1719 5 23.6315 5 22.9971C5 22.3609 5.11966 21.8196 5.35897 21.3732C5.59829 20.9269 5.92308 20.5869 6.33333 20.3533C6.74359 20.1178 7.20513 20 7.71795 20C8.05603 20 8.36942 20.0475 8.65812 20.1425C8.94871 20.2374 9.20607 20.3761 9.4302 20.5584C9.65432 20.7388 9.83665 20.9601 9.9772 21.2222C10.1197 21.4843 10.2108 21.7844 10.2507 22.1225Z", fill: "#FCFCFC" })] }), jsx("path", { d: "M30.8819 5.43478L27.9937 9.19732L25.1055 5.43478L27.031 5.43478L27.031 2.0903C27.031 1.39799 27.462 0.836119 27.9937 0.836119C28.5254 0.836119 28.9564 1.39799 28.9564 2.0903L28.9564 5.43478L30.8819 5.43478Z", fill: "#343839" })] });
}
function ExportJson(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("mask", { id: "mask0_4379_5175", maskUnits: "userSpaceOnUse", x: "2", y: "0", width: "30", height: "32", children: jsx("path", { d: "M32 0H2V32H32V0Z", fill: "white" }) }), jsxs("g", { mask: "url(#mask0_4379_5175)", children: [jsx("path", { d: "M20.5149 2.99247C20.2102 2.65617 19.8406 2.3869 19.4289 2.20135C19.0173 2.01581 18.5724 1.91796 18.1219 1.91388H8.95228C8.31271 1.93183 7.70624 2.20591 7.26573 2.67607C6.82522 3.14624 6.58659 3.77415 6.60212 4.42224V29.4916C6.58659 30.1397 6.82522 30.7676 7.26573 31.2378C7.70624 31.708 8.31271 31.982 8.95228 32H25.8201C26.4597 31.982 27.0662 31.708 27.5067 31.2378C27.9472 30.7676 28.1858 30.1397 28.1703 29.4916V12.837C28.1765 11.8989 27.8315 10.9932 27.2048 10.3027L20.5149 2.99247ZM19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.92 10.2104 20.7598 10.1431C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811ZM26.6857 29.4916C26.7007 29.7406 26.6183 29.9856 26.4562 30.1734C26.2942 30.3612 26.0657 30.4767 25.8201 30.495H8.95228C8.70689 30.4765 8.47855 30.3609 8.31669 30.1731C8.15483 29.9853 8.07248 29.7405 8.08748 29.4916V4.42224C8.07249 4.17325 8.15495 3.9283 8.31698 3.74049C8.47902 3.55268 8.70757 3.43713 8.95311 3.4189H18.1186C18.2337 3.41924 18.3484 3.43156 18.461 3.45569V8.91137C18.461 9.66533 18.7566 10.3884 19.2828 10.9215C19.8089 11.4547 20.5226 11.7542 21.2667 11.7542H26.014C26.1371 11.7532 26.258 11.721 26.3656 11.6605C26.5768 12.0165 26.6884 12.4241 26.6882 12.8395L26.6857 29.4916Z", fill: "#343839" }), jsx("path", { d: "M19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1432C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811Z", fill: "#343839" }), jsx("path", { d: "M23.973 28.0326H3.13249C2.83206 28.0324 2.54401 27.9079 2.33165 27.6866C2.11929 27.4653 2 27.1653 2 26.8525V19.1801C2 18.8673 2.11929 18.5672 2.33165 18.3459C2.54401 18.1247 2.83206 18.0002 3.13249 18H23.973C24.2734 18.0002 24.5615 18.1247 24.7738 18.3459C24.9862 18.5672 25.1055 18.8673 25.1055 19.1801V26.8533C25.1055 27.1662 24.9862 27.4662 24.7738 27.6875C24.5615 27.9088 24.2734 28.0324 23.973 28.0326Z", fill: "#EA4335" }), jsx("path", { d: "M23.7256 20.0798V25.9173H22.6892L20.2201 22.2432H20.1785V25.9173H18.9786V20.0798H20.0316L22.4814 23.7511H22.5312V20.0798H23.7256Z", fill: "#FCFCFC" }), jsx("path", { d: "M18.0897 22.9986C18.0897 23.6352 17.9724 24.1767 17.7378 24.6233C17.505 25.0698 17.1873 25.4109 16.7845 25.6466C16.3836 25.8803 15.9328 25.9971 15.4322 25.9971C14.9278 25.9971 14.4752 25.8793 14.0743 25.6437C13.6734 25.4081 13.3566 25.067 13.1238 24.6204C12.891 24.1739 12.7746 23.6333 12.7746 22.9986C12.7746 22.362 12.891 21.8204 13.1238 21.3739C13.3566 20.9273 13.6734 20.5872 14.0743 20.3534C14.4752 20.1178 14.9278 20 15.4322 20C15.9328 20 16.3836 20.1178 16.7845 20.3534C17.1873 20.5872 17.505 20.9273 17.7378 21.3739C17.9724 21.8204 18.0897 22.362 18.0897 22.9986ZM16.8732 22.9986C16.8732 22.5862 16.8132 22.2385 16.6931 21.9553C16.5748 21.6722 16.4076 21.4575 16.1915 21.3112C15.9753 21.1648 15.7222 21.0917 15.4322 21.0917C15.1421 21.0917 14.889 21.1648 14.6729 21.3112C14.4567 21.4575 14.2886 21.6722 14.1685 21.9553C14.0503 22.2385 13.9912 22.5862 13.9912 22.9986C13.9912 23.4109 14.0503 23.7587 14.1685 24.0418C14.2886 24.3249 14.4567 24.5397 14.6729 24.686C14.889 24.8323 15.1421 24.9055 15.4322 24.9055C15.7222 24.9055 15.9753 24.8323 16.1915 24.686C16.4076 24.5397 16.5748 24.3249 16.6931 24.0418C16.8132 23.7587 16.8732 23.4109 16.8732 22.9986Z", fill: "#FCFCFC" }), jsx("path", { d: "M10.8397 21.7587C10.8175 21.5287 10.7224 21.3501 10.5542 21.2228C10.3861 21.0955 10.158 21.0318 9.86976 21.0318C9.67393 21.0318 9.50859 21.0603 9.37372 21.1173C9.23886 21.1724 9.1354 21.2494 9.06335 21.3482C8.99315 21.447 8.95805 21.5591 8.95805 21.6846C8.95435 21.7891 8.9756 21.8803 9.02178 21.9582C9.06982 22.0361 9.1354 22.1036 9.21854 22.1606C9.30167 22.2157 9.39774 22.2641 9.50674 22.3059C9.61574 22.3458 9.73213 22.38 9.85591 22.4086L10.3658 22.534C10.6134 22.591 10.8406 22.667 11.0475 22.762C11.2544 22.857 11.4336 22.9739 11.5851 23.1126C11.7366 23.2513 11.8539 23.4147 11.9371 23.6029C12.022 23.791 12.0655 24.0067 12.0673 24.2499C12.0655 24.6071 11.9768 24.9169 11.8013 25.1791C11.6276 25.4394 11.3764 25.6418 11.0475 25.7862C10.7205 25.9287 10.3261 26 9.86422 26C9.40605 26 9.007 25.9278 8.66707 25.7834C8.32899 25.639 8.06481 25.4252 7.87452 25.142C7.68608 24.857 7.58724 24.5045 7.578 24.0846H8.73912C8.75206 24.2803 8.80656 24.4437 8.90262 24.5748C9.00054 24.704 9.13078 24.8019 9.29336 24.8684C9.45778 24.933 9.64345 24.9653 9.85036 24.9653C10.0536 24.9653 10.23 24.9349 10.3797 24.8741C10.5311 24.8133 10.6485 24.7287 10.7316 24.6204C10.8147 24.5121 10.8563 24.3876 10.8563 24.247C10.8563 24.1159 10.8184 24.0057 10.7427 23.9164C10.6688 23.8271 10.5598 23.7511 10.4157 23.6884C10.2734 23.6257 10.0988 23.5686 9.89193 23.5173L9.27396 23.3577C8.79547 23.238 8.41767 23.0508 8.14055 22.7962C7.86343 22.5416 7.7258 22.1986 7.72765 21.7672C7.7258 21.4138 7.81725 21.105 8.00199 20.8409C8.18858 20.5767 8.44446 20.3705 8.76961 20.2223C9.09476 20.0741 9.46425 20 9.87808 20C10.2993 20 10.6669 20.0741 10.981 20.2223C11.2969 20.3705 11.5426 20.5767 11.7181 20.8409C11.8936 21.105 11.9842 21.4109 11.9897 21.7587H10.8397Z", fill: "#FCFCFC" }), jsx("path", { d: "M5.58276 20.0798H6.76883V24.1501C6.76883 24.5264 6.68661 24.8532 6.52219 25.1306C6.35962 25.4081 6.1333 25.6219 5.84325 25.772C5.5532 25.9221 5.21605 25.9972 4.83178 25.9972C4.49 25.9972 4.17963 25.9354 3.90066 25.8119C3.62354 25.6865 3.4037 25.4964 3.24112 25.2418C3.07855 24.9853 2.99818 24.6632 3.00003 24.2755H4.19441C4.1981 24.4295 4.22858 24.5615 4.28586 24.6717C4.34497 24.78 4.42534 24.8637 4.52695 24.9226C4.6304 24.9796 4.75234 25.0081 4.89274 25.0081C5.04054 25.0081 5.16524 24.9758 5.26685 24.9112C5.37031 24.8447 5.44882 24.7477 5.5024 24.6204C5.55598 24.4931 5.58276 24.3363 5.58276 24.1501V20.0798Z", fill: "#FCFCFC" })] }), jsx("path", { d: "M30.8819 5.43478L27.9937 9.19732L25.1055 5.43478L27.031 5.43478L27.031 2.0903C27.031 1.39799 27.462 0.836119 27.9937 0.836119C28.5254 0.836119 28.9564 1.39799 28.9564 2.0903L28.9564 5.43478L30.8819 5.43478Z", fill: "#343839" })] });
}
function ExportPdf(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("mask", { id: "mask0_4379_5235", maskUnits: "userSpaceOnUse", x: "2", y: "0", width: "30", height: "32", children: jsx("path", { d: "M32 0H2V32H32V0Z", fill: "white" }) }), jsxs("g", { mask: "url(#mask0_4379_5235)", children: [jsx("path", { d: "M20.5149 2.99247C20.2102 2.65617 19.8406 2.3869 19.4289 2.20135C19.0173 2.01581 18.5724 1.91796 18.1219 1.91388H8.95228C8.31271 1.93183 7.70624 2.20591 7.26573 2.67607C6.82522 3.14624 6.58659 3.77415 6.60212 4.42224V29.4916C6.58659 30.1397 6.82522 30.7676 7.26573 31.2378C7.70624 31.708 8.31271 31.982 8.95228 32H25.8201C26.4597 31.982 27.0662 31.708 27.5067 31.2378C27.9472 30.7676 28.1858 30.1397 28.1703 29.4916V12.837C28.1765 11.8989 27.8315 10.9932 27.2048 10.3027L20.5149 2.99247ZM19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.92 10.2104 20.7598 10.1431C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811ZM26.6857 29.4916C26.7007 29.7406 26.6183 29.9856 26.4562 30.1734C26.2942 30.3612 26.0657 30.4767 25.8201 30.495H8.95228C8.70689 30.4765 8.47855 30.3609 8.31669 30.1731C8.15483 29.9853 8.07248 29.7405 8.08748 29.4916V4.42224C8.07249 4.17325 8.15495 3.9283 8.31698 3.74049C8.47902 3.55268 8.70757 3.43713 8.95311 3.4189H18.1186C18.2337 3.41924 18.3484 3.43156 18.461 3.45569V8.91137C18.461 9.66533 18.7566 10.3884 19.2828 10.9215C19.8089 11.4547 20.5226 11.7542 21.2667 11.7542H26.014C26.1371 11.7532 26.258 11.721 26.3656 11.6605C26.5768 12.0165 26.6884 12.4241 26.6882 12.8395L26.6857 29.4916Z", fill: "#343839" }), jsx("path", { d: "M19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1432C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811Z", fill: "#343839" }), jsx("path", { d: "M23.973 28.0326H3.13249C2.83206 28.0324 2.54401 27.9079 2.33165 27.6866C2.11929 27.4653 2 27.1653 2 26.8525V19.1801C2 18.8673 2.11929 18.5672 2.33165 18.3459C2.54401 18.1247 2.83206 18.0002 3.13249 18H23.973C24.2734 18.0002 24.5615 18.1247 24.7738 18.3459C24.9862 18.5672 25.1055 18.8673 25.1055 19.1801V26.8533C25.1055 27.1662 24.9862 27.4662 24.7738 27.6875C24.5615 27.9088 24.2734 28.0324 23.973 28.0326Z", fill: "#EA4335" })] }), jsx("path", { d: "M30.8819 5.43478L27.9937 9.19732L25.1055 5.43478L27.031 5.43478L27.031 2.0903C27.031 1.39799 27.462 0.836119 27.9937 0.836119C28.5254 0.836119 28.9564 1.39799 28.9564 2.0903L28.9564 5.43478L30.8819 5.43478Z", fill: "#343839" }), jsx("path", { d: "M17.3438 26V20H21.3164V21.0459H18.6123V22.4756H21.0527V23.5215H18.6123V26H17.3438Z", fill: "#FCFCFC" }), jsx("path", { d: "M13.4685 26H11.3416V20H13.4861C14.0896 20 14.6091 20.1201 15.0447 20.3604C15.4802 20.5986 15.8152 20.9414 16.0496 21.3887C16.2859 21.8359 16.4041 22.3711 16.4041 22.9941C16.4041 23.6191 16.2859 24.1563 16.0496 24.6055C15.8152 25.0547 15.4783 25.3994 15.0388 25.6396C14.6013 25.8799 14.0779 26 13.4685 26ZM12.6101 24.9131H13.4158C13.7908 24.9131 14.1062 24.8467 14.3621 24.7139C14.6199 24.5791 14.8132 24.3711 14.9421 24.0898C15.073 23.8066 15.1384 23.4414 15.1384 22.9941C15.1384 22.5508 15.073 22.1885 14.9421 21.9072C14.8132 21.626 14.6209 21.4189 14.365 21.2861C14.1091 21.1533 13.7937 21.0869 13.4187 21.0869H12.6101V24.9131Z", fill: "#FCFCFC" }), jsx("path", { d: "M6 26V20H8.36719C8.82227 20 9.20996 20.0869 9.53027 20.2607C9.85059 20.4326 10.0947 20.6719 10.2627 20.9785C10.4326 21.2832 10.5176 21.6348 10.5176 22.0332C10.5176 22.4316 10.4316 22.7832 10.2598 23.0879C10.0879 23.3926 9.83887 23.6299 9.5127 23.7998C9.18848 23.9697 8.7959 24.0547 8.33496 24.0547H6.82617V23.0381H8.12988C8.37402 23.0381 8.5752 22.9961 8.7334 22.9121C8.89355 22.8262 9.0127 22.708 9.09082 22.5576C9.1709 22.4053 9.21094 22.2305 9.21094 22.0332C9.21094 21.834 9.1709 21.6602 9.09082 21.5117C9.0127 21.3613 8.89355 21.2451 8.7334 21.1631C8.57324 21.0791 8.37012 21.0371 8.12402 21.0371H7.26855V26H6Z", fill: "#FCFCFC" })] });
}
function ExportUbl(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("mask", { id: "mask0_4381_5338", maskUnits: "userSpaceOnUse", x: "2", y: "0", width: "30", height: "32", children: jsx("path", { d: "M32 0H2V32H32V0Z", fill: "white" }) }), jsxs("g", { mask: "url(#mask0_4381_5338)", children: [jsx("path", { d: "M20.5149 2.99247C20.2102 2.65617 19.8406 2.3869 19.4289 2.20135C19.0173 2.01581 18.5724 1.91796 18.1219 1.91388H8.95227C8.3127 1.93183 7.70623 2.20591 7.26572 2.67607C6.82521 3.14624 6.58658 3.77415 6.60212 4.42224V29.4916C6.58658 30.1397 6.82521 30.7676 7.26572 31.2378C7.70623 31.708 8.3127 31.982 8.95227 32H25.8201C26.4597 31.982 27.0661 31.708 27.5067 31.2378C27.9472 30.7676 28.1858 30.1397 28.1703 29.4916V12.837C28.1765 11.8989 27.8315 10.9932 27.2048 10.3027L20.5149 2.99247ZM19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1431C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811ZM26.6857 29.4916C26.7007 29.7406 26.6183 29.9856 26.4562 30.1734C26.2942 30.3612 26.0656 30.4767 25.8201 30.495H8.95227C8.70688 30.4765 8.47854 30.3609 8.31668 30.1731C8.15482 29.9853 8.07247 29.7405 8.08747 29.4916V4.42224C8.07248 4.17325 8.15494 3.9283 8.31697 3.74049C8.47901 3.55268 8.70756 3.43713 8.9531 3.4189H18.1186C18.2336 3.41924 18.3484 3.43156 18.461 3.45569V8.91137C18.461 9.66533 18.7566 10.3884 19.2828 10.9215C19.8089 11.4547 20.5226 11.7542 21.2667 11.7542H26.014C26.1371 11.7532 26.2579 11.721 26.3656 11.6605C26.5768 12.0165 26.6884 12.4241 26.6882 12.8395L26.6857 29.4916Z", fill: "#343839" }), jsx("path", { d: "M19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1432C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811Z", fill: "#343839" })] }), jsx("path", { d: "M30.8819 5.43478L27.9937 9.19732L25.1055 5.43478L27.0309 5.43478L27.0309 2.0903C27.0309 1.39799 27.462 0.836119 27.9937 0.836119C28.5254 0.836119 28.9564 1.39799 28.9564 2.0903L28.9564 5.43478L30.8819 5.43478Z", fill: "#343839" }), jsx("path", { d: "M23.973 28.0326H3.13249C2.83206 28.0324 2.54401 27.9079 2.33165 27.6866C2.11929 27.4653 2 27.1653 2 26.8525V19.1801C2 18.8673 2.11929 18.5672 2.33165 18.3459C2.54401 18.1247 2.83206 18.0002 3.13249 18H23.973C24.2734 18.0002 24.5615 18.1247 24.7738 18.3459C24.9862 18.5672 25.1055 18.8673 25.1055 19.1801V26.8533C25.1055 27.1662 24.9862 27.4662 24.7738 27.6875C24.5615 27.9088 24.2734 28.0324 23.973 28.0326Z", fill: "#1990FF" }), jsx("path", { d: "M17.6553 25.9162V20H18.944V24.8849H21.5572V25.9162H17.6553Z", fill: "#FCFCFC" }), jsx("path", { d: "M12.1141 25.9162V20H14.5547C15.0031 20 15.3771 20.0645 15.6768 20.1935C15.9764 20.3226 16.2016 20.5017 16.3524 20.7309C16.5032 20.9581 16.5786 21.22 16.5786 21.5166C16.5786 21.7477 16.531 21.9509 16.4357 22.1261C16.3405 22.2995 16.2095 22.442 16.0428 22.5537C15.8782 22.6635 15.6897 22.7415 15.4773 22.7877V22.8455C15.7095 22.8551 15.9268 22.9186 16.1292 23.0361C16.3335 23.1536 16.4992 23.3182 16.6262 23.5301C16.7532 23.74 16.8167 23.9904 16.8167 24.2812C16.8167 24.5951 16.7363 24.8753 16.5756 25.1218C16.4169 25.3664 16.1817 25.5599 15.8702 25.7025C15.5587 25.845 15.1748 25.9162 14.7184 25.9162H12.1141ZM13.4029 24.8936H14.4535C14.8126 24.8936 15.0746 24.8272 15.2392 24.6943C15.4039 24.5595 15.4863 24.3804 15.4863 24.157C15.4863 23.9933 15.4456 23.8488 15.3642 23.7236C15.2829 23.5985 15.1668 23.5002 15.016 23.429C14.8672 23.3577 14.6896 23.3221 14.4833 23.3221H13.4029V24.8936ZM13.4029 22.4757H14.3583C14.5348 22.4757 14.6916 22.4458 14.8285 22.3861C14.9674 22.3245 15.0765 22.2378 15.1559 22.1261C15.2373 22.0144 15.2779 21.8806 15.2779 21.7246C15.2779 21.5108 15.1996 21.3385 15.0428 21.2075C14.888 21.0766 14.6678 21.0111 14.3821 21.0111H13.4029V22.4757Z", fill: "#FCFCFC" }), jsx("path", { d: "M9.76505 20H11.0538V23.8421C11.0538 24.2735 10.9476 24.6509 10.7353 24.9745C10.525 25.298 10.2303 25.5503 9.85136 25.7313C9.47237 25.9104 9.03089 26 8.5269 26C8.02092 26 7.57844 25.9104 7.19946 25.7313C6.82047 25.5503 6.52582 25.298 6.31549 24.9745C6.10516 24.6509 6 24.2735 6 23.8421V20H7.28875V23.7352C7.28875 23.9605 7.33934 24.1608 7.44054 24.3361C7.54372 24.5113 7.68857 24.649 7.87508 24.7492C8.0616 24.8493 8.27887 24.8994 8.5269 24.8994C8.77691 24.8994 8.99418 24.8493 9.17871 24.7492C9.36523 24.649 9.50908 24.5113 9.61028 24.3361C9.71346 24.1608 9.76505 23.9605 9.76505 23.7352V20Z", fill: "#FCFCFC" })] });
}
function ExportZip(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("mask", { id: "mask0_4381_5398", maskUnits: "userSpaceOnUse", x: "2", y: "0", width: "30", height: "32", children: jsx("path", { d: "M32 0H2V32H32V0Z", fill: "white" }) }), jsxs("g", { mask: "url(#mask0_4381_5398)", children: [jsx("path", { d: "M20.5149 2.99247C20.2102 2.65617 19.8406 2.3869 19.4289 2.20135C19.0173 2.01581 18.5724 1.91796 18.1219 1.91388H8.95227C8.3127 1.93183 7.70623 2.20591 7.26572 2.67607C6.82521 3.14624 6.58658 3.77415 6.60212 4.42224V29.4916C6.58658 30.1397 6.82521 30.7676 7.26572 31.2378C7.70623 31.708 8.3127 31.982 8.95227 32H25.8201C26.4597 31.982 27.0661 31.708 27.5067 31.2378C27.9472 30.7676 28.1858 30.1397 28.1703 29.4916V12.837C28.1765 11.8989 27.8315 10.9932 27.2048 10.3027L20.5149 2.99247ZM19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1431C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811ZM26.6857 29.4916C26.7007 29.7406 26.6183 29.9856 26.4562 30.1734C26.2942 30.3612 26.0656 30.4767 25.8201 30.495H8.95227C8.70688 30.4765 8.47854 30.3609 8.31668 30.1731C8.15482 29.9853 8.07247 29.7405 8.08747 29.4916V4.42224C8.07248 4.17325 8.15494 3.9283 8.31697 3.74049C8.47901 3.55268 8.70756 3.43713 8.9531 3.4189H18.1186C18.2336 3.41924 18.3484 3.43156 18.461 3.45569V8.91137C18.461 9.66533 18.7566 10.3884 19.2828 10.9215C19.8089 11.4547 20.5226 11.7542 21.2667 11.7542H26.014C26.1371 11.7532 26.2579 11.721 26.3656 11.6605C26.5768 12.0165 26.6884 12.4241 26.6882 12.8395L26.6857 29.4916Z", fill: "#343839" }), jsx("path", { d: "M19.9455 4.5811L25.1302 10.245H21.265C21.0916 10.245 20.9199 10.2104 20.7598 10.1432C20.5996 10.0759 20.454 9.97738 20.3314 9.85315C20.2088 9.72893 20.1116 9.58145 20.0452 9.41914C19.9789 9.25683 19.9447 9.08287 19.9447 8.90719L19.9455 4.5811Z", fill: "#343839" })] }), jsx("path", { d: "M30.8819 5.43478L27.9937 9.19732L25.1055 5.43478L27.0309 5.43478L27.0309 2.0903C27.0309 1.39799 27.462 0.836119 27.9937 0.836119C28.5254 0.836119 28.9564 1.39799 28.9564 2.0903L28.9564 5.43478L30.8819 5.43478Z", fill: "#343839" }), jsx("path", { d: "M23.973 28.0326H3.13249C2.83206 28.0324 2.54401 27.9079 2.33165 27.6866C2.11929 27.4653 2 27.1653 2 26.8525V19.1801C2 18.8673 2.11929 18.5672 2.33165 18.3459C2.54401 18.1247 2.83206 18.0002 3.13249 18H23.973C24.2734 18.0002 24.5615 18.1247 24.7738 18.3459C24.9862 18.5672 25.1055 18.8673 25.1055 19.1801V26.8533C25.1055 27.1662 24.9862 27.4662 24.7738 27.6875C24.5615 27.9088 24.2734 28.0324 23.973 28.0326Z", fill: "#343839" }), jsx("path", { d: "M15.8853 26V20H18.2524C18.7075 20 19.0952 20.0869 19.4155 20.2607C19.7358 20.4326 19.98 20.6719 20.148 20.9785C20.3179 21.2832 20.4028 21.6348 20.4028 22.0332C20.4028 22.4316 20.3169 22.7832 20.145 23.0879C19.9731 23.3926 19.7241 23.6299 19.398 23.7998C19.0737 23.9697 18.6812 24.0547 18.2202 24.0547H16.7114V23.0381H18.0151C18.2593 23.0381 18.4605 22.9961 18.6187 22.9121C18.7788 22.8262 18.898 22.708 18.9761 22.5576C19.0562 22.4053 19.0962 22.2305 19.0962 22.0332C19.0962 21.834 19.0562 21.6602 18.9761 21.5117C18.898 21.3613 18.7788 21.2451 18.6187 21.1631C18.4585 21.0791 18.2554 21.0371 18.0093 21.0371H17.1538V26H15.8853Z", fill: "#FCFCFC" }), jsx("path", { d: "M14.8416 20V26H13.573V20H14.8416Z", fill: "#FCFCFC" }), jsx("path", { d: "M8.00586 26V25.2471L11 21.0459H8V20H12.5938V20.7529L9.59668 24.9541H12.5996V26H8.00586Z", fill: "#FCFCFC" })] });
}
function File(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.7333 2.13332C3.43875 2.13332 3.19997 2.3721 3.19997 2.66665V13.3333C3.19997 13.6279 3.43875 13.8667 3.7333 13.8667H12.2666C12.5612 13.8667 12.8 13.6279 12.8 13.3333V6.39998H9.06663C8.77208 6.39998 8.5333 6.1612 8.5333 5.86665V2.13332H3.7333ZM9.59997 2.88756L12.0457 5.33332H9.59997V2.88756ZM2.1333 2.66665C2.1333 1.78299 2.84965 1.06665 3.7333 1.06665H9.06663C9.20808 1.06665 9.34374 1.12284 9.44376 1.22286L13.7104 5.48953C13.8104 5.58955 13.8666 5.7252 13.8666 5.86665V13.3333C13.8666 14.217 13.1503 14.9333 12.2666 14.9333H3.7333C2.84964 14.9333 2.1333 14.217 2.1333 13.3333V2.66665Z", fill: "currentcolor" }) });
}
function FilesEarmark(props) {
  return jsx("svg", { ...props, viewBox: "0 0 20 20", fill: "currentcolor", children: jsx("path", { d: "M8.33139 1.67773C5.36388 1.67773 2.49805 4.5159 2.49805 7.48507C2.49805 7.49365 2.49805 7.5024 2.49805 7.51107C2.49805 9.56107 2.49805 12.008 2.49805 12.2246C2.49805 13.7777 3.84056 15.0111 5.46639 15.0111H5.83139V15.5579C5.83139 17.1111 7.1739 18.3444 8.79973 18.3444H14.5297C16.1556 18.3444 17.4981 17.1111 17.4981 15.5579V7.79757C17.4981 6.2444 16.1556 5.01107 14.5297 5.01107H14.1647V4.46423C14.1647 2.91107 12.8222 1.67773 11.1964 1.67773C11.0181 1.67773 11.0097 1.67773 8.33139 1.67773ZM7.49805 3.55273V5.5579C7.49805 6.15257 6.93638 6.67773 6.19638 6.67773H4.34721C4.72971 5.20507 6.02139 3.94473 7.49805 3.55273ZM14.1647 6.67773H14.5297C15.2697 6.67773 15.8314 7.2029 15.8314 7.79757V15.5579C15.8314 16.1526 15.2697 16.6777 14.5297 16.6777H8.79973C8.05973 16.6777 7.49805 16.1526 7.49805 15.5579V15.0111H11.1964C12.8222 15.0111 14.1647 13.7777 14.1647 12.2246V6.67773Z" }) });
}
function FolderClose(props) {
  return jsx("svg", { ...props, viewBox: "0 0 18 19", fill: "currentcolor", children: jsx("path", { d: "M2.99829 0.682129C1.24429 0.683129 0.008291 1.90913 -0.00170898 3.68213V5.68213C-0.000708986 5.72213 -0.00170898 14.6821 -0.00170898 14.6821C-0.00170898 16.8911 1.78929 18.6821 3.99828 18.6821H13.9983C16.2073 18.6821 17.9983 16.8911 17.9983 14.6821V8.68213C17.9973 8.59713 17.9983 6.84013 17.9983 6.71313C18.0053 4.97213 16.7203 3.68913 14.9983 3.68213C14.7263 3.68113 14.0513 3.68113 14.0613 3.68213C13.1383 3.67913 12.9253 3.49513 12.3423 2.62013C11.4253 1.24513 10.6533 0.682129 8.99828 0.682129H2.99829ZM2.99829 2.68213H8.99828C9.84328 2.68213 10.0713 2.86913 10.6543 3.74413C11.5713 5.11913 12.3433 5.68213 13.9983 5.68213C13.9723 5.68313 14.7223 5.68113 14.9983 5.68213C15.6223 5.68513 16.0013 6.08313 15.9983 6.71313C15.9983 6.77713 15.9973 7.21813 15.9983 7.68213C15.3583 7.68213 15.1983 7.68213 11.9983 7.68213C11.1533 7.68213 10.9253 7.49513 10.3423 6.62013C9.42527 5.24513 8.65328 4.68213 6.99828 4.68213C6.11328 4.68213 3.43429 4.68213 1.99829 4.68213V3.68213C2.00229 3.01813 2.34029 2.68213 2.99829 2.68213Z", fill: "#6C7275" }) });
}
function FolderOpen(props) {
  return jsx("svg", { ...props, viewBox: "0 0 20 19", fill: "currentcolor", children: jsx("path", { d: "M2.99829 0.68213C1.38729 0.68213 0.0122901 1.96913 -0.00170994 3.68213V14.6821C-0.00170994 15.7961 0.45129 16.8001 1.18629 17.5261C1.54429 17.8791 1.96529 18.1711 2.43629 18.3701C2.91929 18.5731 3.45429 18.6821 3.99829 18.6821H5.99829H12.9983C14.0523 18.6821 15.0383 18.2771 15.7793 17.5571C16.1773 17.1711 16.6333 16.0351 17.4363 13.6821C17.5003 13.4921 18.9473 9.0291 18.9673 8.9631C19.1653 8.3201 18.6713 7.6821 17.9983 7.6821C17.8733 7.6821 17.2123 7.6821 16.9983 7.6821V6.68213C16.9983 5.02513 15.6553 3.68213 13.9983 3.68213H11.9983C11.1533 3.68213 10.9253 3.49513 10.3423 2.62013C9.4253 1.24513 8.6533 0.68213 6.99829 0.68213C6.12329 0.68213 3.87329 0.68213 2.99829 0.68213ZM2.99829 2.68213C3.87329 2.68213 6.12329 2.68213 6.99829 2.68213C7.8433 2.68213 8.0713 2.86913 8.6543 3.74413C9.5713 5.11913 10.3433 5.68213 11.9983 5.68213H13.9983C14.5503 5.68213 14.9983 6.13013 14.9983 6.68213V7.6821C11.5293 7.6821 6.24829 7.6821 4.99829 7.6821C4.58429 7.6821 4.20929 7.9511 4.06029 8.3381C4.06029 8.3381 2.90229 11.3631 1.99829 13.7131V3.68213C2.00329 3.10513 2.45829 2.68213 2.99829 2.68213Z" }) });
}
function FolderPlus(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M5.99804 2.99023C4.34104 2.99023 2.99805 4.33333 2.99805 5.99023V7.99023V16.9902C2.99805 19.1992 4.78904 20.9902 6.99804 20.9902H16.998C19.207 20.9902 20.998 19.1992 20.998 16.9902V7.99023C20.998 7.43793 20.55 6.99023 19.998 6.99023C19.998 6.99023 17.095 6.99023 14.998 6.99023C14.243 6.99023 14 6.74533 13.404 5.55273C12.501 3.74533 11.743 2.99023 9.99804 2.99023H5.99804ZM5.99804 4.99023H9.99804C10.753 4.99023 10.996 5.23513 11.592 6.42773C11.722 6.68883 11.776 6.77213 11.904 6.99023C8.45804 6.99023 5.98304 6.99023 4.99804 6.99023V5.99023C4.99804 5.43793 5.44604 4.99023 5.99804 4.99023ZM11.998 10.9902C12.55 10.9902 12.998 11.4382 12.998 11.9902V12.9902H13.998C14.55 12.9902 14.998 13.4382 14.998 13.9902C14.998 14.5422 14.55 14.9902 13.998 14.9902H12.998V15.9902C12.998 16.5422 12.55 16.9902 11.998 16.9902C11.446 16.9902 10.998 16.5422 10.998 15.9902V14.9902H9.99804C9.44604 14.9902 8.99804 14.5422 8.99804 13.9902C8.99804 13.4382 9.44604 12.9902 9.99804 12.9902H10.998V11.9902C10.998 11.4382 11.446 10.9902 11.998 10.9902Z" }) });
}
function Forum(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M12.5 4.99902H11.5V9.49902H5V10.499C5 10.6316 5.05268 10.7588 5.14645 10.8526C5.24021 10.9463 5.36739 10.999 5.5 10.999H11L13 12.999V5.49902C13 5.36642 12.9473 5.23924 12.8536 5.14547C12.7598 5.0517 12.6326 4.99902 12.5 4.99902ZM10.5 7.99902V3.49902C10.5 3.36642 10.4473 3.23924 10.3536 3.14547C10.2598 3.0517 10.1326 2.99902 10 2.99902H3.5C3.36739 2.99902 3.24021 3.0517 3.14645 3.14547C3.05268 3.23924 3 3.36642 3 3.49902V10.499L5 8.49902H10C10.1326 8.49902 10.2598 8.44634 10.3536 8.35258C10.4473 8.25881 10.5 8.13163 10.5 7.99902Z", fill: "currentcolor" }) });
}
function Gear(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M5.97803 1.63718C5.03269 1.93652 4.21736 2.42652 3.4987 3.09519C3.2767 3.30252 3.2087 3.64052 3.3527 3.90785C3.8867 4.89519 3.32802 5.95119 2.12402 6.01186C1.82869 6.02719 1.56803 6.24518 1.4987 6.53252C1.37936 7.02918 1.33203 7.44519 1.33203 7.99118C1.33203 8.44918 1.38136 8.96719 1.47803 9.42852C1.53803 9.71652 1.7887 9.92385 2.08203 9.94985C3.29403 10.0545 3.89404 10.9785 3.3527 12.1578C3.2327 12.4198 3.28736 12.7332 3.4987 12.9285C4.2067 13.5839 5.02003 14.0452 5.97803 14.3452C6.25136 14.4312 6.56003 14.3279 6.72803 14.0952C7.46936 13.0699 8.5447 13.0659 9.2487 14.0952C9.4147 14.3379 9.7187 14.4545 9.9987 14.3658C10.9234 14.0752 11.7847 13.5799 12.4987 12.9285C12.7187 12.7285 12.7767 12.4038 12.6447 12.1372C12.09 11.0178 12.728 9.98985 13.8734 9.97051C14.1774 9.96518 14.448 9.76518 14.5194 9.47051C14.6347 8.99251 14.6654 8.57585 14.6654 7.99118C14.6654 7.48852 14.606 6.99319 14.4987 6.51186C14.4307 6.20786 14.1647 5.99185 13.8527 5.99119C12.7254 5.98919 12.0934 4.88119 12.6447 3.90785C12.798 3.63652 12.75 3.30452 12.5194 3.09519C11.7927 2.43519 10.9067 1.91985 9.97803 1.63718C9.69269 1.55052 9.38936 1.65719 9.22803 1.90785C8.58403 2.90785 7.38136 2.92586 6.7487 1.92853C6.5867 1.67319 6.26603 1.54518 5.97803 1.63718ZM7.9987 5.32452C9.47136 5.32452 10.6654 6.51852 10.6654 7.99118C10.6654 9.46385 9.47136 10.6579 7.9987 10.6579C6.52603 10.6579 5.33203 9.46385 5.33203 7.99118C5.33203 6.51852 6.52603 5.32452 7.9987 5.32452Z" }) });
}
function Github(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 2.99902C5.23757 2.99902 3 5.29288 3 8.12481C3 10.3903 4.43339 12.3098 6.41928 12.9894C6.66789 13.0366 6.75997 12.8793 6.75997 12.7408C6.75997 12.6181 6.75691 12.2972 6.75384 11.8692C5.36341 12.1776 5.06875 11.1833 5.06875 11.1833C4.84162 10.5917 4.5132 10.4312 4.5132 10.4312C4.05893 10.1134 4.54696 10.1197 4.54696 10.1197C5.04727 10.1575 5.3143 10.6484 5.3143 10.6484C5.75936 11.4319 6.48373 11.2053 6.76918 11.0732C6.81522 10.7428 6.94414 10.5162 7.08533 10.3872C5.97729 10.2613 4.81093 9.82081 4.81093 7.85735C4.81093 7.29725 5.0043 6.841 5.32658 6.48229C5.2744 6.35013 5.10252 5.83095 5.37262 5.12611C5.37262 5.12611 5.79312 4.98766 6.7477 5.65159C7.14672 5.53831 7.57336 5.48168 8 5.47853C8.42357 5.48168 8.85328 5.53831 9.2523 5.65159C10.2069 4.98766 10.6274 5.12611 10.6274 5.12611C10.9006 5.83095 10.7287 6.35328 10.6765 6.48229C10.9957 6.841 11.1891 7.29725 11.1891 7.85735C11.1891 9.82711 10.0196 10.2582 8.90546 10.3872C9.08349 10.5445 9.24616 10.8592 9.24616 11.3375C9.24616 12.0234 9.24002 12.5741 9.24002 12.744C9.24002 12.8824 9.32904 13.0398 9.58379 12.9894C11.5697 12.3098 13 10.3903 13 8.12795C13 5.29288 10.7624 2.99902 8 2.99902Z", fill: "currentcolor" }) });
}
function GlobeWww(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M8.00456 2.5C5.4791 2.5 3.32848 4.12626 2.61283 6.36754H3.41185C3.49486 6.14602 3.59411 5.93256 3.70897 5.72798H5.24658C5.17952 5.93719 5.12439 6.15117 5.07872 6.36754H5.8576C5.91202 6.14949 5.97688 5.93537 6.054 5.72798H7.5379V6.36754H8.28992V5.72798H9.893C9.97926 5.93555 10.0517 6.14931 10.1129 6.36754H10.8918C10.8395 6.15094 10.7785 5.93737 10.7038 5.72798H12.3001C12.415 5.9326 12.5142 6.14597 12.5973 6.36754H13.3946C12.679 4.12626 10.53 2.5 8.00456 2.5ZM9.1393 3.38463C10.1919 3.62667 11.1112 4.19428 11.7764 4.97596H10.3815C10.0699 4.37324 9.65717 3.82927 9.1393 3.38463ZM6.64991 3.44002C6.18372 3.87275 5.81602 4.3967 5.54202 4.97596H4.2327C4.8512 4.24914 5.68921 3.70748 6.64991 3.44002ZM8.28992 3.68175C8.78573 4.02114 9.1858 4.46871 9.50356 4.97596H8.28992V3.68175ZM7.5379 3.68678V4.97596H6.40483C6.69593 4.46755 7.06755 4.0211 7.5379 3.68678ZM2.83776 7.09438C2.76293 7.09438 2.70042 7.11127 2.64976 7.14642C2.59909 7.18157 2.57422 7.22536 2.57422 7.27567C2.57422 7.31332 2.58506 7.36549 2.60947 7.43346L3.00898 8.58164C3.02115 8.61597 3.03516 8.65467 3.05095 8.69578C3.06673 8.73689 3.08879 8.77346 3.11473 8.8049C3.14067 8.83633 3.17598 8.86047 3.22049 8.87875C3.265 8.89703 3.32089 8.90561 3.38835 8.90561C3.47201 8.90561 3.53772 8.89044 3.58811 8.86029C3.63849 8.83014 3.67445 8.79771 3.69386 8.76125C3.71326 8.72479 3.73739 8.66864 3.76772 8.59171L4.12526 7.58454L4.48113 8.59674C4.51076 8.67174 4.53436 8.72709 4.55331 8.76293C4.57226 8.79877 4.607 8.83224 4.65739 8.86197C4.70777 8.8917 4.77481 8.90561 4.85882 8.90561C4.94714 8.90561 5.01636 8.89111 5.06529 8.86029C5.11421 8.82947 5.14846 8.79478 5.16769 8.75621C5.18691 8.71765 5.20946 8.65886 5.23651 8.58164L5.63602 7.43346C5.66078 7.36138 5.67295 7.30921 5.67295 7.27567C5.67295 7.22447 5.64702 7.18112 5.59574 7.14642C5.54444 7.11172 5.48292 7.09438 5.40941 7.09438C5.33569 7.09438 5.27881 7.10744 5.23987 7.13467C5.20092 7.1619 5.17417 7.1915 5.15929 7.22363C5.14441 7.25577 5.12906 7.29823 5.11397 7.34953L4.83196 8.32649L4.51638 7.41164C4.48689 7.33481 4.46294 7.27962 4.4442 7.24378C4.42546 7.20794 4.38925 7.17317 4.33845 7.14138C4.28764 7.1096 4.21678 7.09438 4.12526 7.09438C4.03527 7.09438 3.96497 7.10908 3.91208 7.1397C3.85919 7.17033 3.82141 7.20623 3.79961 7.24546C3.77781 7.28469 3.754 7.33927 3.72743 7.41164L3.41353 8.32649L3.12984 7.34282C3.10766 7.26822 3.07887 7.20887 3.04423 7.1632C3.0096 7.11754 2.94111 7.09438 2.83776 7.09438ZM6.70362 7.09438C6.62879 7.09438 6.56628 7.11127 6.51562 7.14642C6.46496 7.18157 6.44008 7.22536 6.44008 7.27567C6.44008 7.31332 6.4526 7.36549 6.47701 7.43346L6.87652 8.58164C6.88869 8.61597 6.9027 8.65467 6.91849 8.69578C6.93427 8.73689 6.95466 8.77346 6.9806 8.8049C7.00654 8.83633 7.04184 8.86047 7.08635 8.87875C7.13086 8.89703 7.18675 8.90561 7.25421 8.90561C7.33787 8.90561 7.40526 8.89044 7.45565 8.86029C7.50603 8.83014 7.54032 8.79771 7.55972 8.76125C7.57912 8.72479 7.60326 8.66864 7.63358 8.59171L7.99113 7.58454L8.34699 8.59674C8.37662 8.67174 8.40022 8.72709 8.41918 8.76293C8.43812 8.79877 8.47286 8.83224 8.52325 8.86197C8.57363 8.8917 8.64067 8.90561 8.72468 8.90561C8.813 8.90561 8.88223 8.89111 8.93115 8.86029C8.98008 8.82947 9.01432 8.79478 9.03355 8.75621C9.05278 8.71765 9.07532 8.65886 9.10237 8.58164L9.50188 7.43346C9.52664 7.36138 9.53881 7.30921 9.53881 7.27567C9.53881 7.22447 9.51288 7.18112 9.4616 7.14642C9.41031 7.11172 9.34878 7.09438 9.27527 7.09438C9.20155 7.09438 9.14467 7.10744 9.10573 7.13467C9.06678 7.1619 9.04004 7.1915 9.02516 7.22363C9.01027 7.25577 8.99492 7.29823 8.97983 7.34953L8.69783 8.32649L8.38225 7.41164C8.35276 7.33481 8.32881 7.27962 8.31006 7.24378C8.29132 7.20794 8.25679 7.17317 8.20599 7.14138C8.15519 7.1096 8.08432 7.09438 7.99281 7.09438C7.90281 7.09438 7.83083 7.10908 7.77794 7.1397C7.72505 7.17033 7.68728 7.20623 7.66547 7.24546C7.64367 7.28469 7.61986 7.33927 7.59329 7.41164L7.27939 8.32649L6.99571 7.34282C6.97352 7.26822 6.94641 7.20887 6.91177 7.1632C6.87714 7.11754 6.80697 7.09438 6.70362 7.09438ZM10.5695 7.09438C10.4947 7.09438 10.4321 7.11127 10.3815 7.14642C10.3308 7.18157 10.3059 7.22536 10.3059 7.27567C10.3059 7.31332 10.3185 7.36549 10.3429 7.43346L10.7424 8.58164C10.7546 8.61597 10.7686 8.65467 10.7844 8.69578C10.8001 8.73689 10.8205 8.77346 10.8465 8.8049C10.8724 8.83633 10.9077 8.86047 10.9522 8.87875C10.9967 8.89703 11.0526 8.90561 11.1201 8.90561C11.2037 8.90561 11.2711 8.89044 11.3215 8.86029C11.3719 8.83014 11.4062 8.79771 11.4256 8.76125C11.445 8.72479 11.4708 8.66864 11.5011 8.59171L11.857 7.58454L12.2129 8.59674C12.2425 8.67174 12.2661 8.72709 12.285 8.76293C12.304 8.79877 12.3387 8.83224 12.3891 8.86197C12.4395 8.8917 12.5065 8.90561 12.5905 8.90561C12.6789 8.90561 12.7481 8.89111 12.797 8.86029C12.8459 8.82947 12.8802 8.79478 12.8994 8.75621C12.9186 8.71765 12.9412 8.65886 12.9682 8.58164L13.3677 7.43346C13.3925 7.36138 13.4047 7.30921 13.4047 7.27567C13.4047 7.22447 13.3804 7.18112 13.3291 7.14642C13.2778 7.11172 13.2146 7.09438 13.1411 7.09438C13.0674 7.09438 13.0105 7.10744 12.9716 7.13467C12.9326 7.1619 12.9059 7.1915 12.891 7.22363C12.8761 7.25577 12.8608 7.29823 12.8457 7.34953L12.5654 8.32649L12.2481 7.41164C12.2186 7.33481 12.1947 7.27962 12.1759 7.24378C12.1572 7.20794 12.1227 7.17317 12.0719 7.14138C12.021 7.1096 11.9502 7.09438 11.8587 7.09438C11.7687 7.09438 11.6967 7.10908 11.6438 7.1397C11.5909 7.17033 11.5531 7.20623 11.5313 7.24546C11.5095 7.28469 11.4857 7.33927 11.4592 7.41164L11.1453 8.32649L10.8632 7.34282C10.8411 7.26822 10.8123 7.20887 10.7776 7.1632C10.743 7.11754 10.6728 7.09438 10.5695 7.09438ZM2.58429 9.53342C3.26749 11.8253 5.442 13.5 8.00456 13.5C10.5671 13.5 12.7417 11.8254 13.4248 9.53342H12.6308C12.5551 9.74957 12.4646 9.95855 12.3589 10.1595H10.7474C10.816 9.95462 10.8727 9.74514 10.9203 9.53342H10.1532C10.0996 9.74751 10.0355 9.95668 9.95679 10.1595H8.28992V9.53342H7.5379V10.1595H6.01539C5.94636 9.95743 5.88696 9.74804 5.83746 9.53342H5.06529C5.10855 9.74538 5.16135 9.95463 5.2214 10.1595H3.65021C3.54448 9.95855 3.45231 9.74957 3.3766 9.53342H2.58429ZM4.14373 10.9116H5.49166C5.76677 11.5479 6.13152 12.1163 6.60123 12.5482C5.61231 12.2622 4.76 11.6817 4.14373 10.9116ZM6.32929 10.9116H7.5379V12.3166C7.04951 12.007 6.64102 11.5134 6.32929 10.9116ZM8.28992 10.9116H9.58246C9.2543 11.4601 8.82755 11.9347 8.28992 12.2813V10.9116ZM10.4469 10.9116H11.8654C11.1866 11.7598 10.2201 12.3774 9.10237 12.6254C9.67591 12.1617 10.1215 11.5712 10.4469 10.9116Z", fill: "currentcolor" }) });
}
function Globe(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M7.9987 1.34375C4.31683 1.34375 1.33203 4.32842 1.33203 8.01042C1.33203 9.08775 1.5899 10.1018 2.04343 11.0024C3.14036 13.1804 5.32943 14.6764 7.9987 14.6771C11.6806 14.6777 14.6654 11.6924 14.6654 8.01042C14.6654 4.32842 11.6806 1.34375 7.9987 1.34375ZM7.9987 2.67708C8.61997 2.67708 9.33403 3.73641 9.68937 5.29441C9.14997 5.32908 8.5851 5.34375 7.9987 5.34375C7.40983 5.34375 6.8449 5.32175 6.30477 5.28575C6.65983 3.78575 7.37743 2.67708 7.9987 2.67708ZM5.6419 3.22575C5.33797 3.78508 5.11463 4.49575 4.96296 5.16575C4.46976 5.09908 4.0233 5.00242 3.64763 4.90708C4.16463 4.19975 4.85216 3.60308 5.6419 3.22575ZM10.365 3.22174C11.0894 3.59641 11.82 4.19109 12.3484 4.91909C11.9732 5.01309 11.5143 5.09643 11.0237 5.16109C10.872 4.49109 10.6166 3.74641 10.365 3.22174ZM3.01483 6.11041C3.52043 6.26441 4.04203 6.37908 4.74337 6.47308C4.68583 6.98042 4.66536 7.46708 4.66536 8.01042C4.66536 8.55375 4.6907 9.04908 4.74823 9.55642C4.03343 9.65242 3.5151 9.74575 3.00183 9.90175C2.7663 9.29975 2.66536 8.69575 2.66536 8.01042C2.66536 7.32508 2.7793 6.71241 3.01483 6.11041ZM12.9766 6.11375C13.2122 6.71575 13.332 7.32508 13.332 8.01042C13.332 8.69575 13.2171 9.30175 12.9816 9.90375C12.4697 9.74775 11.9517 9.64308 11.2396 9.54775C11.2957 9.04575 11.332 8.54642 11.332 8.01042C11.332 7.46708 11.2956 6.97107 11.238 6.46307C11.9378 6.36641 12.4709 6.26708 12.9766 6.11375ZM6.08396 6.60175C6.7019 6.64641 7.3245 6.67708 7.9987 6.67708C8.6691 6.67708 9.30243 6.64642 9.9175 6.59975C9.97377 7.06842 9.9987 7.49575 9.9987 8.01042C9.9987 8.52508 9.98077 8.94108 9.92457 9.40908C9.30743 9.36374 8.67077 9.34375 7.9987 9.34375C7.3249 9.34375 6.69417 9.36776 6.07457 9.41376C6.01677 8.93976 5.9987 8.53308 5.9987 8.01042C5.9987 7.49575 6.0277 7.06975 6.08396 6.60175ZM7.9987 10.6771C8.58423 10.6771 9.1457 10.6991 9.6849 10.7337C9.30983 12.2944 8.62263 13.3437 7.9987 13.3437C7.37743 13.3437 6.67576 12.2438 6.2909 10.7324C6.83176 10.6964 7.4089 10.6771 7.9987 10.6771ZM4.96603 10.8624C5.11763 11.5324 5.3815 12.2678 5.6331 12.7931C4.89496 12.4424 4.18623 11.8384 3.6459 11.1144C4.0279 11.0178 4.46037 10.9298 4.96603 10.8624ZM11.0257 10.8611C11.5274 10.9264 11.9618 11.0211 12.3431 11.1164C11.86 11.7657 11.1508 12.4084 10.3716 12.7844C10.6558 12.2044 10.874 11.5311 11.0257 10.8611Z" }) });
}
function Hdd(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 25", fill: "currentcolor", children: jsx("path", { d: "M7.24956 4.68945C5.17156 4.68945 3.27058 6.40045 2.93758 8.53345L1.99956 15.5645C1.98756 15.6545 2.05058 15.7285 2.06258 15.8145C2.04858 15.9415 1.99956 16.0585 1.99956 16.1895V17.1895C1.99956 19.1225 3.56656 20.6895 5.49956 20.6895H18.4996C20.4326 20.6895 21.9996 19.1225 21.9996 17.1895V16.1895C21.9996 16.0585 21.9516 15.9415 21.9376 15.8145C21.9496 15.7285 22.0126 15.6545 21.9996 15.5645L20.9996 8.56445C20.6646 6.41545 18.7966 4.68945 16.7186 4.68945H7.24956ZM5.49956 14.6895H18.4996C19.3286 14.6895 19.9996 15.3615 19.9996 16.1895V17.1895C19.9996 18.0175 19.3286 18.6895 18.4996 18.6895H5.49956C4.67156 18.6895 3.99956 18.0175 3.99956 17.1895V16.1895C3.99956 15.3615 4.67156 14.6895 5.49956 14.6895ZM5.99956 15.6895C5.44756 15.6895 4.99956 16.1375 4.99956 16.6895C4.99956 17.2415 5.44756 17.6895 5.99956 17.6895C6.55256 17.6895 6.99956 17.2415 6.99956 16.6895C6.99956 16.1375 6.55256 15.6895 5.99956 15.6895ZM8.99956 15.6895C8.44756 15.6895 7.99956 16.1375 7.99956 16.6895C7.99956 17.2415 8.44756 17.6895 8.99956 17.6895C9.55256 17.6895 9.99956 17.2415 9.99956 16.6895C9.99956 16.1375 9.55256 15.6895 8.99956 15.6895Z" }) });
}
function History(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M8.02812 1.33301C4.33612 1.33301 1.34277 4.317 1.34277 7.99833C1.34277 11.6797 4.33612 14.6643 8.02812 14.6643C9.83012 14.6643 11.5248 13.9537 12.7708 12.7063C13.0314 12.445 13.0328 12.0283 12.7708 11.769C12.5094 11.509 12.0914 11.5077 11.8308 11.769C10.8334 12.7677 9.47078 13.331 8.02812 13.331C5.07478 13.331 2.68011 10.9437 2.68011 7.99833C2.68011 5.05366 5.07478 2.66634 8.02812 2.66634C8.39745 2.66634 8.69678 2.36767 8.69678 1.99967C8.69678 1.63167 8.39745 1.33301 8.02812 1.33301ZM10.4728 1.93701C10.3108 1.99035 10.1781 2.10501 10.0968 2.27034C9.93412 2.60101 10.0581 3.00367 10.3894 3.16634C10.5674 3.25301 10.7241 3.35102 10.8908 3.45768C11.2014 3.65568 11.6321 3.55967 11.8308 3.24967C12.0294 2.93901 11.9328 2.53101 11.6221 2.33301C11.4128 2.19967 11.1968 2.08767 10.9741 1.979C10.8088 1.89767 10.6354 1.88434 10.4728 1.93701ZM12.8334 3.58236C12.6641 3.56236 12.4774 3.61502 12.3321 3.72835C12.0421 3.95569 11.9994 4.37636 12.2281 4.66569C12.3501 4.82102 12.4781 4.97702 12.5828 5.14502C12.7774 5.45769 13.1888 5.54703 13.5021 5.35303C13.8161 5.15903 13.9054 4.77035 13.7114 4.45768C13.5808 4.24768 13.4254 4.02702 13.2721 3.83236C13.1581 3.68769 13.0034 3.60302 12.8334 3.58236ZM8.02812 3.99902C7.65945 3.99902 7.36011 4.29769 7.36011 4.66569V7.99833C7.36011 8.17566 7.44343 8.35233 7.56877 8.47766L9.5741 10.477C9.83543 10.7377 10.2534 10.7377 10.5148 10.477C10.7754 10.217 10.7754 9.77967 10.5148 9.519L8.69678 7.70699V4.66569C8.69678 4.29769 8.39745 3.99902 8.02812 3.99902ZM13.7528 6.01969C13.3921 6.09903 13.1714 6.45166 13.2514 6.81099C13.2941 7.00366 13.3354 7.19766 13.3561 7.39433C13.3948 7.76033 13.7201 8.01633 14.0874 7.97766C14.4541 7.93899 14.7114 7.61502 14.6721 7.24902C14.6461 7.00236 14.6214 6.76036 14.5674 6.51969C14.4881 6.16036 14.1134 5.94036 13.7528 6.01969ZM14.0454 8.72766C13.6868 8.64099 13.3174 8.86966 13.2308 9.22766C13.1841 9.42033 13.1101 9.60501 13.0428 9.78967C12.9161 10.1357 13.1134 10.497 13.4608 10.623C13.8074 10.749 14.1701 10.5943 14.2961 10.2483C14.3808 10.0163 14.4674 9.78101 14.5261 9.53967C14.6128 9.18234 14.4041 8.81433 14.0454 8.72766Z" }) });
}
function InfoSquare(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M4.66557 1.99414C3.1929 1.99414 1.9989 3.18815 1.9989 4.66082V11.3275C1.9989 12.8002 3.1929 13.9942 4.66557 13.9942H11.3322C12.8049 13.9942 13.9989 12.8002 13.9989 11.3275V4.66082C13.9989 3.18815 12.8049 1.99414 11.3322 1.99414H4.66557ZM7.9989 4.66082C8.3669 4.66082 8.66556 4.95949 8.66556 5.32749C8.66556 5.6955 8.3669 5.99416 7.9989 5.99416C7.6309 5.99416 7.33223 5.6955 7.33223 5.32749C7.33223 4.95949 7.6309 4.66082 7.9989 4.66082ZM7.9989 6.66083C8.3669 6.66083 8.66556 6.9595 8.66556 7.32751V10.6609C8.66556 11.0289 8.3669 11.3275 7.9989 11.3275C7.6309 11.3275 7.33223 11.0289 7.33223 10.6609V7.32751C7.33223 6.9595 7.6309 6.66083 7.9989 6.66083Z" }) });
}
function Link(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.7562 4.74381C17.0977 3.0854 14.4088 3.0854 12.7503 4.74381L9.74749 7.74664C8.08906 9.40505 8.08941 12.0937 9.74786 13.7521C10.1625 14.1667 10.8347 14.1667 11.2493 13.7521C11.6639 13.3375 11.6639 12.6653 11.2493 12.2507L11.2322 12.2339C10.4197 11.4035 10.4253 10.0716 11.2489 9.24805L14.2518 6.24522C15.0811 5.41601 16.4255 5.41603 17.2547 6.24522C18.0839 7.07443 18.0839 8.41884 17.2547 9.24805L16.1917 10.3111C16.5282 11.17 16.6325 12.099 16.5043 13.0012L18.7562 10.7495C20.4146 9.09106 20.4146 6.40223 18.7562 4.74381ZM5.24383 18.2562C6.90228 19.9146 9.59115 19.9146 11.2496 18.2562L14.2525 15.2534C15.911 13.595 15.911 10.9061 14.2525 9.24768C13.8378 8.83308 13.1657 8.83308 12.7511 9.24768C12.3364 9.66229 12.3364 10.3345 12.7511 10.7491C13.5803 11.5783 13.5803 12.9227 12.7511 13.7519L9.74815 16.7548C8.91894 17.5839 7.5745 17.5839 6.74528 16.7548C5.91605 15.9255 5.91605 14.5811 6.74528 13.7519L7.80833 12.6888C7.47174 11.83 7.36751 10.901 7.49563 9.99875L5.24383 12.2505C3.58539 13.9089 3.58539 16.5978 5.24383 18.2562Z" }) });
}
function Linkedin(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M4.95963 2.99902C3.88199 2.99902 3 3.88099 3 4.95865V11.0397C3 12.1174 3.88197 12.999 4.95963 12.999H11.0407C12.1183 12.999 13 12.1174 13 11.0397V4.95865C13 3.88101 12.1183 2.99902 11.0407 2.99902H4.95963ZM5.4525 4.64922C5.96921 4.64922 6.28748 4.98843 6.2973 5.43432C6.2973 5.87036 5.96919 6.2191 5.44251 6.2191H5.43281C4.92594 6.2191 4.59833 5.87038 4.59833 5.43432C4.59833 4.98844 4.93587 4.64922 5.4525 4.64922ZM9.90525 6.73324C10.899 6.73324 11.6439 7.38274 11.6439 8.77849V11.3841H10.1337V8.95319C10.1337 8.34232 9.91515 7.92556 9.36862 7.92556C8.9514 7.92556 8.70271 8.20646 8.59352 8.47782C8.55364 8.5749 8.54383 8.71049 8.54383 8.8463V11.3841H7.03364C7.03364 11.3841 7.05346 7.26619 7.03364 6.8398H8.54414V7.48332C8.74483 7.17369 9.10381 6.73324 9.90525 6.73324ZM4.68741 6.84013H6.1976V11.3841H4.68741V6.84013Z", fill: "currentcolor" }) });
}
function Lock(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M11.998 1.95312C9.23705 1.95312 6.99805 4.19213 6.99805 6.95312V8.95312C5.34105 8.95312 3.99805 10.2961 3.99805 11.9531V18.9531C3.99805 20.6101 5.34105 21.9531 6.99805 21.9531H16.998C18.655 21.9531 19.998 20.6101 19.998 18.9531V11.9531C19.998 10.2961 18.655 8.95312 16.998 8.95312V6.95312C16.998 4.19213 14.759 1.95312 11.998 1.95312ZM11.998 3.95312C13.655 3.95312 14.998 5.29612 14.998 6.95312V8.95312H8.99805V6.95312C8.99805 5.29612 10.341 3.95312 11.998 3.95312ZM11.998 11.9531C13.103 11.9531 13.998 12.8481 13.998 13.9531C13.998 14.6631 13.555 15.1611 12.998 15.5151V17.9531C12.998 18.5051 12.55 18.9531 11.998 18.9531C11.446 18.9531 10.998 18.5051 10.998 17.9531V15.5151C10.441 15.1601 9.99805 14.6631 9.99805 13.9531C9.99805 12.8481 10.893 11.9531 11.998 11.9531Z" }) });
}
function M(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 24 24", fill: "none", children: [jsx("path", { d: "M1.88134 8.65644V18.3251H0V7.09336C0 6.19326 1.03474 5.68003 1.75748 6.22134L10.6938 12.912C10.9698 13.1179 11.1313 13.4409 11.1313 13.784V18.3235H9.24992V14.174L1.88134 8.65644Z", fill: "currentcolor" }), jsx("path", { d: "M22.0605 18.3251V8.65599L14.4616 14.1738V18.3251H12.5215V13.7854C12.5215 13.4422 12.688 13.1193 12.9726 12.9133L22.1882 6.22233C22.9335 5.67944 24.0006 6.19269 24.0006 7.09283V18.3251H22.0605Z", fill: "currentcolor" })] });
}
function Modified(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { x: "1.5", y: "1.5", width: "13", height: "13", rx: "3.5", stroke: "currentcolor" }), jsx("circle", { cx: "8", cy: "8", r: "3", fill: "currentcolor" })] });
}
function Moved(props) {
  return jsxs("svg", { ...props, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M7.07143 1.96429C7.07143 2.2207 6.86356 2.42857 6.60714 2.42857H5.21429C3.67578 2.42857 2.42857 3.67578 2.42857 5.21429V10.7857C2.42857 12.3242 3.67578 13.5714 5.21429 13.5714H10.7857C12.3242 13.5714 13.5714 12.3242 13.5714 10.7857V9.39286C13.5714 9.13644 13.7793 8.92857 14.0357 8.92857C14.2921 8.92857 14.5 9.13644 14.5 9.39286V10.7857C14.5 12.8371 12.8371 14.5 10.7857 14.5H5.21429C3.16294 14.5 1.5 12.8371 1.5 10.7857V5.21429C1.5 3.16294 3.16294 1.5 5.21429 1.5H6.60714C6.86356 1.5 7.07143 1.70787 7.07143 1.96429Z", fill: "currentcolor" }), jsx("path", { d: "M14 6.5V2.5C14 2.22386 13.7761 2 13.5 2H9.5", stroke: "currentcolor", strokeLinecap: "round" }), jsx("path", { d: "M7 10L7.28346 9.29136C8.39378 6.51556 10.4269 4.20728 13.0403 2.75539L13.5 2.5", stroke: "currentcolor", strokeLinecap: "round" })] });
}
function PackageManager(props) {
  return jsx("svg", { ...props, width: "12", height: "12", viewBox: "0 0 12 12", fill: "currentcolor", children: jsx("path", { d: "M1.22323 -0.00109863C0.549226 -0.00109863 -0.00610352 0.533576 -0.00610352 1.20691V2.79089C-0.00610352 3.46423 0.549226 3.9989 1.22323 3.9989H4.0979C4.7719 3.9989 5.32723 3.46423 5.32723 2.79089V1.20691C5.32723 0.533576 4.7719 -0.00109863 4.0979 -0.00109863H1.22323ZM7.9939 -0.00109863C7.25723 -0.00109863 6.66056 0.595568 6.66056 1.33223V5.33223C6.66056 6.0689 7.25723 6.66557 7.9939 6.66557H10.6606C11.3972 6.66557 11.9939 6.0689 11.9939 5.33223V1.33223C11.9939 0.595568 11.3972 -0.00109863 10.6606 -0.00109863H7.9939ZM1.32723 5.33223C0.590563 5.33223 -0.00610352 5.9289 -0.00610352 6.66557V10.6656C-0.00610352 11.4022 0.590563 11.9989 1.32723 11.9989H3.9939C4.73056 11.9989 5.32723 11.4022 5.32723 10.6656V6.66557C5.32723 5.9289 4.73056 5.33223 3.9939 5.33223H1.32723ZM7.88989 7.9989C7.21589 7.9989 6.66056 8.53358 6.66056 9.20691V10.7909C6.66056 11.4642 7.21589 11.9989 7.88989 11.9989H10.7646C11.4386 11.9989 11.9939 11.4642 11.9939 10.7909V9.20691C11.9939 8.53358 11.4386 7.9989 10.7646 7.9989H7.88989Z" }) });
}
function Pencil(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M16.9951 1.95312C16.7301 1.95312 16.4641 2.04713 16.2761 2.23413C15.7201 2.79013 13.7191 4.79115 13.2751 5.23615L4.26978 14.2412L3.26928 15.2412C3.12958 15.3812 3.05788 15.5792 3.01918 15.7732L2.01858 20.7762C1.87858 21.4762 2.47538 22.0721 3.17548 21.9331C3.80078 21.8071 7.55288 21.0572 8.17818 20.9322C8.37188 20.8932 8.57008 20.8212 8.70968 20.6822L9.71027 19.6812L18.7151 10.6762C19.1601 10.2322 21.1611 8.23012 21.7171 7.67512C21.9041 7.48712 21.9981 7.22113 21.9981 6.95613C21.9981 5.31912 21.5811 4.14912 20.7161 3.26612C19.8431 2.37511 18.6771 1.95312 16.9951 1.95312ZM17.3891 3.97211C18.2921 4.02511 18.8771 4.23216 19.2781 4.64216C19.6881 5.06016 19.9471 5.64015 20.0031 6.52516C19.4551 7.07216 18.6531 7.86212 17.9961 8.51912C17.2031 7.72612 16.2251 6.74815 15.4321 5.95515C16.0901 5.29815 16.8421 4.51911 17.3891 3.97211ZM4.98898 16.3982L7.55288 18.9621L7.45908 19.0562C6.79908 19.1882 5.46628 19.4672 4.23858 19.7132L4.89518 16.4922L4.98898 16.3982Z" }) });
}
function PeopleFill(props) {
  return jsx("svg", { ...props, ...props, viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M7.74939 1.46484C6.50674 1.46484 5.49939 2.47234 5.49939 3.71484C5.49939 4.95734 6.50674 5.96484 7.74939 5.96484C8.99204 5.96484 9.99939 4.95734 9.99939 3.71484C9.99939 2.47234 8.99204 1.46484 7.74939 1.46484ZM3.99939 1.96484C2.89484 1.96484 1.99939 2.86034 1.99939 3.96484C1.99939 5.06934 2.89484 5.96484 3.99939 5.96484C4.41409 5.96484 4.79264 5.85086 5.12579 5.61786C4.27139 4.34786 4.39249 3.13184 4.85814 2.15234C4.59219 2.02634 4.30009 1.96484 3.99939 1.96484ZM2.53064 6.63684C1.61359 7.01534 0.99939 7.94284 0.99939 8.96484V9.96484C0.99939 10.2408 1.22324 10.4648 1.49939 10.4648L3.57579 10.4659C3.45879 10.0859 3.49319 9.46984 3.50089 8.97134C3.51714 7.91284 3.95489 7.15783 4.12634 6.95883C3.81124 6.95633 3.43309 6.87984 3.15564 6.76184C3.08864 6.73334 3.04974 6.71084 2.92129 6.65234C2.79534 6.59484 2.65854 6.58384 2.53064 6.63684ZM6.03064 6.63684C5.11359 7.01534 4.49939 7.94284 4.49939 8.96484V9.96484C4.49939 10.2408 4.72324 10.4648 4.99939 10.4648H10.4994C10.7755 10.4648 10.9994 10.2408 10.9994 9.96484V8.96484C10.9994 7.96684 10.3818 7.06185 9.46814 6.66785C9.33954 6.61235 9.18969 6.61085 9.06189 6.66785C8.61949 6.86635 8.18849 6.96484 7.74939 6.96484C7.31179 6.96484 6.87929 6.86084 6.42129 6.65234C6.29534 6.59484 6.15854 6.58384 6.03064 6.63684Z", fill: "#343839" }) });
}
function People(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M15.498 2.92969C13.0127 2.92969 10.998 4.94469 10.998 7.42969C10.998 9.91469 13.0127 11.9297 15.498 11.9297C17.9833 11.9297 19.998 9.91469 19.998 7.42969C19.998 4.94469 17.9833 2.92969 15.498 2.92969ZM7.99805 3.92969C5.78895 3.92969 3.99805 5.72069 3.99805 7.92969C3.99805 10.1387 5.78895 11.9297 7.99805 11.9297C8.82745 11.9297 9.58455 11.7017 10.2508 11.2357C8.54205 8.69572 8.78425 6.26369 9.71555 4.30469C9.18365 4.05269 8.59945 3.92969 7.99805 3.92969ZM5.06055 13.2737C3.22645 14.0307 1.99805 15.8857 1.99805 17.9297V19.9297C1.99805 20.4817 2.44575 20.9297 2.99805 20.9297L7.15085 20.9317C6.91685 20.1717 6.98565 18.9397 7.00105 17.9427C7.03355 15.8257 7.90905 14.3157 8.25195 13.9177C7.62175 13.9127 6.86545 13.7597 6.31055 13.5237C6.17655 13.4667 6.09875 13.4217 5.84185 13.3047C5.58995 13.1897 5.31635 13.1677 5.06055 13.2737ZM12.0605 13.2737C10.2264 14.0307 8.99805 15.8857 8.99805 17.9297V19.9297C8.99805 20.4817 9.44575 20.9297 9.99805 20.9297H20.998C21.5503 20.9297 21.998 20.4817 21.998 19.9297V17.9297C21.998 15.9337 20.7628 14.1237 18.9355 13.3357C18.6783 13.2247 18.3786 13.2217 18.123 13.3357C17.2382 13.7327 16.3762 13.9297 15.498 13.9297C14.6228 13.9297 13.7578 13.7217 12.8418 13.3047C12.5899 13.1897 12.3163 13.1677 12.0605 13.2737Z" }) });
}
function Person(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M7.9974 1.30273C6.15646 1.30273 4.66406 2.79513 4.66406 4.63607C4.66406 6.477 6.15646 7.9694 7.9974 7.9694C9.83833 7.9694 11.3307 6.477 11.3307 4.63607C11.3307 2.79513 9.83833 1.30273 7.9974 1.30273ZM5.64326 8.8444C3.9004 9.32073 2.66406 10.8362 2.66406 12.6361V13.9694C2.66406 14.3376 2.96253 14.6361 3.33073 14.6361H12.6641C13.0323 14.6361 13.3307 14.3376 13.3307 13.9694V12.6361C13.3307 10.8362 12.0944 9.32073 10.3515 8.8444C10.2021 8.80353 10.0553 8.8224 9.91406 8.88607C9.30373 9.16113 8.654 9.30273 7.9974 9.30273C7.3408 9.30273 6.69106 9.16113 6.08073 8.88607C5.93946 8.8224 5.79266 8.80353 5.64326 8.8444Z" }) });
}
function PinFilled(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.2627 1.21187C10.471 1.00359 10.8087 1.00359 11.017 1.21187L12.1484 2.34324L13.6569 3.85174L14.7882 4.98311C14.9965 5.19139 14.9965 5.52908 14.7882 5.73736C14.5799 5.94564 14.2423 5.94564 14.034 5.73736L13.3374 5.04081L9.45845 10.2128L10.6399 11.3942C10.8481 11.6025 10.8481 11.9402 10.6399 12.1485C10.4316 12.3567 10.0939 12.3567 9.88562 12.1485L8.37712 10.64L7.24582 9.50866C7.24581 9.50868 7.24579 9.50869 7.24577 9.50871L3.75738 12.9971C3.5491 13.2054 3.21141 13.2054 3.00313 12.9971C2.79485 12.7888 2.79485 12.4511 3.00313 12.2429L6.49153 8.75446C6.49154 8.75445 6.49156 8.75443 6.49157 8.75441L5.36014 7.62298L3.85164 6.11448C3.64336 5.9062 3.64336 5.56851 3.85164 5.36023C4.05992 5.15195 4.39761 5.15195 4.60589 5.36023L5.7873 6.54165L10.9593 2.66266L10.2627 1.96612C10.0545 1.75784 10.0545 1.42015 10.2627 1.21187Z", fill: "currentcolor" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.2627 1.21187C10.471 1.00359 10.8087 1.00359 11.017 1.21187L12.1484 2.34324L13.6569 3.85174L14.7882 4.98311C14.9965 5.19139 14.9965 5.52908 14.7882 5.73736C14.5799 5.94564 14.2423 5.94564 14.034 5.73736L13.3374 5.04081L9.45845 10.2128L10.6399 11.3942C10.8481 11.6025 10.8481 11.9402 10.6399 12.1485C10.4316 12.3567 10.0939 12.3567 9.88562 12.1485L8.37712 10.64L7.24582 9.50866C7.24581 9.50868 7.24579 9.50869 7.24577 9.50871L3.75738 12.9971C3.5491 13.2054 3.21141 13.2054 3.00313 12.9971C2.79485 12.7888 2.79485 12.4511 3.00313 12.2429L6.49153 8.75446C6.49154 8.75445 6.49156 8.75443 6.49157 8.75441L5.36014 7.62298L3.85164 6.11448C3.64336 5.9062 3.64336 5.56851 3.85164 5.36023C4.05992 5.15195 4.39761 5.15195 4.60589 5.36023L5.7873 6.54165L10.9593 2.66266L10.2627 1.96612C10.0545 1.75784 10.0545 1.42015 10.2627 1.21187Z", fill: "currentcolor" })] });
}
function Pin(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.017 1.212C10.8087 1.00372 10.471 1.00372 10.2627 1.212C10.0545 1.42028 10.0545 1.75796 10.2627 1.96624L10.9593 2.66279L5.7873 6.54177L4.60589 5.36036C4.39761 5.15208 4.05992 5.15208 3.85164 5.36036C3.64336 5.56864 3.64336 5.90632 3.85164 6.1146L5.36014 7.6231L6.49157 8.75454C6.49156 8.75455 6.49154 8.75457 6.49153 8.75458L3.00313 12.243C2.79485 12.4513 2.79485 12.7889 3.00313 12.9972C3.21141 13.2055 3.5491 13.2055 3.75738 12.9972L7.24577 9.50883C7.24579 9.50882 7.24581 9.5088 7.24582 9.50878L8.37712 10.6401L9.88562 12.1486C10.0939 12.3569 10.4316 12.3569 10.6399 12.1486C10.8481 11.9403 10.8481 11.6026 10.6399 11.3943L9.45845 10.2129L13.3374 5.04094L14.034 5.73748C14.2423 5.94576 14.5799 5.94576 14.7882 5.73748C14.9965 5.5292 14.9965 5.19151 14.7882 4.98323L13.6569 3.85186L12.1484 2.34337L11.017 1.212ZM6.54921 7.30368L11.7212 3.42469L12.5755 4.27903L8.69654 9.45101L6.54921 7.30368Z", fill: "currentcolor" }) });
}
function PlusCircle(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M8.00846 1.30273C4.3266 1.30273 1.3418 4.2874 1.3418 7.9694C1.3418 11.6514 4.3266 14.6361 8.00846 14.6361C11.6903 14.6361 14.6751 11.6514 14.6751 7.9694C14.6751 4.2874 11.6903 1.30273 8.00846 1.30273ZM8.00846 4.63607C8.37667 4.63607 8.67513 4.93473 8.67513 5.30273V7.30273H10.6751C11.0433 7.30273 11.3418 7.6014 11.3418 7.9694C11.3418 8.3374 11.0433 8.63606 10.6751 8.63606H8.67513V10.6361C8.67513 11.0041 8.37667 11.3027 8.00846 11.3027C7.64026 11.3027 7.3418 11.0041 7.3418 10.6361V8.63606H5.3418C4.9736 8.63606 4.67513 8.3374 4.67513 7.9694C4.67513 7.6014 4.9736 7.30273 5.3418 7.30273H7.3418V5.30273C7.3418 4.93473 7.64026 4.63607 8.00846 4.63607Z" }) });
}
function PlusSquare(props) {
  return jsx("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M9.32113 3.90637C6.3758 3.90637 3.98779 6.29437 3.98779 9.2397L3.98779 22.573C3.98779 25.5184 6.3758 27.9064 9.32113 27.9064L22.6545 27.9064C25.5998 27.9064 27.9878 25.5184 27.9878 22.573L27.9878 9.2397C27.9878 6.29437 25.5998 3.90637 22.6545 3.90637L9.32113 3.90637ZM9.32113 6.57304L22.6545 6.57304C24.1278 6.57304 25.3212 7.76637 25.3212 9.2397L25.3212 22.573C25.3212 24.0464 24.1278 25.2397 22.6545 25.2397L9.32113 25.2397C7.8478 25.2397 6.65446 24.0464 6.65446 22.573L6.65446 9.2397C6.65446 7.76637 7.8478 6.57304 9.32113 6.57304ZM15.9878 9.2397C15.2518 9.2397 14.6545 9.83704 14.6545 10.573L14.6545 14.573L10.6545 14.573C9.91847 14.573 9.32113 15.1704 9.32113 15.9064C9.32113 16.6424 9.91847 17.2397 10.6545 17.2397L14.6545 17.2397L14.6545 21.2397C14.6545 21.9757 15.2518 22.573 15.9878 22.573C16.7238 22.573 17.3211 21.9757 17.3211 21.2397L17.3211 17.2397L21.3212 17.2397C22.0572 17.2397 22.6545 16.6424 22.6545 15.9064C22.6545 15.1704 22.0572 14.573 21.3212 14.573L17.3211 14.573L17.3211 10.573C17.3211 9.83704 16.7238 9.2397 15.9878 9.2397Z", fill: "#32373B" }) });
}
function Plus(props) {
  return jsx("svg", { ...props, viewBox: "0 0 18 19", fill: "currentcolor", children: jsx("path", { d: "M8.99072 0.929749C8.43872 0.929749 7.99072 1.37775 7.99072 1.92975V8.92975H0.990723C0.438723 8.92975 -0.00927734 9.37775 -0.00927734 9.92975C-0.00927734 10.4817 0.438723 10.9297 0.990723 10.9297H7.99072V17.9297C7.99072 18.4817 8.43872 18.9297 8.99072 18.9297C9.54272 18.9297 9.99072 18.4817 9.99072 17.9297V10.9297H16.9907C17.5427 10.9297 17.9907 10.4817 17.9907 9.92975C17.9907 9.37775 17.5427 8.92975 16.9907 8.92975H9.99072V1.92975C9.99072 1.37775 9.54272 0.929749 8.99072 0.929749Z" }) });
}
function PowerhouseLogoSmall(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.0059 0L3.41636 5.45646C2.44979 6.25682 2.3795 7.71452 3.26456 8.60418L5.54425 10.8957C6.21311 11.568 6.35783 12.6012 5.89944 13.4314L4.48126 16H2.13333C0.955126 16 0 15.0449 0 13.8667V2.13333C0 0.955126 0.955126 0 2.13333 0H10.0059ZM11.2436 0L10.0128 2.24221C9.55899 3.06891 9.70183 4.09549 10.3641 4.7669L12.7825 7.21868C13.6656 8.11402 13.5866 9.57512 12.612 10.37L5.70922 16H13.8667C15.0449 16 16 15.0449 16 13.8667V2.13333C16 0.955126 15.0449 0 13.8667 0H11.2436Z" }) });
}
function Project(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M11.4561 1.95312C12.8734 1.95312 13.998 3.15579 13.998 4.61979V11.2865C13.998 12.7505 12.8734 13.9531 11.4561 13.9531H11.3314V1.95312H11.4561ZM9.99805 1.95312V13.9531H4.53939C3.12272 13.9531 1.99805 12.7505 1.99805 11.2865V4.61979C1.99805 3.15579 3.12272 1.95312 4.53939 1.95312H9.99805ZM7.33138 4.61979H4.66471C4.29671 4.61979 3.99805 4.91846 3.99805 5.28646C3.99805 5.65446 4.29671 5.95312 4.66471 5.95312H7.33138C7.69938 5.95312 7.99805 5.65446 7.99805 5.28646C7.99805 4.91846 7.69938 4.61979 7.33138 4.61979ZM7.33138 7.28646H4.66471C4.29671 7.28646 3.99805 7.58512 3.99805 7.95312C3.99805 8.32112 4.29671 8.61979 4.66471 8.61979H7.33138C7.69938 8.61979 7.99805 8.32112 7.99805 7.95312C7.99805 7.58512 7.69938 7.28646 7.33138 7.28646ZM7.33138 9.95312H4.66471C4.29671 9.95312 3.99805 10.2518 3.99805 10.6198C3.99805 10.9878 4.29671 11.2865 4.66471 11.2865H7.33138C7.69938 11.2865 7.99805 10.9878 7.99805 10.6198C7.99805 10.2518 7.69938 9.95312 7.33138 9.95312Z" }) });
}
function QuestionSquare(props) {
  return jsx("svg", { ...props, width: "12", height: "13", viewBox: "0 0 12 13", fill: "currentcolor", children: jsx("path", { d: "M2.66056 0.953125C1.18783 0.953125 -0.00610352 2.14713 -0.00610352 3.61979V10.2865C-0.00610352 11.7591 1.18783 12.9531 2.66056 12.9531H9.32723C10.8 12.9531 11.9939 11.7591 11.9939 10.2865V3.61979C11.9939 2.14713 10.8 0.953125 9.32723 0.953125H2.66056ZM5.95223 3.61979C7.0557 3.61979 7.9483 4.51579 7.95223 5.61979C7.9549 6.35913 7.60796 6.98246 7.03556 7.55713C6.91576 7.6778 6.8001 7.79378 6.66056 7.91178C6.59396 7.96778 6.40963 8.10313 6.38976 8.11979C6.10823 8.35713 5.68956 8.33913 5.45223 8.05713C5.2149 7.7758 5.25403 7.33645 5.53556 7.09912C5.56636 7.07312 5.72963 6.9378 5.78556 6.89046C5.8975 6.79646 6.00883 6.70913 6.09803 6.61979C6.44443 6.27179 6.62003 5.93846 6.6189 5.61979C6.61756 5.24913 6.3197 4.95312 5.95223 4.95312C5.64783 4.95312 5.3829 5.16379 5.30643 5.45312C5.21236 5.80912 4.8499 6.02645 4.4939 5.93245C4.1379 5.83845 3.9207 5.45512 4.0147 5.09912C4.2449 4.22779 5.03896 3.61979 5.95223 3.61979ZM5.95223 8.95312C6.32043 8.95312 6.6189 9.25179 6.6189 9.61979C6.6189 9.98779 6.32043 10.2865 5.95223 10.2865C5.58403 10.2865 5.28556 9.98779 5.28556 9.61979C5.28556 9.25179 5.58403 8.95312 5.95223 8.95312Z" }) });
}
function RedoArrow(props) {
  return jsx("svg", { ...props, viewBox: "0 0 21 17", fill: "currentcolor", children: jsx("path", { d: "M10.9863 4.90607C10.6036 4.90607 8.3471 4.87807 7.9863 4.90607C2.04289 5.36307 0.986294 9.90607 0.986294 14.9061V15.9061C2.85309 13.9911 3.9863 12.9061 7.9863 12.9061C8.7319 12.9061 10.0809 12.9061 10.9863 12.9061L11.0166 15.4801C11.0166 16.9001 11.8933 17.3321 12.9747 16.4451L20.1554 10.5521C21.2633 9.64306 21.2633 8.16907 20.1554 7.26007L12.9747 1.36707C11.8933 0.480072 11.0166 0.912068 11.0166 2.33207L10.9863 4.90607Z" }) });
}
function Reload(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.93994 7.99994C1.93994 4.95954 4.30966 1.93994 7.99994 1.93994C11.0251 1.93994 12.4976 4.2113 13.1079 5.36663H11.2C10.9238 5.36663 10.7 5.59049 10.7 5.86663C10.7 6.14278 10.9238 6.36663 11.2 6.36663H14.4C14.6761 6.36663 14.9 6.14278 14.9 5.86663V2.66663C14.9 2.39049 14.6761 2.16663 14.4 2.16663C14.1238 2.16663 13.9 2.39049 13.9 2.66663V4.72863C13.1867 3.43408 11.4556 0.939941 7.99994 0.939941C3.68702 0.939941 0.939941 4.48034 0.939941 7.99994C0.939941 11.5195 3.68702 15.0599 7.99994 15.0599C10.0641 15.0599 11.7819 14.2434 13.005 12.9989C13.66 12.3324 14.1716 11.545 14.5204 10.6974C14.6255 10.442 14.5037 10.1498 14.2484 10.0447C13.993 9.93963 13.7008 10.0614 13.5957 10.3168C13.2945 11.0485 12.8536 11.7263 12.2918 12.2979C11.2492 13.3588 9.7853 14.0599 7.99994 14.0599C4.30966 14.0599 1.93994 11.0403 1.93994 7.99994Z" }) });
}
function Removed(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("rect", { x: "1.5", y: "1.5", width: "13", height: "13", rx: "3.5", stroke: "currentcolor" }), jsx("path", { d: "M4 8H12", stroke: "currentcolor", strokeLinecap: "round" })] });
}
function RenownHover(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 71 19", fill: "currentcolor", children: [jsx("path", { d: "M53.6211 18.4887V9.0342H56.435V10.8096H56.4923C56.7377 10.181 57.1085 9.70244 57.6047 9.37398C58.101 9.03986 58.6981 8.8728 59.3962 8.8728C60.4105 8.8728 61.2039 9.1871 61.7765 9.8157C62.3546 10.4443 62.6436 11.3164 62.6436 12.432V18.4887H59.7397V13.0776C59.7397 12.5283 59.6007 12.1007 59.3225 11.7949C59.0499 11.4835 58.6654 11.3277 58.1692 11.3277C57.6784 11.3277 57.2803 11.4976 56.9749 11.8374C56.6695 12.1772 56.5168 12.6161 56.5168 13.1541V18.4887H53.6211Z" }), jsx("path", { d: "M53.097 9.03394L50.7412 18.4884H47.6164L46.1522 12.075H46.0949L44.6389 18.4884H41.5632L39.1992 9.03394H42.1195L43.3056 15.7532H43.3628L44.7861 9.03394H47.551L48.9906 15.7532H49.0479L50.234 9.03394H53.097Z" }), jsx("path", { d: "M37.8661 17.3926C37.0427 18.2591 35.9084 18.6923 34.4632 18.6923C33.0181 18.6923 31.8838 18.2591 31.0604 17.3926C30.2369 16.5205 29.8252 15.3086 29.8252 13.7569C29.8252 12.2336 30.2424 11.033 31.0767 10.1552C31.9111 9.2718 33.0399 8.83008 34.4632 8.83008C35.892 8.83008 37.0208 9.26896 37.8497 10.1467C38.6841 11.0188 39.1013 12.2222 39.1013 13.7569C39.1013 15.3143 38.6896 16.5262 37.8661 17.3926ZM33.2117 15.7702C33.5116 16.2402 33.9288 16.4752 34.4632 16.4752C34.9977 16.4752 35.4148 16.2402 35.7148 15.7702C36.0147 15.2945 36.1647 14.6234 36.1647 13.7569C36.1647 12.9131 36.012 12.2506 35.7066 11.7692C35.4012 11.2878 34.9868 11.0472 34.4632 11.0472C33.9343 11.0472 33.5171 11.2878 33.2117 11.7692C32.9118 12.2449 32.7618 12.9075 32.7618 13.7569C32.7618 14.6234 32.9118 15.2945 33.2117 15.7702Z" }), jsx("path", { d: "M20.0088 18.4887V9.0342H22.8227V10.8096H22.88C23.1254 10.181 23.4962 9.70244 23.9924 9.37398C24.4887 9.03986 25.0858 8.8728 25.7838 8.8728C26.7982 8.8728 27.5916 9.1871 28.1642 9.8157C28.7423 10.4443 29.0313 11.3164 29.0313 12.432V18.4887H26.1274V13.0776C26.1274 12.5283 25.9883 12.1007 25.7102 11.7949C25.4376 11.4835 25.0531 11.3277 24.5569 11.3277C24.0661 11.3277 23.668 11.4976 23.3626 11.8374C23.0572 12.1772 22.9045 12.6161 22.9045 13.1541V18.4887H20.0088Z" }), jsx("path", { d: "M14.7486 10.9707C14.2851 10.9707 13.8952 11.1321 13.5789 11.4549C13.2626 11.7777 13.0854 12.1911 13.0472 12.6951H16.4337C16.4064 12.1741 16.2374 11.7579 15.9265 11.4464C15.6212 11.1293 15.2285 10.9707 14.7486 10.9707ZM16.4991 15.5153H19.1167C18.9749 16.4837 18.5141 17.2567 17.7343 17.8343C16.9599 18.4063 15.9838 18.6923 14.8059 18.6923C13.3662 18.6923 12.2374 18.2591 11.4194 17.3926C10.6014 16.5262 10.1924 15.3313 10.1924 13.8079C10.1924 12.2845 10.5987 11.0755 11.4112 10.1807C12.2237 9.28029 13.3226 8.83008 14.7077 8.83008C16.0656 8.83008 17.1481 9.26047 17.9552 10.1213C18.7677 10.9764 19.174 12.1231 19.174 13.5616V14.4195H13.0145V14.6064C13.0145 15.184 13.1835 15.6541 13.5216 16.0165C13.8597 16.3733 14.3015 16.5517 14.8468 16.5517C15.2503 16.5517 15.5993 16.461 15.8938 16.2798C16.1883 16.0929 16.3901 15.8381 16.4991 15.5153Z" }), jsx("path", { d: "M3.00205 8.58396V12.0667H4.7771C5.32789 12.0667 5.7587 11.911 6.06954 11.5995C6.38038 11.2881 6.5358 10.8662 6.5358 10.3338C6.5358 9.80718 6.37492 9.38528 6.05318 9.06815C5.73143 8.74535 5.30335 8.58396 4.76892 8.58396H3.00205ZM3.00205 14.1989V18.4886H0V6.23096H5.07158C6.53307 6.23096 7.65373 6.5849 8.43355 7.29278C9.21337 8.00066 9.60328 8.99453 9.60328 10.2744C9.60328 11.0446 9.42605 11.7439 9.07159 12.3725C8.71712 12.9955 8.2236 13.4514 7.59101 13.7402L9.94684 18.4886H6.5767L4.55624 14.1989H3.00205Z" }), jsx("path", { d: "M65.7255 0.211478C65.0841 2.46724 63.3737 4.2455 61.2041 4.90969C60.932 4.99366 60.932 5.39096 61.2041 5.47492C63.3725 6.13912 65.0841 7.91738 65.7255 10.1731C65.8056 10.4551 66.1932 10.4551 66.2745 10.1731C66.9159 7.91738 68.6263 6.13912 70.7959 5.47492C71.068 5.39096 71.068 4.99366 70.7959 4.90969C68.6276 4.2455 66.9159 2.46724 66.2745 0.211478C66.1944 -0.0704925 65.8068 -0.0704925 65.7255 0.211478Z", fill: "#21FFB4" })] });
}
function RenownLight(props) {
  return jsxs("svg", { ...props, width: "83", height: "22", viewBox: "0 0 83 22", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M62.6841 21.7601V10.6326H65.9736V12.7221H66.0405C66.3274 11.9823 66.7609 11.4191 67.341 11.0325C67.9212 10.6393 68.6192 10.4426 69.4352 10.4426C70.621 10.4426 71.5486 10.8125 72.2179 11.5524C72.8937 12.2922 73.2316 13.3187 73.2316 14.6317V21.7601H69.8369V15.3915C69.8369 14.745 69.6743 14.2418 69.3492 13.8819C69.0304 13.5153 68.581 13.332 68.0009 13.332C67.4271 13.332 66.9617 13.5319 66.6047 13.9319C66.2477 14.3318 66.0692 14.8483 66.0692 15.4815V21.7601H62.6841Z", fill: "currentcolor" }), jsx("path", { d: "M62.0713 10.6328L59.3173 21.7603H55.6644L53.9527 14.212H53.8858L52.1837 21.7603H48.5882L45.8246 10.6328H49.2384L50.625 18.5411H50.6919L52.3558 10.6328H55.5879L57.2709 18.5411H57.3379L58.7245 10.6328H62.0713Z", fill: "currentcolor" }), jsx("path", { d: "M44.2662 20.4703C43.3036 21.4901 41.9775 22 40.2882 22C38.5988 22 37.2728 21.4901 36.3102 20.4703C35.3475 19.4439 34.8662 18.0176 34.8662 16.1913C34.8662 14.3984 35.3539 12.9853 36.3293 11.9522C37.3047 10.9125 38.6243 10.3926 40.2882 10.3926C41.9584 10.3926 43.2781 10.9091 44.2471 11.9422C45.2224 12.9687 45.7101 14.385 45.7101 16.1913C45.7101 18.0242 45.2288 19.4506 44.2662 20.4703ZM38.8251 18.5608C39.1757 19.114 39.6634 19.3906 40.2882 19.3906C40.9129 19.3906 41.4006 19.114 41.7512 18.5608C42.1019 18.0009 42.2772 17.2111 42.2772 16.1913C42.2772 15.1982 42.0987 14.4184 41.7417 13.8518C41.3847 13.2853 40.9002 13.002 40.2882 13.002C39.6698 13.002 39.1821 13.2853 38.8251 13.8518C38.4745 14.4117 38.2992 15.1915 38.2992 16.1913C38.2992 17.2111 38.4745 18.0009 38.8251 18.5608Z", fill: "currentcolor" }), jsx("path", { d: "M23.3906 21.7601V10.6326H26.6801V12.7221H26.7471C27.034 11.9823 27.4675 11.4191 28.0476 11.0325C28.6277 10.6393 29.3258 10.4426 30.1418 10.4426C31.3275 10.4426 32.2551 10.8125 32.9245 11.5524C33.6002 12.2922 33.9381 13.3187 33.9381 14.6317V21.7601H30.5434V15.3915C30.5434 14.745 30.3808 14.2418 30.0557 13.8819C29.737 13.5153 29.2875 13.332 28.7074 13.332C28.1336 13.332 27.6683 13.5319 27.3113 13.9319C26.9543 14.3318 26.7758 14.8483 26.7758 15.4815V21.7601H23.3906Z", fill: "currentcolor" }), jsx("path", { d: "M17.2414 12.912C16.6995 12.912 16.2437 13.102 15.8739 13.4819C15.5042 13.8618 15.297 14.3484 15.2524 14.9416H19.2113C19.1794 14.3284 18.9818 13.8385 18.6184 13.4719C18.2614 13.0986 17.8024 12.912 17.2414 12.912ZM19.2878 18.2608H22.3478C22.182 19.4006 21.6433 20.3104 20.7317 20.9902C19.8264 21.6634 18.6853 22 17.3083 22C15.6253 22 14.3057 21.4901 13.3494 20.4703C12.3932 19.4506 11.915 18.0442 11.915 16.2513C11.915 14.4583 12.39 13.0353 13.3399 11.9822C14.2897 10.9225 15.5743 10.3926 17.1936 10.3926C18.7809 10.3926 20.0464 10.8991 20.9899 11.9122C21.9398 12.9187 22.4147 14.2684 22.4147 15.9613V16.9711H15.2141V17.1911C15.2141 17.8709 15.4117 18.4241 15.807 18.8507C16.2022 19.2706 16.7186 19.4806 17.3561 19.4806C17.8279 19.4806 18.2359 19.3739 18.5801 19.1606C18.9244 18.9407 19.1603 18.6408 19.2878 18.2608Z", fill: "currentcolor" }), jsx("path", { d: "M3.50945 10.1029V14.202H5.58452C6.2284 14.202 6.73202 14.0187 7.0954 13.6521C7.45878 13.2855 7.64047 12.789 7.64047 12.1624C7.64047 11.5426 7.4524 11.046 7.07628 10.6728C6.70015 10.2928 6.19971 10.1029 5.57496 10.1029H3.50945ZM3.50945 16.7114V21.7603H0V7.3335H5.92877C7.63728 7.3335 8.94735 7.75007 9.85897 8.58322C10.7706 9.41637 11.2264 10.5861 11.2264 12.0924C11.2264 12.9989 11.0192 13.8221 10.6049 14.5619C10.1905 15.2951 9.61354 15.8316 8.87403 16.1715L11.628 21.7603H7.68828L5.32633 16.7114H3.50945Z", fill: "currentcolor" }), jsx("path", { d: "M76.834 0.248901C76.0842 2.90384 74.0847 4.99678 71.5484 5.77851C71.2303 5.87734 71.2303 6.34494 71.5484 6.44376C74.0833 7.22549 76.0842 9.31844 76.834 11.9734C76.9277 12.3052 77.3807 12.3052 77.4758 11.9734C78.2257 9.31844 80.2251 7.22549 82.7614 6.44376C83.0795 6.34494 83.0795 5.87734 82.7614 5.77851C80.2266 4.99678 78.2257 2.90384 77.4758 0.248901C77.3821 -0.0829669 76.9291 -0.0829669 76.834 0.248901Z", fill: "url(#paint0_linear_2120_7894)" }), jsx("defs", { children: jsxs("linearGradient", { id: "paint0_linear_2120_7894", x1: "77.1549", y1: "-0.768932", x2: "72.2552", y2: "11.3783", gradientUnits: "userSpaceOnUse", children: [jsx("stop", { stopColor: "#21FFB4" }), jsx("stop", { offset: "1", stopColor: "#0080FF" })] }) })] });
}
function Renown(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 71 19", fill: "currentcolor", children: [jsx("path", { d: "M53.6211 18.4887V9.0342H56.435V10.8096H56.4923C56.7377 10.181 57.1085 9.70244 57.6047 9.37398C58.101 9.03986 58.6981 8.8728 59.3962 8.8728C60.4105 8.8728 61.2039 9.1871 61.7765 9.8157C62.3546 10.4443 62.6436 11.3164 62.6436 12.432V18.4887H59.7397V13.0776C59.7397 12.5283 59.6007 12.1007 59.3225 11.7949C59.0499 11.4835 58.6654 11.3277 58.1692 11.3277C57.6784 11.3277 57.2803 11.4976 56.9749 11.8374C56.6695 12.1772 56.5168 12.6161 56.5168 13.1541V18.4887H53.6211Z" }), jsx("path", { d: "M53.097 9.03394L50.7412 18.4884H47.6164L46.1522 12.075H46.0949L44.6389 18.4884H41.5632L39.1992 9.03394H42.1195L43.3056 15.7532H43.3628L44.7861 9.03394H47.551L48.9906 15.7532H49.0479L50.234 9.03394H53.097Z" }), jsx("path", { d: "M37.8661 17.3926C37.0427 18.2591 35.9084 18.6923 34.4632 18.6923C33.0181 18.6923 31.8838 18.2591 31.0604 17.3926C30.2369 16.5205 29.8252 15.3086 29.8252 13.7569C29.8252 12.2336 30.2424 11.033 31.0767 10.1552C31.9111 9.2718 33.0399 8.83008 34.4632 8.83008C35.892 8.83008 37.0208 9.26896 37.8497 10.1467C38.6841 11.0188 39.1013 12.2222 39.1013 13.7569C39.1013 15.3143 38.6896 16.5262 37.8661 17.3926ZM33.2117 15.7702C33.5116 16.2402 33.9288 16.4752 34.4632 16.4752C34.9977 16.4752 35.4148 16.2402 35.7148 15.7702C36.0147 15.2945 36.1647 14.6234 36.1647 13.7569C36.1647 12.9131 36.012 12.2506 35.7066 11.7692C35.4012 11.2878 34.9868 11.0472 34.4632 11.0472C33.9343 11.0472 33.5171 11.2878 33.2117 11.7692C32.9118 12.2449 32.7618 12.9075 32.7618 13.7569C32.7618 14.6234 32.9118 15.2945 33.2117 15.7702Z" }), jsx("path", { d: "M20.0088 18.4887V9.0342H22.8227V10.8096H22.88C23.1254 10.181 23.4962 9.70244 23.9924 9.37398C24.4887 9.03986 25.0858 8.8728 25.7838 8.8728C26.7982 8.8728 27.5916 9.1871 28.1642 9.8157C28.7423 10.4443 29.0313 11.3164 29.0313 12.432V18.4887H26.1274V13.0776C26.1274 12.5283 25.9883 12.1007 25.7102 11.7949C25.4376 11.4835 25.0531 11.3277 24.5569 11.3277C24.0661 11.3277 23.668 11.4976 23.3626 11.8374C23.0572 12.1772 22.9045 12.6161 22.9045 13.1541V18.4887H20.0088Z" }), jsx("path", { d: "M14.7486 10.9707C14.2851 10.9707 13.8952 11.1321 13.5789 11.4549C13.2626 11.7777 13.0854 12.1911 13.0472 12.6951H16.4337C16.4064 12.1741 16.2374 11.7579 15.9265 11.4464C15.6212 11.1293 15.2285 10.9707 14.7486 10.9707ZM16.4991 15.5153H19.1167C18.9749 16.4837 18.5141 17.2567 17.7343 17.8343C16.9599 18.4063 15.9838 18.6923 14.8059 18.6923C13.3662 18.6923 12.2374 18.2591 11.4194 17.3926C10.6014 16.5262 10.1924 15.3313 10.1924 13.8079C10.1924 12.2845 10.5987 11.0755 11.4112 10.1807C12.2237 9.28029 13.3226 8.83008 14.7077 8.83008C16.0656 8.83008 17.1481 9.26047 17.9552 10.1213C18.7677 10.9764 19.174 12.1231 19.174 13.5616V14.4195H13.0145V14.6064C13.0145 15.184 13.1835 15.6541 13.5216 16.0165C13.8597 16.3733 14.3015 16.5517 14.8468 16.5517C15.2503 16.5517 15.5993 16.461 15.8938 16.2798C16.1883 16.0929 16.3901 15.8381 16.4991 15.5153Z" }), jsx("path", { d: "M3.00205 8.58396V12.0667H4.7771C5.32789 12.0667 5.7587 11.911 6.06954 11.5995C6.38038 11.2881 6.5358 10.8662 6.5358 10.3338C6.5358 9.80718 6.37492 9.38528 6.05318 9.06815C5.73143 8.74535 5.30335 8.58396 4.76892 8.58396H3.00205ZM3.00205 14.1989V18.4886H0V6.23096H5.07158C6.53307 6.23096 7.65373 6.5849 8.43355 7.29278C9.21337 8.00066 9.60328 8.99453 9.60328 10.2744C9.60328 11.0446 9.42605 11.7439 9.07159 12.3725C8.71712 12.9955 8.2236 13.4514 7.59101 13.7402L9.94684 18.4886H6.5767L4.55624 14.1989H3.00205Z" }), jsx("path", { d: "M65.7255 0.211478C65.0841 2.46724 63.3737 4.2455 61.2041 4.90969C60.932 4.99366 60.932 5.39096 61.2041 5.47492C63.3725 6.13912 65.0841 7.91738 65.7255 10.1731C65.8056 10.4551 66.1932 10.4551 66.2745 10.1731C66.9159 7.91738 68.6263 6.13912 70.7959 5.47492C71.068 5.39096 71.068 4.99366 70.7959 4.90969C68.6276 4.2455 66.9159 2.46724 66.2745 0.211478C66.1944 -0.0704925 65.8068 -0.0704925 65.7255 0.211478Z" })] });
}
function Ring(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M7.99853 2.60352C5.0532 2.60352 2.66519 4.99152 2.66519 7.93685C2.66519 10.8822 5.0532 13.2702 7.99853 13.2702C10.9439 13.2702 13.3319 10.8822 13.3319 7.93685C13.3319 4.99152 10.9439 2.60352 7.99853 2.60352ZM7.99853 3.93685C10.2079 3.93685 11.9985 5.72752 11.9985 7.93685C11.9985 10.1462 10.2079 11.9368 7.99853 11.9368C5.7892 11.9368 3.99853 10.1462 3.99853 7.93685C3.99853 5.72752 5.7892 3.93685 7.99853 3.93685Z" }) });
}
function Save(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M2 4.66667C2 3.194 3.194 2 4.66667 2H8.08333C7.64666 2.564 7.33333 3.23133 7.33333 4V8.66667H5.33333L8 11.3333L10.6667 8.66667H8.66666V4C8.66666 2.89533 9.562 2 10.6667 2H11.3333C12.806 2 14 3.194 14 4.66667V11.3333C14 12.806 12.806 14 11.3333 14H4.66667C3.194 14 2 12.806 2 11.3333V4.66667Z" }) });
}
function Search(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M10.0137 1.95312C5.59537 1.95312 2.01367 5.53513 2.01367 9.95314C2.01367 14.3712 5.59537 17.9532 10.0137 17.9532C11.8504 17.9532 13.5913 17.3222 14.9416 16.2822L19.2949 20.6722C19.6855 21.0622 20.3419 21.0622 20.7325 20.6722C21.123 20.2812 21.123 19.6252 20.7325 19.2342L16.349 14.8741C17.3898 13.5241 18.0137 11.7901 18.0137 9.95314C18.0137 5.53513 14.432 1.95312 10.0137 1.95312ZM10.0137 3.95313C13.3274 3.95313 16.0137 6.63914 16.0137 9.95314C16.0137 13.2672 13.3274 15.9532 10.0137 15.9532C6.69997 15.9532 4.01367 13.2672 4.01367 9.95314C4.01367 6.63914 6.69997 3.95313 10.0137 3.95313Z" }) });
}
function Server(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M11.998 1.95312C7.63605 1.95312 3.99805 3.51213 3.99805 5.95312C3.99805 8.39412 7.63605 9.95312 11.998 9.95312C16.36 9.95312 19.998 8.39412 19.998 5.95312C19.998 3.51213 16.36 1.95312 11.998 1.95312ZM3.99805 9.57812V11.9531C3.99805 14.3941 7.63605 15.9531 11.998 15.9531C16.36 15.9531 19.998 14.3941 19.998 11.9531V9.57812C18.184 11.0681 15.356 11.9531 11.998 11.9531C8.64005 11.9531 5.81205 11.0681 3.99805 9.57812ZM3.99805 15.5781V17.9531C3.99805 20.3941 7.63605 21.9531 11.998 21.9531C16.36 21.9531 19.998 20.3941 19.998 17.9531V15.5781C18.184 17.0681 15.356 17.9531 11.998 17.9531C8.64005 17.9531 5.81205 17.0681 3.99805 15.5781Z" }) });
}
function Settings(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: [jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.5 2C13.1894 2 13.8136 2.27905 14.2659 2.73036C14.2834 2.74784 14.3007 2.76559 14.3177 2.78358C14.7174 3.20678 14.971 3.76953 14.9977 4.39107L14.9985 4.41205C14.9995 4.44124 15 4.47056 15 4.5L15 4.51426C15 4.55491 15.0247 4.59145 15.0623 4.60702C15.0998 4.62261 15.1431 4.61423 15.1719 4.58546L15.182 4.57538C15.2028 4.55456 15.2239 4.53419 15.2452 4.51426L15.2607 4.5C15.719 4.07934 16.2962 3.86073 16.8782 3.84417C16.9029 3.84346 16.9277 3.84312 16.9524 3.84315C17.5913 3.84382 18.23 4.0879 18.7175 4.57538L19.4246 5.28249C19.9121 5.76997 20.1562 6.40868 20.1569 7.0476C20.1569 7.07234 20.1565 7.09709 20.1558 7.12182C20.1393 7.70375 19.9207 8.281 19.5 8.73935L19.4857 8.75476C19.4658 8.77611 19.4454 8.7972 19.4246 8.81802L19.4145 8.82811C19.3858 8.85687 19.3774 8.90017 19.393 8.93775C19.4085 8.97529 19.4451 9 19.4857 9L19.5 9C19.5294 9 19.5588 9.00051 19.5879 9.00152L19.6089 9.00233C20.2305 9.02898 20.7932 9.28257 21.2164 9.68233C21.2344 9.69933 21.2522 9.71659 21.2696 9.73411C21.721 10.1864 22 10.8106 22 11.5L22 12.5C22 13.1894 21.721 13.8136 21.2696 14.2659C21.2522 14.2834 21.2344 14.3007 21.2164 14.3177C20.7932 14.7174 20.2305 14.971 19.6089 14.9977L19.5879 14.9985C19.5588 14.9995 19.5294 15 19.5 15L19.4857 15C19.4451 15 19.4085 15.0247 19.393 15.0623C19.3774 15.0998 19.3858 15.1431 19.4145 15.1719L19.4246 15.182C19.4454 15.2028 19.4658 15.2239 19.4857 15.2452L19.5 15.2607C19.9207 15.719 20.1393 16.2962 20.1558 16.8782C20.1565 16.9029 20.1569 16.9277 20.1569 16.9524C20.1562 17.5913 19.9121 18.23 19.4246 18.7175L18.7175 19.4246C18.23 19.9121 17.5913 20.1562 16.9524 20.1568C16.9277 20.1569 16.9029 20.1565 16.8782 20.1558C16.2963 20.1393 15.719 19.9207 15.2607 19.5L15.2452 19.4857C15.2239 19.4658 15.2028 19.4454 15.182 19.4246L15.1719 19.4145C15.1431 19.3858 15.0998 19.3774 15.0623 19.393C15.0247 19.4085 15 19.4451 15 19.4857L15 19.5C15 19.5294 14.9995 19.5588 14.9985 19.5879L14.9977 19.6089C14.971 20.2305 14.7174 20.7932 14.3177 21.2164C14.3007 21.2344 14.2834 21.2522 14.2659 21.2696C13.8136 21.7209 13.1894 22 12.5 22L11.5 22C10.8106 22 10.1864 21.7209 9.73411 21.2696C9.71659 21.2522 9.69933 21.2344 9.68233 21.2164C9.28257 20.7932 9.02898 20.2305 9.00233 19.6089L9.00152 19.5879C9.00051 19.5588 9 19.5294 9 19.5L9 19.4857C9 19.4451 8.97529 19.4085 8.93774 19.393C8.90017 19.3774 8.85687 19.3858 8.8281 19.4145L8.81802 19.4246C8.7972 19.4454 8.77611 19.4658 8.75475 19.4857L8.73934 19.5C8.281 19.9207 7.70375 20.1393 7.12182 20.1558C7.09708 20.1565 7.07234 20.1569 7.0476 20.1568C6.40868 20.1562 5.76997 19.9121 5.28249 19.4246L4.57538 18.7175C4.0879 18.23 3.84382 17.5913 3.84315 16.9524C3.84312 16.9277 3.84346 16.9029 3.84417 16.8782C3.86073 16.2962 4.07934 15.719 4.5 15.2607L4.51426 15.2452C4.53419 15.2239 4.55456 15.2028 4.57538 15.182L4.58546 15.1719C4.61423 15.1431 4.62261 15.0998 4.60702 15.0623C4.59145 15.0247 4.55491 15 4.51426 15L4.5 15C4.47056 15 4.44125 14.9995 4.41205 14.9985L4.39107 14.9977C3.76953 14.971 3.20678 14.7174 2.78358 14.3177C2.76558 14.3007 2.74784 14.2834 2.73036 14.2659C2.27905 13.8136 2 13.1894 2 12.5L2 11.5C2 10.8106 2.27905 10.1864 2.73036 9.73411C2.74784 9.71659 2.76558 9.69933 2.78358 9.68233C3.20678 9.28257 3.76953 9.02898 4.39107 9.00233L4.41205 9.00152C4.44125 9.00051 4.47056 9 4.5 9L4.51426 9C4.55491 9 4.59145 8.97529 4.60702 8.93775C4.62261 8.90017 4.61423 8.85687 4.58546 8.82811L4.57538 8.81802C4.55456 8.7972 4.53419 8.77611 4.51426 8.75476L4.5 8.73935C4.07934 8.281 3.86073 7.70375 3.84417 7.12182C3.84346 7.09709 3.84312 7.07234 3.84315 7.0476C3.84382 6.40868 4.0879 5.76997 4.57538 5.28249L5.28249 4.57538C5.76997 4.0879 6.40868 3.84382 7.0476 3.84315C7.07234 3.84312 7.09709 3.84346 7.12182 3.84417C7.70375 3.86073 8.281 4.07934 8.73934 4.5L8.75476 4.51426C8.77611 4.53419 8.7972 4.55456 8.81802 4.57538L8.8281 4.58546C8.85687 4.61423 8.90017 4.62261 8.93775 4.60702C8.97529 4.59145 9 4.55491 9 4.51426L9 4.5C9 4.47056 9.00051 4.44124 9.00152 4.41205L9.00233 4.39107C9.02898 3.76953 9.28257 3.20678 9.68233 2.78358C9.69933 2.76559 9.71659 2.74784 9.73411 2.73036C10.1864 2.27905 10.8106 2 11.5 2L12.5 2ZM11 19.5C11 19.7761 11.2239 20 11.5 20L12.5 20C12.7761 20 13 19.7761 13 19.5L13 19.4857C13 18.6262 13.5212 17.8669 14.2962 17.5455C15.0727 17.2235 15.9787 17.3929 16.5861 18.0003L16.5962 18.0104C16.7915 18.2057 17.108 18.2057 17.3033 18.0104L18.0104 17.3033C18.2057 17.108 18.2057 16.7915 18.0104 16.5962L18.0003 16.5861C17.3929 15.9787 17.2235 15.0727 17.5455 14.2961C17.8669 13.5212 18.6262 13 19.4857 13L19.5 13C19.7761 13 20 12.7761 20 12.5L20 11.5C20 11.2239 19.7761 11 19.5 11L19.4857 11C18.6262 11 17.8669 10.4788 17.5455 9.70385C17.2235 8.92727 17.3929 8.02132 18.0003 7.41389L18.0104 7.40381C18.2057 7.20854 18.2057 6.89196 18.0104 6.6967L17.3033 5.98959C17.108 5.79433 16.7915 5.79433 16.5962 5.98959L16.5861 5.99968C15.9787 6.60711 15.0727 6.77651 14.2962 6.45448C13.5212 6.13311 13 5.37381 13 4.51426L13 4.5C13 4.22386 12.7761 4 12.5 4L11.5 4C11.2239 4 11 4.22386 11 4.5L11 4.51426C11 5.37381 10.4788 6.13311 9.70384 6.45448C8.92725 6.77651 8.02132 6.60711 7.41389 5.99968L7.40381 5.98959C7.20854 5.79433 6.89196 5.79433 6.6967 5.98959L5.98959 6.6967C5.79433 6.89196 5.79433 7.20854 5.98959 7.40381L5.99967 7.41389C6.60711 8.02132 6.77651 8.92727 6.45448 9.70385C6.13311 10.4788 5.37382 11 4.51426 11L4.5 11C4.22386 11 4 11.2239 4 11.5L4 12.5C4 12.7761 4.22386 13 4.5 13L4.51426 13C5.37382 13 6.13311 13.5212 6.45447 14.2961C6.77651 15.0727 6.60711 15.9787 5.99968 16.5861L5.98959 16.5962C5.79433 16.7915 5.79433 17.108 5.98959 17.3033L6.6967 18.0104C6.89196 18.2057 7.20854 18.2057 7.4038 18.0104L7.41389 18.0003C8.02132 17.3929 8.92726 17.2235 9.70384 17.5455C10.4788 17.8669 11 18.6262 11 19.4857L11 19.5Z" }), jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 14C13.1046 14 14 13.1046 14 12C14 10.8954 13.1046 10 12 10C10.8954 10 10 10.8954 10 12C10 13.1046 10.8954 14 12 14ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16Z" })] });
}
function Synced(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M8.01042 1.3418C4.32842 1.3418 1.34375 4.3266 1.34375 8.00847C1.34375 11.6905 4.32842 14.6751 8.01042 14.6751C11.6924 14.6751 14.6771 11.6905 14.6771 8.00847C14.6771 4.3266 11.6924 1.3418 8.01042 1.3418ZM8.01042 4.67513C8.37842 4.67513 8.67708 4.9736 8.67708 5.3418V8.67514H10.6771L8.01042 11.3418L5.34375 8.67514H7.34375V5.3418C7.34375 4.9736 7.64242 4.67513 8.01042 4.67513Z" }) });
}
function Syncing(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M7.81333 1.33662C6.07787 1.38545 4.42992 2.10935 3.21991 3.35437C2.0099 4.59939 1.3333 6.26732 1.33398 8.00346C1.33478 9.7711 2.03752 11.4661 3.28771 12.7157C4.5379 13.9653 6.23319 14.6673 8.00083 14.6673C9.76847 14.6673 11.4638 13.9653 12.714 12.7157C13.9641 11.4661 14.6669 9.7711 14.6677 8.00346C14.668 7.11195 14.4896 6.22943 14.1429 5.4081C13.7962 4.58678 13.2883 3.84332 12.6492 3.22173C12.0101 2.60015 11.2529 2.11306 10.4222 1.78926C9.59161 1.46547 8.70448 1.31155 7.81333 1.33662ZM8.00083 4.67003C8.92086 4.67003 9.75038 5.00753 10.3551 5.60755L11.3343 4.67003V7.33679H11.2718H10.2093H8.66755L9.62591 6.33676C9.21457 5.93674 8.64705 5.67005 8.0217 5.67005C6.98901 5.67005 6.13082 6.4034 5.83414 7.33679H4.72995C5.04062 5.80341 6.39012 4.67003 8.00083 4.67003ZM4.66741 8.67016H4.72988H5.79241H7.33412L6.37576 9.60768C6.7871 10.0077 7.35461 10.2744 7.97997 10.2744C9.01266 10.2744 9.87085 9.60351 10.1675 8.67016H11.2717C10.961 10.1368 9.61151 11.3369 8.0008 11.3369C7.08078 11.3369 6.25125 10.9369 5.64657 10.3369L4.66738 11.3369L4.66741 8.67016Z" }) });
}
function Tabler(props) {
  return jsxs("svg", { ...props, width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M4.5 9V7.5C4.5 6.30653 4.97411 5.16193 5.81802 4.31802C6.66193 3.47411 7.80653 3 9 3C10.1935 3 11.3381 3.47411 12.182 4.31802C13.0259 5.16193 13.5 6.30653 13.5 7.5V9M3 13.5C3 13.8978 3.15804 14.2794 3.43934 14.5607C3.72064 14.842 4.10218 15 4.5 15C4.89782 15 5.27936 14.842 5.56066 14.5607C5.84196 14.2794 6 13.8978 6 13.5C6 13.1022 5.84196 12.7206 5.56066 12.4393C5.27936 12.158 4.89782 12 4.5 12C4.10218 12 3.72064 12.158 3.43934 12.4393C3.15804 12.7206 3 13.1022 3 13.5ZM12 13.5C12 13.8978 12.158 14.2794 12.4393 14.5607C12.7206 14.842 13.1022 15 13.5 15C13.8978 15 14.2794 14.842 14.5607 14.5607C14.842 14.2794 15 13.8978 15 13.5C15 13.1022 14.842 12.7206 14.5607 12.4393C14.2794 12.158 13.8978 12 13.5 12C13.1022 12 12.7206 12.158 12.4393 12.4393C12.158 12.7206 12 13.1022 12 13.5Z", stroke: "currentcolor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), jsx("path", { d: "M11.25 6.75L13.5 9L15.75 6.75", stroke: "currentcolor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })] });
}
function TrashFill(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M11.9981 4.46484C11.1693 4.46484 10.4981 5.13609 10.4981 5.96484H6.74805C6.33405 5.96484 5.99805 6.30084 5.99805 6.71484C5.99805 7.12884 6.33405 7.46483 6.74805 7.46483H17.2481C17.6621 7.46483 17.9981 7.12884 17.9981 6.71484C17.9981 6.30084 17.6621 5.96484 17.2481 5.96484H13.4981C13.4981 5.13609 12.8268 4.46484 11.9981 4.46484ZM6.74805 8.96483V16.4648C6.74805 18.1073 8.1018 19.4415 9.74805 19.4415L14.2713 19.4648C15.9176 19.4648 17.2481 18.1111 17.2481 16.4648V8.96483H6.74805ZM10.4981 11.2148C10.9121 11.2148 11.2481 11.5508 11.2481 11.9648V16.4648C11.2481 16.8788 10.9121 17.2148 10.4981 17.2148C10.0841 17.2148 9.74805 16.8788 9.74805 16.4648V11.9648C9.74805 11.5508 10.0841 11.2148 10.4981 11.2148ZM13.4981 11.2148C13.9121 11.2148 14.2481 11.5508 14.2481 11.9648V16.4648C14.2481 16.8788 13.9121 17.2148 13.4981 17.2148C13.0841 17.2148 12.7481 16.8788 12.7481 16.4648V11.9648C12.7481 11.5508 13.0841 11.2148 13.4981 11.2148Z" }) });
}
function Trash(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M7.99935 1.30273C7.26269 1.30273 6.66602 1.8994 6.66602 2.63606H3.33268C2.96468 2.63606 2.66602 2.93473 2.66602 3.30273C2.66602 3.67073 2.96468 3.96939 3.33268 3.96939H12.666C13.034 3.96939 13.3327 3.67073 13.3327 3.30273C13.3327 2.93473 13.034 2.63606 12.666 2.63606H9.33269C9.33269 1.8994 8.73602 1.30273 7.99935 1.30273ZM3.33268 5.30272V11.9694C3.33268 13.4294 4.53602 14.6154 5.99935 14.6154L10.02 14.636C11.4834 14.636 12.666 13.4327 12.666 11.9694V5.30272H3.33268ZM6.66602 7.30272C7.03402 7.30272 7.33269 7.60138 7.33269 7.96938V11.9694C7.33269 12.3374 7.03402 12.636 6.66602 12.636C6.29802 12.636 5.99935 12.3374 5.99935 11.9694V7.96938C5.99935 7.60138 6.29802 7.30272 6.66602 7.30272ZM9.33269 7.30272C9.70069 7.30272 9.99936 7.60138 9.99936 7.96938V11.9694C9.99936 12.3374 9.70069 12.636 9.33269 12.636C8.96469 12.636 8.66602 12.3374 8.66602 11.9694V7.96938C8.66602 7.60138 8.96469 7.30272 9.33269 7.30272Z" }) });
}
function TreeViewSlash(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M10 8.5V8H5.5V12C5.5 12.1326 5.55268 12.2598 5.64645 12.3536C5.74021 12.4473 5.86739 12.5 6 12.5H10V12C10 11.7348 10.1054 11.4804 10.2929 11.2929C10.4804 11.1054 10.7348 11 11 11H13C13.2652 11 13.5196 11.1054 13.7071 11.2929C13.8946 11.4804 14 11.7348 14 12V14C14 14.2652 13.8946 14.5196 13.7071 14.7071C13.5196 14.8946 13.2652 15 13 15H11C10.7348 15 10.4804 14.8946 10.2929 14.7071C10.1054 14.5196 10 14.2652 10 14V13.5H6C5.60218 13.5 5.22064 13.342 4.93934 13.0607C4.65804 12.7794 4.5 12.3978 4.5 12V5H4C3.73478 5 3.48043 4.89464 3.29289 4.70711C3.10536 4.51957 3 4.26522 3 4V2C3 1.73478 3.10536 1.48043 3.29289 1.29289C3.48043 1.10536 3.73478 1 4 1H6C6.26522 1 6.51957 1.10536 6.70711 1.29289C6.89464 1.48043 7 1.73478 7 2V4C7 4.26522 6.89464 4.51957 6.70711 4.70711C6.51957 4.89464 6.26522 5 6 5H5.5V7H10V6.5C10 6.23478 10.1054 5.98043 10.2929 5.79289C10.4804 5.60536 10.7348 5.5 11 5.5H13C13.2652 5.5 13.5196 5.60536 13.7071 5.79289C13.8946 5.98043 14 6.23478 14 6.5V8.5C14 8.76522 13.8946 9.01957 13.7071 9.20711C13.5196 9.39464 13.2652 9.5 13 9.5H11C10.7348 9.5 10.4804 9.39464 10.2929 9.20711C10.1054 9.01957 10 8.76522 10 8.5Z", fill: "currentcolor" }), jsx("line", { x1: "1.93934", y1: "13.5858", x2: "14.2946", y2: "1.23053", stroke: "#FCFCFC", strokeWidth: "3" }), jsx("path", { d: "M2.04419 13.5317L13.5758 2.00013", stroke: "currentcolor", strokeLinecap: "round" })] });
}
function TriangleDown(props) {
  return jsx("svg", { ...props, width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("g", { id: "Triangle Down", children: jsx("path", { id: "Shape", d: "M4.7998 7.20001H13.1998L8.9998 12.6L4.7998 7.20001Z", fill: "currentColor" }) }) });
}
function Tube(props) {
  return jsxs("svg", { ...props, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsx("path", { d: "M21.2247 30H10.7906C5.09802 30 3.97038 26.6304 5.81808 22.5283L7.77448 18.1731C7.77448 18.1731 11.9318 18.0133 16.0076 19.3452C20.0834 20.677 23.9283 18.1598 23.9283 18.1598L24.1864 18L26.2108 22.5416C28.0313 26.6437 26.8357 30 21.2247 30Z", fill: "currentcolor" }), jsx("path", { d: "M20.6368 8.58926H20.421L23.2936 15.3453L22.7407 15.7068C22.7137 15.7207 19.6658 17.7364 16.6313 16.7077C13.462 15.6095 10.2792 15.4148 8.71478 15.387L11.6009 8.58926H11.1963C10.3197 8.58926 9.51048 8.22783 8.93056 7.63007C8.35065 7.03231 8 6.19822 8 5.29463C8 3.48745 9.42956 2 11.1963 2H20.7851C21.6752 2 22.4709 2.37534 23.0508 2.9731C23.8061 3.75158 24.1972 4.89149 23.9005 6.10091C23.5498 7.60226 22.1472 8.58926 20.6368 8.58926Z", fill: "currentcolor" })] });
}
function VariantArrowLeft(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M4.09245 12.0893L4 11.9998L4.09245 11.9103L4.66414 11.3568L4.66493 11.356L9.81374 6.37154C10.1808 6.01623 10.7758 6.01623 11.1428 6.37154C11.5098 6.72685 11.5098 7.30291 11.1428 7.65822L7.59798 11.09L19.0602 11.09C19.5792 11.09 20 11.4973 20 11.9998C20 12.5023 19.5792 12.9096 19.0602 12.9096L7.59798 12.9096L11.1428 16.3413C11.5098 16.6967 11.5098 17.2727 11.1428 17.628C10.7758 17.9834 10.1808 17.9834 9.81375 17.628L4.66493 12.6435L4.66414 12.6427L4.09245 12.0893Z" }) });
}
function VerticalDots(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M14.0098 3.95312C14.0098 2.84812 13.1144 1.95312 12.0098 1.95312C10.9052 1.95312 10.0098 2.84812 10.0098 3.95312C10.0098 5.05812 10.9052 5.95311 12.0098 5.95311C13.1144 5.95311 14.0098 5.05812 14.0098 3.95312ZM14.0098 11.9531C14.0098 10.8481 13.1144 9.9531 12.0098 9.9531C10.9052 9.9531 10.0098 10.8481 10.0098 11.9531C10.0098 13.0581 10.9052 13.9531 12.0098 13.9531C13.1144 13.9531 14.0098 13.0581 14.0098 11.9531ZM14.0098 19.9531C14.0098 18.8481 13.1144 17.9531 12.0098 17.9531C10.9052 17.9531 10.0098 18.8481 10.0098 19.9531C10.0098 21.0581 10.9052 21.9531 12.0098 21.9531C13.1144 21.9531 14.0098 21.0581 14.0098 19.9531Z" }) });
}
function WarningFill(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { d: "M12 3C7.0293 3 3 7.0293 3 12C3 16.9707 7.0293 21 12 21C16.9707 21 21 16.9707 21 12C21 7.0293 16.9707 3 12 3ZM12 7.5C12.4968 7.5 12.9 7.9032 12.9 8.4V12.9C12.9 13.3968 12.4968 13.8 12 13.8C11.5032 13.8 11.1 13.3968 11.1 12.9V8.4C11.1 7.9032 11.5032 7.5 12 7.5ZM12 14.7C12.4968 14.7 12.9 15.1032 12.9 15.6C12.9 16.0968 12.4968 16.5 12 16.5C11.5032 16.5 11.1 16.0968 11.1 15.6C11.1 15.1032 11.5032 14.7 12 14.7Z" }) });
}
function XTwitter(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { d: "M11.1823 2.99902H12.8787L9.17256 7.23492L13.5326 12.999H10.1182L7.44435 9.50313L4.38487 12.999H2.68743L6.65153 8.46825L2.46948 2.99902H5.96948L8.38641 6.19441L11.1823 2.99902ZM10.5869 11.9836H11.5269L5.45923 3.96107H4.45051L10.5869 11.9836Z", fill: "currentcolor" }) });
}
function XmarkLight(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "currentcolor", children: jsx("path", { d: "M3.32875 2.60352C3.15815 2.60352 2.97975 2.66085 2.84955 2.79085C2.58921 3.05152 2.58921 3.48884 2.84955 3.74951L7.03708 7.93685L2.84955 12.1242C2.58921 12.3849 2.58921 12.8222 2.84955 13.0828C3.10995 13.3428 3.54755 13.3428 3.80795 13.0828L7.99541 8.89552L12.1829 13.0828C12.4433 13.3428 12.8809 13.3428 13.1413 13.0828C13.4016 12.8222 13.4016 12.3849 13.1413 12.1242L8.95375 7.93685L13.1413 3.74951C13.4016 3.48884 13.4016 3.05152 13.1413 2.79085C13.0111 2.66085 12.8326 2.60352 12.6621 2.60352C12.4915 2.60352 12.3131 2.66085 12.1829 2.79085L7.99541 6.97818L3.80795 2.79085C3.67775 2.66085 3.49935 2.60352 3.32875 2.60352Z" }) });
}
function Xmark(props) {
  return jsx("svg", { ...props, viewBox: "0 0 24 24", fill: "currentcolor", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.9993 8.51506L15.4844 7L11.9994 10.4852L8.51497 7.00057L7 8.51562L10.4844 12.0003L7.00056 15.4843L8.51552 16.9994L11.9994 13.5153L15.4838 17L16.9988 15.4849L13.5144 12.0003L16.9993 8.51506Z" }) });
}
function Youtube(props) {
  return jsx("svg", { ...props, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.9069 4.70801C12.3372 4.823 12.676 5.16182 12.791 5.5921C13 6.37194 13 7.99903 13 7.99903C13 7.99903 13 9.62613 12.791 10.406C12.676 10.8362 12.3372 11.1751 11.9069 11.2901C11.1271 11.499 8 11.499 8 11.499C8 11.499 4.87291 11.499 4.09306 11.2901C3.66282 11.1751 3.32395 10.8362 3.20896 10.406C3 9.62613 3 7.99903 3 7.99903C3 7.99903 3 6.37194 3.20896 5.5921C3.32395 5.16182 3.66282 4.823 4.09306 4.70801C4.87291 4.49902 8 4.49902 8 4.49902C8 4.49902 11.1271 4.49902 11.9069 4.70801ZM9.59094 7.99912L6.97729 9.47629V6.52177L9.59094 7.99912Z", fill: "currentcolor" }) });
}
const iconComponents = {
  CalendarTime,
  CaretLeft,
  CaretRight,
  ArrowFilledRight,
  ArrowLeft,
  ArrowUp,
  BarChart,
  BaseArrowLeft,
  BaseArrowRight,
  Braces,
  Branch,
  BrickGlobe,
  Briefcase,
  Calendar,
  CaretDown,
  CaretSort,
  Caret,
  CheckCircleFill,
  CheckCircle,
  Check,
  Checkmark,
  ChevronDown,
  CircleInfo,
  Circle,
  ClockFill,
  Clock,
  CloudSlash,
  Collapse,
  Compass,
  ConnectSmall,
  Connect,
  Copy,
  Created,
  CrossCircle,
  Danger,
  DescendenceModified,
  Disconnect,
  Discord,
  DownloadFile,
  Drive,
  Duplicated,
  Edit,
  Ellipsis,
  Error: Error$1,
  Ethscan,
  Exclamation,
  ExportCsv,
  ExportJson,
  ExportPdf,
  ExportUbl,
  ExportZip,
  File,
  FilesEarmark,
  FolderClose,
  FolderOpen,
  FolderPlus,
  Forum,
  Gear,
  Github,
  GlobeWww,
  Globe,
  Hdd,
  History,
  InfoSquare,
  Link,
  Linkedin,
  Lock,
  M,
  Modified,
  Moved,
  PackageManager,
  Pencil,
  PeopleFill,
  People,
  Person,
  PinFilled,
  Pin,
  PlusCircle,
  PlusSquare,
  Plus,
  PowerhouseLogoSmall,
  Project,
  QuestionSquare,
  RedoArrow,
  Reload,
  Removed,
  RenownHover,
  RenownLight,
  Renown,
  Ring,
  Save,
  Search,
  Server,
  Settings,
  Synced,
  Syncing,
  Tabler,
  TrashFill,
  Trash,
  TreeViewSlash,
  TriangleDown,
  Tube,
  VariantArrowLeft,
  VerticalDots,
  WarningFill,
  XTwitter,
  XmarkLight,
  Xmark,
  Youtube
};
function Icon({ name: name2, size = 24, color, style, ...props }) {
  const dimensions = getDimensions(size);
  const _style = {
    color,
    ...dimensions,
    style
  };
  const IconComponent = iconComponents[name2];
  return (
    // displays div with the same size while icon
    // loads to avoid UI displacement
    jsx(Suspense, { fallback: jsx("div", { "data-testid": "icon-fallback", style: dimensions }), name: "icon-component", children: jsx(IconComponent, { ...props, style: _style }) })
  );
}
function getDimensions(size) {
  if (!size)
    return {};
  if (typeof size === "number") {
    return {
      width: size.toString() + "px",
      height: size.toString() + "px"
    };
  }
  return {
    width: size,
    height: size
  };
}
const SWITCHBOARD = "SWITCHBOARD";
const LOCAL = "LOCAL";
const CLOUD = "CLOUD";
const PUBLIC = "PUBLIC";
const DRIVE = "DRIVE";
const FOLDER = "FOLDER";
const FILE = "FILE";
const WRITE = "WRITE";
const READ = "READ";
const UI_NODE = "UI_NODE";
const DUPLICATE = "DUPLICATE";
const NEW_FOLDER = "NEW_FOLDER";
const RENAME = "RENAME";
const DELETE = "DELETE";
const SETTINGS = "SETTINGS";
const REMOVE_TRIGGER = "REMOVE_TRIGGER";
const ADD_TRIGGER = "ADD_TRIGGER";
const ADD_INVALID_TRIGGER = "ADD_INVALID_TRIGGER";
const defaultDriveOptions = [NEW_FOLDER, RENAME, SETTINGS];
const defaultFileOptions = [RENAME, DELETE, DUPLICATE];
const defaultFolderOptions = [
  NEW_FOLDER,
  RENAME,
  DELETE,
  DUPLICATE
];
const debugNodeOptions = [
  ADD_TRIGGER,
  REMOVE_TRIGGER,
  ADD_INVALID_TRIGGER
];
const sharingTypeOptions = [
  {
    value: LOCAL,
    icon: jsx(Icon, { name: "Lock" }),
    description: "Only available to you"
  },
  {
    value: CLOUD,
    icon: jsx(Icon, { name: "People" }),
    description: "Only available to people in this drive"
  },
  {
    value: PUBLIC,
    icon: jsx(Icon, { name: "Globe" }),
    description: "Available to everyone",
    disabled: true
  }
];
const locationInfoByLocation = {
  CLOUD: {
    title: "Secure cloud",
    description: "End to end encryption between members.",
    icon: jsx(Icon, { name: "Lock" })
  },
  LOCAL: {
    title: "Local",
    description: "Private and only available to you.",
    icon: jsx(Icon, { name: "Hdd" })
  },
  SWITCHBOARD: {
    title: "Switchboard",
    description: "Public and available to everyone.",
    icon: jsx(Icon, { name: "Drive" })
  }
};
const debugNodeOptionsMap = {
  [ADD_TRIGGER]: {
    label: "Add Trigger",
    icon: jsx(Icon, { className: "text-orange-900", name: "Plus" })
  },
  [REMOVE_TRIGGER]: {
    label: "Remove Trigger",
    icon: jsx(Icon, { className: "text-orange-900", name: "Xmark" })
  },
  [ADD_INVALID_TRIGGER]: {
    label: "Add Trigger",
    icon: jsx(Icon, { className: "text-orange-900", name: "Exclamation" })
  }
};
const normalNodeOptionsMap = {
  [DUPLICATE]: {
    label: "Duplicate",
    icon: jsx(Icon, { name: "FilesEarmark" })
  },
  [NEW_FOLDER]: {
    label: "New Folder",
    icon: jsx(Icon, { name: "FolderPlus" })
  },
  [RENAME]: {
    label: "Rename",
    icon: jsx(Icon, { name: "Pencil" })
  },
  [DELETE]: {
    label: "Delete",
    icon: jsx(Icon, { name: "Trash" }),
    className: "text-red-900"
  },
  [SETTINGS]: {
    label: "Settings",
    icon: jsx(Icon, { name: "Gear" })
  }
};
const nodeOptionsMap = {
  ...debugNodeOptionsMap,
  ...normalNodeOptionsMap
};
const name = "@powerhousedao/connect";
const productName = "Powerhouse-Connect";
const version$1 = "1.0.8";
const description = "Powerhouse Connect";
const main = "./dist/index.html";
const type = "module";
const engines = { "node": ">=20.0.0" };
const files$1 = ["dist", "nginx.conf", "nginx.sh", "scripts"];
const license = "AGPL-3.0-only";
const author = "acaldas@powerhouse.inc";
const repository = { "type": "git", "url": "git+https://github.com/powerhouse-inc/document-model-electron.git" };
const bugs = { "url": "https://github.com/powerhouse-inc/document-model-electron/issues" };
const homepage = "https://github.com/powerhouse-inc/document-model-electron#readme";
const scripts = { "build:tsc": "tsc --build", "start": "electron-forge start", "package": "electron-forge package", "make": "PH_CONNECT_BASE_HREF=./ electron-forge make", "make:mac": "PH_CONNECT_BASE_HREF=./ electron-forge make -p darwin", "make:linux": "PH_CONNECT_BASE_HREF=./ electron-forge make -p linux", "make:windows": "PH_CONNECT_BASE_HREF=./ electron-forge make -p win32", "publish:electron": "electron-forge publish", "prepublishOnly": "npm run build", "lint": "eslint .", "lint:fix": "eslint --fix .", "lint:nx": "eslint --quiet --fix .", "format": 'prettier --write "**/*.+(js|ts|jsx|tsx|json)"', "dev": "vite -c vite.renderer.config.mts", "dev:nocache": "rm -rf node_modules/.vite && rm -rf node_modules/.cache && npm run dev", "prebuild": "tsc --build --noEmit", "build": "NODE_OPTIONS=--max-old-space-size=6144 vite build -c vite.renderer.config.mts", "preview:web": "vite preview -c vite.renderer.config.mts", "e2e": "playwright test", "cy:open": "cypress open", "build:service-worker": "tsc --build ./tsconfig.sw.json" };
const devDependencies = { "@electron-forge/cli": "^6.1.1", "@electron-forge/maker-deb": "^6.1.1", "@electron-forge/maker-rpm": "^6.1.1", "@electron-forge/maker-squirrel": "^6.1.1", "@electron-forge/maker-zip": "^6.1.1", "@electron-forge/plugin-vite": "^6.1.1", "@electron-forge/publisher-electron-release-server": "^6.2.1", "@electron-forge/publisher-github": "^7.2.0", "@electron-forge/shared-types": "^7.7.0", "@playwright/test": "^1.41.2", "@powerhousedao/builder-tools": "workspace:*", "@powerhousedao/common": "workspace:*", "@powerhousedao/config": "workspace:*", "@powerhousedao/design-system": "workspace:*", "@powerhousedao/reactor-browser": "workspace:*", "@powerhousedao/scalars": "workspace:*", "@rollup/plugin-node-resolve": "^15.2.3", "@sentry/browser": "^9.1.0", "@sentry/react": "^7.109.0", "@sentry/vite-plugin": "^2.22.2", "@tailwindcss/vite": "^4.0.9", "@tanstack/react-virtual": "^3.8.1", "@types/node": "^22.13.10", "@types/react": "^18.2.79", "@types/react-dom": "^18.2.18", "@types/uuid": "^9.0.7", "@types/wicg-file-system-access": "^2020.9.6", "@vitejs/plugin-basic-ssl": "^1.2.0", "@vitejs/plugin-react": "^4.2.1", "asar": "^3.2.0", "did-key-creator": "^1.2.0", "document-drive": "workspace:*", "document-model": "workspace:*", "electron": "30.0.0", "electron-is-dev": "^3.0.1", "electron-playwright-helpers": "^1.7.1", "electron-squirrel-startup": "^1.0.0", "electron-store": "^8.1.0", "esbuild": "^0.24.0", "graphql": "^16.8.1", "graphql-request": "^6.1.0", "i18next": "^23.7.6", "jotai": "^2.1.0", "jotai-effect": "^1.1.6", "localforage": "^1.10.0", "lz-string": "^1.5.0", "playwright": "^1.41.2", "playwright-core": "^1.41.2", "react": "^18.2.0", "react-dom": "^18.2.0", "react-error-boundary": "^4.0.11", "react-hotkeys-hook": "^4.5.0", "react-i18next": "^13.5.0", "react-router-dom": "^6.11.2", "tailwind-merge": "^3.0.2", "tailwindcss": "^4.0.9", "uuid": "^9.0.1", "viem": "^2.8.13", "vite": "^6.2.2", "vite-envs": "^4.4.11", "vite-plugin-html": "^3.2.2", "vite-plugin-node-polyfills": "^0.23.0", "vite-plugin-svgr": "^4.2.0", "vite-tsconfig-paths": "^4.3.2", "xvfb-maybe": "^0.2.1" };
const optionalDependencies = { "@esbuild/linux-x64": "^0.21.4", "@rollup/rollup-linux-x64-musl": "4.14.3" };
const packageJson = {
  name,
  productName,
  version: version$1,
  description,
  main,
  type,
  engines,
  files: files$1,
  license,
  author,
  repository,
  bugs,
  homepage,
  scripts,
  devDependencies,
  optionalDependencies
};
const version = packageJson.version;
const APP_VERSION = window.__VITE_ENVS.APP_VERSION || version;
const WARN_OUTDATED_APP = window.__VITE_ENVS.PH_CONNECT_WARN_OUTDATED_APP || "false";
const PH_CONNECT_STUDIO_MODE = window.__VITE_ENVS.PH_CONNECT_STUDIO_MODE || "false";
const DISABLE_ADD_PUBLIC_DRIVES = window.__VITE_ENVS.PH_CONNECT_DISABLE_ADD_PUBLIC_DRIVES || void 0;
const DISABLE_ADD_CLOUD_DRIVES = window.__VITE_ENVS.PH_CONNECT_DISABLE_ADD_CLOUD_DRIVES || void 0;
const DISABLE_ADD_LOCAL_DRIVES = window.__VITE_ENVS.PH_CONNECT_DISABLE_ADD_LOCAL_DRIVES || void 0;
const DISABLE_DELETE_PUBLIC_DRIVES = window.__VITE_ENVS.PH_CONNECT_DISABLE_DELETE_PUBLIC_DRIVES || void 0;
const DISABLE_DELETE_CLOUD_DRIVES = window.__VITE_ENVS.PH_CONNECT_DISABLE_DELETE_CLOUD_DRIVES || void 0;
const DISABLE_DELETE_LOCAL_DRIVES = window.__VITE_ENVS.PH_CONNECT_DISABLE_DELETE_LOCAL_DRIVES || void 0;
const LOCAL_DRIVES_ENABLED = window.__VITE_ENVS.PH_CONNECT_LOCAL_DRIVES_ENABLED || void 0;
const CLOUD_DRIVES_ENABLED = window.__VITE_ENVS.PH_CONNECT_CLOUD_DRIVES_ENABLED || void 0;
const PUBLIC_DRIVES_ENABLED = window.__VITE_ENVS.PH_CONNECT_PUBLIC_DRIVES_ENABLED || void 0;
const SEARCH_BAR_ENABLED = window.__VITE_ENVS.PH_CONNECT_SEARCH_BAR_ENABLED || void 0;
const HIDE_DOCUMENT_MODEL_SELECTION_SETTINGS = window.__VITE_ENVS.PH_CONNECT_HIDE_DOCUMENT_MODEL_SELECTION_SETTINGS || "false";
const PH_CONNECT_ROUTER_BASENAME = window.__VITE_ENVS.PH_CONNECT_ROUTER_BASENAME || "/";
const PH_CONNECT_SENTRY_DSN = window.__VITE_ENVS.PH_CONNECT_SENTRY_DSN || "";
const PH_CONNECT_SENTRY_ENV = window.__VITE_ENVS.PH_CONNECT_SENTRY_ENV || "dev";
const PH_CONNECT_SENTRY_TRACING_ENABLED = window.__VITE_ENVS.PH_CONNECT_SENTRY_TRACING_ENABLED || "false";
const GA_TRACKING_ID = window.__VITE_ENVS.PH_CONNECT_GA_TRACKING_ID;
const PH_CONNECT_CLI_VERSION = window.__VITE_ENVS.PH_CONNECT_CLI_VERSION || void 0;
setLogLevel(window.__VITE_ENVS.LOG_LEVEL);
logger$1.info(`Setting log level to ${window.__VITE_ENVS.LOG_LEVEL}.`);
const connectConfig = {
  appVersion: APP_VERSION,
  studioMode: PH_CONNECT_STUDIO_MODE.toString() === "true",
  warnOutdatedApp: WARN_OUTDATED_APP === "true",
  routerBasename: PH_CONNECT_ROUTER_BASENAME,
  sentry: {
    dsn: PH_CONNECT_SENTRY_DSN,
    env: PH_CONNECT_SENTRY_ENV,
    tracing: PH_CONNECT_SENTRY_TRACING_ENABLED === "true"
  },
  content: {
    showSearchBar: SEARCH_BAR_ENABLED !== "false",
    showDocumentModelSelectionSetting: HIDE_DOCUMENT_MODEL_SELECTION_SETTINGS !== "true"
  },
  drives: {
    sections: {
      [LOCAL]: {
        enabled: LOCAL_DRIVES_ENABLED !== "false",
        allowAdd: DISABLE_ADD_LOCAL_DRIVES !== "true",
        allowDelete: DISABLE_DELETE_LOCAL_DRIVES !== "true"
      },
      [CLOUD]: {
        enabled: CLOUD_DRIVES_ENABLED !== "false",
        allowAdd: DISABLE_ADD_CLOUD_DRIVES !== "true",
        allowDelete: DISABLE_DELETE_CLOUD_DRIVES !== "true"
      },
      [PUBLIC]: {
        enabled: PUBLIC_DRIVES_ENABLED !== "false",
        allowAdd: DISABLE_ADD_PUBLIC_DRIVES !== "true",
        allowDelete: DISABLE_DELETE_PUBLIC_DRIVES !== "true"
      }
    }
  },
  gaTrackingId: GA_TRACKING_ID,
  phCliVersion: PH_CONNECT_CLI_VERSION
};
const connectDebug = localStorage.getItem("CONNECT_DEBUG") === "true";
const DriveSections = [
  { sharingType: PUBLIC, label: "Public Drives" },
  { sharingType: CLOUD, label: "Secure Cloud Drives" },
  { sharingType: LOCAL, label: "My Local Drives" }
];
const getSectionConfig = (sharingType) => {
  return connectConfig.drives.sections[sharingType];
};
function getDriveNodeOptions(sharingType) {
  const options = [...defaultDriveOptions];
  if (connectConfig.drives.sections[sharingType].allowDelete) {
    options.push(DELETE);
  }
  if (connectDebug) {
    options.push(...debugNodeOptions);
  }
  return options;
}
function getFileNodeOptions() {
  const options = [...defaultFileOptions];
  if (connectDebug) {
    options.push(...debugNodeOptions);
  }
  return options;
}
function getFolderNodeOptions() {
  const options = [...defaultFolderOptions];
  if (connectDebug) {
    options.push(...debugNodeOptions);
  }
  return options;
}
function getNodeOptions() {
  return {
    [LOCAL]: {
      [DRIVE]: getDriveNodeOptions(LOCAL),
      [FOLDER]: getFolderNodeOptions(),
      [FILE]: getFileNodeOptions()
    },
    [CLOUD]: {
      [DRIVE]: getDriveNodeOptions(CLOUD),
      [FOLDER]: getFolderNodeOptions(),
      [FILE]: getFileNodeOptions()
    },
    [PUBLIC]: {
      [DRIVE]: getDriveNodeOptions(PUBLIC),
      [FOLDER]: getFolderNodeOptions(),
      [FILE]: getFileNodeOptions()
    }
  };
}
DriveSections.filter(
  (section) => getSectionConfig(section.sharingType).enabled
).map((section) => {
  const sectionConfig = getSectionConfig(section.sharingType);
  return {
    ...section,
    disableAddDrives: !sectionConfig.allowAdd
  };
});
var lzString = { exports: {} };
var hasRequiredLzString;
function requireLzString() {
  if (hasRequiredLzString) return lzString.exports;
  hasRequiredLzString = 1;
  (function(module) {
    var LZString2 = function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString3 = {
        compressToBase64: function(input) {
          if (input == null) return "";
          var res = LZString3._compress(input, 6, function(a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          return LZString3._decompress(input.length, 32, function(index) {
            return getBaseValue(keyStrBase64, input.charAt(index));
          });
        },
        compressToUTF16: function(input) {
          if (input == null) return "";
          return LZString3._compress(input, 15, function(a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString3._decompress(compressed.length, 16384, function(index) {
            return compressed.charCodeAt(index) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString3.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString3.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c) {
              result.push(f(c));
            });
            return LZString3.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null) return "";
          return LZString3._compress(input, 6, function(a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return LZString3._decompress(input.length, 32, function(index) {
            return getBaseValue(keyStrUriSafe, input.charAt(index));
          });
        },
        compress: function(uncompressed) {
          return LZString3._compress(uncompressed, 16, function(a) {
            return f(a);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString3._decompress(compressed.length, 32768, function(index) {
            return compressed.charCodeAt(index);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry = dictionary[c];
            } else {
              if (c === dictSize) {
                entry = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w + entry.charAt(0);
            enlargeIn--;
            w = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString3;
    }();
    if (module != null) {
      module.exports = LZString2;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString2;
      });
    }
  })(lzString);
  return lzString.exports;
}
var lzStringExports = requireLzString();
const LZString = /* @__PURE__ */ getDefaultExportFromCjs(lzStringExports);
const openBrowserUrl = (url) => window.open(url, "_blank");
const openUrl = ((_a = window.electronAPI) == null ? void 0 : _a.openURL) ?? openBrowserUrl;
function migrateDocumentOperationSignatures(document) {
  let legacy = false;
  const operations = Object.entries(document.operations).reduce((acc, [key, operations2]) => {
    const scope = key;
    for (const op of operations2) {
      const newOp = migrateLegacyOperationSignature(op);
      acc[scope].push(newOp);
      if (newOp !== op) {
        legacy = true;
      }
    }
    return acc;
  }, { global: [], local: [] });
  return legacy ? { ...document, operations } : document;
}
function migrateLegacyOperationSignature(operation) {
  var _a2;
  if (!((_a2 = operation.context) == null ? void 0 : _a2.signer) || operation.context.signer.signatures) {
    return operation;
  }
  const { signer } = operation.context;
  if ("signature" in signer) {
    const signature = signer.signature;
    return {
      ...operation,
      context: {
        ...operation.context,
        signer: {
          user: signer.user,
          app: signer.app,
          signatures: (signature == null ? void 0 : signature.length) ? [signature] : []
        }
      }
    };
  } else {
    return operation;
  }
}
var localforage = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
var hasRequiredLocalforage;
function requireLocalforage() {
  if (hasRequiredLocalforage) return localforage.exports;
  hasRequiredLocalforage = 1;
  (function(module, exports) {
    (function(f) {
      {
        module.exports = f();
      }
    })(function() {
      return function e(t2, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t2[o2]) {
              var a = typeof commonjsRequire == "function" && commonjsRequire;
              if (!u && a) return a(o2, true);
              if (i) return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t2[o2][0].call(l.exports, function(e2) {
              var n2 = t2[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t2, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof commonjsRequire == "function" && commonjsRequire;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module2, exports2) {
        (function(global2) {
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module2.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module2, exports2) {
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module2.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
        (function(global2) {
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance2, Constructor) {
          if (!(instance2 instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i = 0; i < length2; i++) {
            arr[i] = bin.charCodeAt(i);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e) {
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e) {
              e.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e) {
                e.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e) {
              var base64 = btoa(e.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i = 0; i < forages.length; i++) {
            var forage = forages[i];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j = 0; j < dbContext.forages.length; j++) {
            var forage = dbContext.forages[j];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k = 0; k < forages.length; k++) {
              var forage2 = forages[k];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var _forage = forages[i2];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j = 0; j < forages.length; j++) {
                    var _forage2 = forages[j];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i;
          var p = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i;
          for (i = 0; i < bytes.length; i += 3) {
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type2) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type2);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t2, dbInfo, callback, errorCallback) {
          t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e) {
              return reject(e);
            }
            dbInfo.db.transaction(function(t2) {
              createDbTable(t2, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t3, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
          t2.executeSql(sqlStatement, args, callback, function(t3, error) {
            if (error.code === error.SYNTAX_ERR) {
              t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
                if (!results.rows.length) {
                  createDbTable(t4, dbInfo, function() {
                    t4.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t4, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t3, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i = 0; i < length2; i++) {
                    var item = rows.item(i);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t3, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t3, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                  var keys2 = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    keys2.push(results.rows.item(i).key);
                  }
                  resolve(keys2);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t2) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
                var storeNames = [];
                for (var i = 0; i < results.rows.length; i++) {
                  storeNames.push(results.rows.item(i).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t3, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t2) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t3, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                    operations.push(dropTable(operationInfo.storeNames[i]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e) {
                    reject(e);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i = 0; i < length2; i++) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i = 0; i < length2; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e) {
                    if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e);
                    }
                    reject(e);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i = 0;
          while (i < len) {
            if (sameValue(array[i], searchElement)) {
              return true;
            }
            i++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage2 = function() {
          function LocalForage3(options) {
            _classCallCheck(this, LocalForage3);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage3.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i in options) {
                if (i === "storeName") {
                  options[i] = options[i].replace(/\W/g, "_");
                }
                if (i === "version" && typeof options[i] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i] = options[i];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage3.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                  var driverMethodName = driverMethods[i];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e) {
                reject(e);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage3.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage3.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage3.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage3.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage3.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage3.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage3.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage3.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage3.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
            }
          };
          LocalForage3.prototype.createInstance = function createInstance(options) {
            return new LocalForage3(options);
          };
          return LocalForage3;
        }();
        var localforage_js = new LocalForage2();
        module2.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  })(localforage);
  return localforage.exports;
}
var localforageExports = requireLocalforage();
const LocalForage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
const _BrowserStorage = class _BrowserStorage {
  constructor(namespace) {
    __publicField(this, "db");
    this.db = LocalForage.ready().then(() => LocalForage.createInstance({
      name: namespace ? `${namespace}:${_BrowserStorage.DBName}` : _BrowserStorage.DBName
    }));
  }
  ////////////////////////////////
  // IDocumentStorage
  ////////////////////////////////
  async exists(documentId) {
    const db = await this.db;
    const document = await db.getItem(this.buildDocumentKey(documentId));
    return !!document;
  }
  async create(documentId, document) {
    const db = await this.db;
    await db.setItem(this.buildDocumentKey(documentId), document);
  }
  async get(documentId) {
    const db = await this.db;
    const document = await db.getItem(this.buildDocumentKey(documentId));
    if (!document) {
      throw new Error(`Document with id ${documentId} not found`);
    }
    return document;
  }
  ////////////////////////////////
  // IDriveStorage
  ////////////////////////////////
  checkDocumentExists(drive, documentId) {
    return this.exists(documentId);
  }
  async getDriveManifest(driveId) {
    const db = await this.db;
    const manifest = await db.getItem(this.buildManifestKey(driveId));
    return manifest || { documentIds: [] };
  }
  async updateDriveManifest(driveId, manifest) {
    const db = await this.db;
    await db.setItem(this.buildManifestKey(driveId), manifest);
  }
  async getDocuments(drive) {
    const manifest = await this.getDriveManifest(drive);
    return manifest.documentIds;
  }
  async getDocument(driveId, id) {
    return this.get(id);
  }
  async createDocument(drive, id, document) {
    await this.create(id, document);
    const manifest = await this.getDriveManifest(drive);
    if (!manifest.documentIds.includes(id)) {
      manifest.documentIds.push(id);
      await this.updateDriveManifest(drive, manifest);
    }
  }
  async deleteDocument(drive, id) {
    await (await this.db).removeItem(this.buildDocumentKey(id));
    const manifest = await this.getDriveManifest(drive);
    const docIndex = manifest.documentIds.indexOf(id);
    if (docIndex !== -1) {
      manifest.documentIds.splice(docIndex, 1);
      await this.updateDriveManifest(drive, manifest);
    }
  }
  async clearStorage() {
    return (await this.db).clear();
  }
  async addDocumentOperations(drive, id, operations, header) {
    const document = await this.getDocument(drive, id);
    if (!document) {
      throw new Error(`Document with id ${id} not found`);
    }
    const mergedOperations = mergeOperations(document.operations, operations);
    const db = await this.db;
    await db.setItem(this.buildDocumentKey(id), {
      ...document,
      ...header,
      operations: mergedOperations
    });
  }
  async getDrives() {
    const db = await this.db;
    const keys = await db.keys();
    return keys.filter((key) => key.startsWith(_BrowserStorage.DRIVES_KEY)).map((key) => key.slice(_BrowserStorage.DRIVES_KEY.length + _BrowserStorage.SEP.length));
  }
  async getDrive(id) {
    const db = await this.db;
    const drive = await db.getItem(this.buildDriveKey(id));
    if (!drive) {
      throw new DriveNotFoundError(id);
    }
    return drive;
  }
  async getDriveBySlug(slug) {
    const drives = (await this.getDrives()).reverse();
    for (const drive of drives) {
      const driveData = await this.getDrive(drive);
      if (driveData.initialState.state.global.slug === slug) {
        return this.getDrive(drive);
      }
    }
    throw new Error(`Drive with slug ${slug} not found`);
  }
  async createDrive(id, drive) {
    const db = await this.db;
    await db.setItem(this.buildDriveKey(id), drive);
    await this.updateDriveManifest(id, { documentIds: [] });
  }
  async deleteDrive(id) {
    const documents = await this.getDocuments(id);
    await Promise.all(documents.map((doc) => this.deleteDocument(id, doc)));
    const db = await this.db;
    await db.removeItem(this.buildManifestKey(id));
    return db.removeItem(this.buildDriveKey(id));
  }
  async addDriveOperations(id, operations, header) {
    const drive = await this.getDrive(id);
    const mergedOperations = mergeOperations(drive.operations, operations);
    const db = await this.db;
    await db.setItem(this.buildDriveKey(id), {
      ...drive,
      ...header,
      operations: mergedOperations
    });
  }
  async getSynchronizationUnitsRevision(units) {
    const results = await Promise.allSettled(units.map(async (unit) => {
      try {
        const document = await (unit.documentId ? this.getDocument(unit.driveId, unit.documentId) : this.getDrive(unit.driveId));
        if (!document) {
          return void 0;
        }
        const operation = document.operations[unit.scope].at(-1);
        if (operation) {
          return {
            driveId: unit.driveId,
            documentId: unit.documentId,
            scope: unit.scope,
            branch: unit.branch,
            lastUpdated: operation.timestamp,
            revision: operation.index
          };
        }
      } catch {
        return void 0;
      }
    }));
    return results.reduce((acc, curr) => {
      if (curr.status === "fulfilled" && curr.value !== void 0) {
        acc.push(curr.value);
      }
      return acc;
    }, []);
  }
  // migrates all stored operations from legacy signature to signatures array
  async migrateOperationSignatures() {
    const drives = await this.getDrives();
    for (const drive of drives) {
      await this.migrateDrive(drive);
      const documents = await this.getDocuments(drive);
      await Promise.all(documents.map(async (docId) => this.migrateDocument(drive, docId)));
    }
  }
  async migrateDrive(driveId) {
    const drive = await this.getDrive(driveId);
    const migratedDrive = migrateDocumentOperationSignatures(drive);
    if (migratedDrive !== drive) {
      return (await this.db).setItem(this.buildDriveKey(driveId), migratedDrive);
    }
  }
  async migrateDocument(drive, id) {
    const document = await this.getDocument(drive, id);
    const migratedDocument = migrateDocumentOperationSignatures(document);
    if (migratedDocument !== document) {
      return (await this.db).setItem(this.buildDocumentKey(id), migratedDocument);
    }
  }
  ////////////////////////////////
  // Private methods
  ////////////////////////////////
  buildDriveKey(driveId) {
    return `${_BrowserStorage.DRIVES_KEY}${_BrowserStorage.SEP}${driveId}`;
  }
  buildDocumentKey(documentId) {
    return `${_BrowserStorage.DOCUMENT_KEY}${_BrowserStorage.SEP}${documentId}`;
  }
  buildManifestKey(driveId) {
    return `${_BrowserStorage.MANIFEST_KEY}${_BrowserStorage.SEP}${driveId}`;
  }
};
__publicField(_BrowserStorage, "DBName", "DOCUMENT_DRIVES");
__publicField(_BrowserStorage, "SEP", ":");
__publicField(_BrowserStorage, "DRIVES_KEY", "DRIVES");
__publicField(_BrowserStorage, "DOCUMENT_KEY", "DOCUMENT");
__publicField(_BrowserStorage, "MANIFEST_KEY", "MANIFEST");
let BrowserStorage = _BrowserStorage;
const DEFAULT_DRIVES_URL = window.__VITE_ENVS.PH_CONNECT_DEFAULT_DRIVES_URL || void 0;
const defaultDrivesUrl = DEFAULT_DRIVES_URL ? DEFAULT_DRIVES_URL.split(",") : [];
const getReactorDefaultDrivesConfig = () => {
  const remoteDrives = defaultDrivesUrl.map(
    (driveUrl) => ({
      url: driveUrl,
      options: {
        sharingType: "PUBLIC",
        availableOffline: true,
        listeners: [
          {
            block: true,
            callInfo: {
              data: driveUrl,
              name: "switchboard-push",
              transmitterType: "SwitchboardPush"
            },
            filter: {
              branch: ["main"],
              documentId: ["*"],
              documentType: ["*"],
              scope: ["global"]
            },
            label: "Switchboard Sync",
            listenerId: "1",
            system: true
          }
        ],
        triggers: []
      }
    })
  );
  return {
    defaultDrives: {
      remoteDrives,
      removeOldRemoteDrives: defaultDrivesUrl.length > 0 ? {
        strategy: "preserve-by-url-and-detach",
        urls: defaultDrivesUrl
      } : { strategy: "preserve-all" }
    }
  };
};
function createBrowserDocumentDriveServer(documentModels, routerBasename) {
  return new ReactorBuilder(documentModels).withStorage(new BrowserStorage(routerBasename)).withCache(new InMemoryCache()).withQueueManager(new BaseQueueManager(1, 10)).withOptions({ ...getReactorDefaultDrivesConfig() }).build();
}
const VERSION_CHECK_INTERVAL = parseInt(window.__VITE_ENVS.PH_CONNECT_VERSION_CHECK_INTERVAL) || 60 * 60 * 1e3;
const basePath = connectConfig.routerBasename;
const serviceWorkerScriptPath = [basePath, "service-worker.js"].join("/").replace(/\/{2,}/gm, "/");
class ServiceWorkerManager {
  constructor(debug = false) {
    __privateAdd(this, _ServiceWorkerManager_instances);
    __publicField(this, "ready", false);
    __publicField(this, "debug", false);
    __publicField(this, "registration", null);
    this.debug = debug;
  }
  setDebug(debug) {
    this.debug = debug;
  }
  registerServiceWorker(debug = false) {
    this.debug = debug;
    if (!("serviceWorker" in navigator)) {
      console.warn("Service Worker not available");
      return;
    }
    window.addEventListener("load", async () => {
      try {
        const existingRegistration = await navigator.serviceWorker.getRegistration();
        if (existingRegistration) {
          await existingRegistration.update();
          __privateMethod(this, _ServiceWorkerManager_instances, handleServiceWorker_fn).call(this, existingRegistration);
        } else {
          const registration = await navigator.serviceWorker.register(
            serviceWorkerScriptPath
          );
          __privateMethod(this, _ServiceWorkerManager_instances, handleServiceWorker_fn).call(this, registration);
          registration.addEventListener("updatefound", () => {
            __privateMethod(this, _ServiceWorkerManager_instances, handleServiceWorker_fn).call(this, registration);
          });
        }
        const intervalId = setInterval(async () => {
          const existingRegistration2 = await navigator.serviceWorker.getRegistration();
          if (existingRegistration2) {
            await existingRegistration2.update();
          } else {
            clearInterval(intervalId);
            this.registerServiceWorker();
          }
        }, VERSION_CHECK_INTERVAL);
      } catch (error) {
        console.error("ServiceWorker registration failed: ", error);
      }
    });
  }
}
_ServiceWorkerManager_instances = new WeakSet();
handleServiceWorkerMessage_fn = function(event) {
  if (this.debug) {
    console.log("ServiceWorker message: ", event);
  }
  const message = "type" in event.data ? event : null;
  switch (message == null ? void 0 : message.data.type) {
    case "NEW_VERSION_AVAILABLE": {
      if (message.data.version === connectConfig.appVersion) {
        return;
      }
      if (message.data.requiresHardRefresh) {
        if (this.debug) {
          console.log("New version available");
        }
        window.location.reload();
      }
      break;
    }
    default: {
      console.warn("Unhandled message:", message);
      break;
    }
  }
};
handleServiceWorker_fn = function(registration) {
  {
    if (this.debug) {
      console.log("ServiceWorker registered: ", registration);
    }
    navigator.serviceWorker.addEventListener(
      "message",
      __privateMethod(this, _ServiceWorkerManager_instances, handleServiceWorkerMessage_fn).bind(this)
    );
    this.registration = registration;
    this.ready = true;
  }
};
const serviceWorkerManager = new ServiceWorkerManager();
const isString = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString(object);
const getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
const pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path]) return obj[path];
  const tokens = path.split(keySeparator);
  let current2 = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current2 || typeof current2 !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current2[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current2 = next;
  }
  return current2;
};
const getCleanedCode = (code) => code && code.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type2, args) {
    if (console && console[type2]) console[type2].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources2) {
      if (isString(resources2[m]) || Array.isArray(resources2[m])) this.addResource(lng, ns, m, resources2[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  addResourceBundle(lng, ns, resources2, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources2;
      resources2 = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources2 = JSON.parse(JSON.stringify(resources2));
    if (deep) {
      deepExtend(pack, resources2, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources2
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng, ns, resources2);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey) copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (isString(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
const capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      if (typeof Intl !== "undefined" && typeof Intl.getCanonicalLocales !== "undefined") {
        try {
          let formattedCode = Intl.getCanonicalLocales(code)[0];
          if (formattedCode && this.options.lowerCaseLng) {
            formattedCode = formattedCode.toLowerCase();
          }
          if (formattedCode) return formattedCode;
        } catch (e) {
        }
      }
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: (n) => Number(n > 1),
  2: (n) => Number(n != 1),
  3: (n) => 0,
  4: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  5: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),
  6: (n) => Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),
  7: (n) => Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  8: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),
  9: (n) => Number(n >= 2),
  10: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),
  11: (n) => Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),
  12: (n) => Number(n % 10 != 1 || n % 100 == 11),
  13: (n) => Number(n !== 0),
  14: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),
  15: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  16: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),
  17: (n) => Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),
  18: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : 2),
  19: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),
  20: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),
  21: (n) => Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),
  22: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const createRules = () => {
  const rules = {};
  sets.forEach((set2) => {
    set2.lngs.forEach((l) => {
      rules[l] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
      const type2 = options.ordinal ? "ordinal" : "cardinal";
      const cacheKey = JSON.stringify({
        cleanedCode,
        type: type2
      });
      if (cacheKey in this.pluralRulesCache) {
        return this.pluralRulesCache[cacheKey];
      }
      let rule;
      try {
        rule = new Intl.PluralRules(cleanedCode, {
          type: type2
        });
      } catch (err) {
        if (!code.match(/-|_/)) return;
        const lngPart = this.languageUtils.getLanguagePartFromCode(code);
        rule = this.getRule(lngPart, options);
      }
      this.pluralRulesCache[cacheKey] = rule;
      return rule;
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = fc;
  }
  addCached(name2, fc) {
    this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}
const removePending = (q, name2) => {
  if (q.pending[name2] !== void 0) {
    delete q.pending[name2];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name2 = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name2] = 2;
        } else if (this.state[name2] < 0) ;
        else if (this.state[name2] === 1) {
          if (pending[name2] === void 0) pending[name2] = true;
        } else {
          this.state[name2] = 1;
          hasAllNamespaces = false;
          if (pending[name2] === void 0) pending[name2] = true;
          if (toLoad[name2] === void 0) toLoad[name2] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name2, err, data) {
    const s = name2.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name2] = err ? -1 : 2;
    if (err && data) this.state[name2] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name2);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name2) => {
      this.loadOne(name2);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name2) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name2.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name2, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n) => {
      const loadState2 = this.services.backendConnector.state[`${l}|${n}`];
      return loadState2 === -1 || loadState2 === 0 || loadState2 === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
const t = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m) => htmlEntities[m];
const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
function setDefaults() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
}
function getDefaults() {
  return defaultOptions;
}
let i18nInstance;
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
const common = { "cancel": "Cancel", "delete": "Delete", "continue": "Continue", "empty": "Empty", "create": "Create", "save": "Save", "export": "Export", "reload": "Reload", "reloadConnect": "Click here to reload Connect" };
const searchbar = { "placeholder": "Search Powerhouse", "filterLabel": "File type" };
const folderView = { "sections": { "folders": { "title": "Folders", "empty": "No folders 🗂️" }, "documents": { "title": "Documents and files", "empty": "No documents or files 📄" } } };
const files = { "options": { "switchboardLink": "Switchboard Link" } };
const modals = { "deleteItem": { "folder": { "header": "Delete “{{item}}” folder?", "body": "Are you sure you want to delete this folder? All files and subfolders within it will be removed." }, "file": { "header": "Delete “{{item}}” file?", "body": "Are you sure you want to delete this file?" } }, "deleteDrive": { "title": 'Delete "{{label}}" drive?', "body": "Are you sure you want to delete this drive? All files and subfolders within it will be removed. Do you want to proceed?", "inputPlaceholder": "Enter drive name..." }, "upgradeDrive": { "header": "Upgrade to cloud drive", "body": "You are moving files from a private to a shared drive. These files will become accessible to others in the shared drive.Do you want to proceed?" }, "createDocument": { "header": "Create a new document", "placeholder": "Document name" }, "connectSettings": { "title": "Settings", "body": "These settings will apply to all drives.", "clearStorage": { "button": "Clear Storage", "description": "Delete previous session data", "confirmation": { "title": "Clear Storage", "body": "Are you sure you want to clear the storage? This will remove all previous session data.", "clearButton": "Clear Storage" } }, "enabledDocumentTypes": { "title": "Document Models", "description": "Documents enabled", "allSelected": "All documents are selected" } }, "exportDocumentWithErrors": { "title": "Your document contains errors", "body": "Your document contains structure errors. Do you want to export it anyway?" }, "disclaimer": { "title": "Disclaimer", "body": "All content provided herein our website, hyperlinked sites, associated applications, forums, blogs, social media accounts and other platforms (“Site”) is for your general information only, procured from third party sources. We make no warranties of any kind in relation to our content, including but not limited to accuracy and updatedness. No part of the content that we provide constitutes financial advice, legal advice or any other form of advice meant for your specific reliance for any purpose. Any use or reliance on our content is solely at your own risk and discretion. You should conduct your own research, review, analyse and verify our content before relying on them. Trading is a highly risky activity that can lead to major losses, please therefore consult your financial advisor before making any decision. No content on our Site is meant to be a solicitation or offer." }, "cookiesPolicy": { "title": "Cookies Policy", "body": "<subtitle>Use of Cookies and Similar Technologies</subtitle><p>The Site is using cookies. Cookies are small text files that are placed on your computer by websites that you visit. They are widely used in order to make websites work, or work more efficiently, as well as to provide information to the owners of the site. Cookies are typically stored on your computer´s hard drive.Information collected from cookies is used by us to evaluate the effectiveness of our Site and analyze trends. The information collected from cookies allows us to determine such things as which parts of the Site are most visited and difficulties our visitors may experience in accessing the SIte. With this knowledge, we can improve the quality of your experience on the Site by recognizing and delivering more of the most desired features and information, as well as by resolving access difficulties.</p><p>We use third party service providers, to assist us in better understanding the use of our Site. Our service providers will place cookies on the hard drive of your computer (or use similar technologies) and will receive information that we select that will educate us on such things as how visitors navigate around our Site. This information is aggregated to provide statistical data about our users browsing actions and patterns, and does not personally identify individuals. This information may include:</p><p>Computer or mobile device information, Website usage information, such as:<list></p><bullet>Page views,</bullet><bullet>Button clicks,</bullet><bullet>Input form changes (without the values being entered),</bullet><bullet>Errors.</bullet></list><p>Our service providers analyses this information and provides us with aggregate reports. The information and analysis provided by our service providers will be used to assist us in better understanding our visitors interests in our Site and how to better serve those interests. If you want to avoid using cookies altogether, you can disable cookies in your browser. However, disabling cookies might make it impossible for you to use certain features of the Site. Your use of the Site with a browser that is configured to accept cookies constitutes an acceptance of our and third-party cookies.</p>" } };
const notifications = { "deleteDriveSuccess": "Drive successfully deleted", "deleteFolderSuccess": "Folder deleted", "fileDeleteSuccess": "File deleted", "addDriveSuccess": "New drive successfully added", "driveSyncSuccess": "Drive synced successfully", "driveSyncError": "Error synchronizing drive {{drive}}", "driveSyncConflict": "Conflict error detected in {{drive}}", "reloadApp": "It seems like you're running an outdated version of the app. Please reload Connect to get the latest version." };
const footer = { "cookiePolicy": "Cookie Policy", "termsOfUse": "Terms of Use", "disclaimer": "Disclaimer", "builtWith": "Built with <icon /> Powerhouse" };
const cookieBanner = { "message": "This website uses cookies for analytic purposes only. Cookies are anonymous and do not link to user data. We collect information to improve the user experience and validate UI changes. You can still use the page without cookies. For more information, please read our <a>cookies policy.</a>", "accept": "Accept configured cookies", "reject": "Reject all cookies", "cookies": { "functional": "Functional cookies", "analytics": "Analytics cookies" } };
const translationEN = {
  common,
  searchbar,
  folderView,
  files,
  modals,
  notifications,
  footer,
  cookieBanner
};
const resources = {
  en: {
    code: "en",
    name: "English",
    translation: translationEN
  }
};
instance.use(initReactI18next).init({
  resources,
  fallbackLng: "en",
  debug: true,
  interpolation: {
    escapeValue: false
  }
});
if (window.__VITE_ENVS.MODE === "development") {
  window.documentEditorDebugTools = new DocumentEditorDebugTools();
} else {
  serviceWorkerManager.registerServiceWorker(false);
}
const App = lazy(() => __vitePreload(() => import("./app-Bw1Ba-jV.js").then((n) => n.aN), true ? __vite__mapDeps([0,1,2]) : void 0));
const AppLoader = /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(App, {}) });
const appLoader = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: AppLoader
}, Symbol.toStringTag, { value: "Module" }));
export {
  getDefaultExportFromCjs as $,
  AddStateExampleInputSchema as A,
  SetModuleDescriptionInputSchema as B,
  SetModuleNameInputSchema as C,
  DeleteStateExampleInputSchema as D,
  AddModuleInputSchema as E,
  ReorderChangeLogItemsInputSchema as F,
  DeleteChangeLogItemInputSchema as G,
  UpdateChangeLogItemInputSchema as H,
  AddChangeLogItemInputSchema as I,
  SetAuthorWebsiteInputSchema as J,
  SetAuthorNameInputSchema as K,
  SetModelDescriptionInputSchema as L,
  MoveOperationInputSchema as M,
  SetModelExtensionInputSchema as N,
  SetModelIdInputSchema as O,
  SetModelNameInputSchema as P,
  baseCreateExtendedState as Q,
  ReorderStateExamplesInputSchema as R,
  SetInitialStateInputSchema as S,
  baseCreateDocument as T,
  UpdateStateExampleInputSchema as U,
  baseSaveToFile as V,
  baseSaveToFileHandle as W,
  baseLoadFromFile as X,
  baseLoadFromInput as Y,
  pascalCase as Z,
  Icon as _,
  createReducer as a,
  DELETE as a$,
  LOCAL as a0,
  commonjsGlobal as a1,
  PUBLIC as a2,
  SWITCHBOARD as a3,
  locationInfoByLocation as a4,
  sharingTypeOptions as a5,
  objectType as a6,
  recordType as a7,
  stringType as a8,
  capitalCase as a9,
  generateNodesCopy as aA,
  copyNode as aB,
  createState as aC,
  setDriveName as aD,
  setAvailableOffline as aE,
  setSharingType as aF,
  SynchronizationUnitNotFoundError as aG,
  removeTrigger as aH,
  generateUUID as aI,
  PullResponderTransmitter as aJ,
  addTrigger as aK,
  ReadDriveNotFoundError as aL,
  openUrl as aM,
  getNodeOptions as aN,
  DRIVE as aO,
  FOLDER as aP,
  requestPublicDrive as aQ,
  serviceWorkerManager as aR,
  packageJson as aS,
  t as aT,
  gql as aU,
  request as aV,
  getAugmentedNamespace as aW,
  getDimensions as aX,
  READ as aY,
  nodeOptionsMap as aZ,
  defaultFileOptions as a_,
  CLOUD as aa,
  createZip as ab,
  logger$1 as ac,
  LZString as ad,
  buildSignedOperation as ae,
  getI18n as af,
  getDefaults as ag,
  connectConfig as ah,
  hashDocumentStateForScope as ai,
  setErrorHandler as aj,
  driveDocumentModelModule as ak,
  createBrowserDocumentDriveServer as al,
  hashKey as am,
  childLogger as an,
  reducer as ao,
  isDocumentDrive as ap,
  generateAddNodeAction as aq,
  isFileNode as ar,
  uploadDocumentOperations as as,
  updateFile as at,
  addFolder as au,
  isFolderNode as av,
  deleteNode as aw,
  updateNode as ax,
  FILE as ay,
  moveNode as az,
  SetStateSchemaInputSchema as b,
  GraphQLInt as b$,
  RENAME as b0,
  WRITE as b1,
  DUPLICATE as b2,
  defaultFolderOptions as b3,
  garbageCollect as b4,
  sortOperations as b5,
  UI_NODE as b6,
  undo as b7,
  redo as b8,
  useDocumentDispatch as b9,
  snakeCase as bA,
  constantCase as bB,
  isAbstractType as bC,
  BREAK as bD,
  GraphQLInputObjectType as bE,
  GraphQLList as bF,
  GraphQLEnumType as bG,
  GraphQLObjectType as bH,
  GraphQLInterfaceType as bI,
  SchemaMetaFieldDef as bJ,
  TypeMetaFieldDef as bK,
  TypeNameMetaFieldDef as bL,
  isCompositeType as bM,
  isOutputType as bN,
  isInputType as bO,
  GraphQLBoolean as bP,
  assertAbstractType as bQ,
  doTypesOverlap as bR,
  DirectiveLocation as bS,
  specifiedRules as bT,
  NoUnusedFragmentsRule as bU,
  ExecutableDefinitionsRule as bV,
  validate as bW,
  validateSchema as bX,
  GraphQLID as bY,
  GraphQLString as bZ,
  GraphQLFloat as b_,
  inspect as ba,
  GraphQLError as bb,
  getNamedType as bc,
  invariant as bd,
  isInputObjectType as be,
  isScalarType as bf,
  isObjectType as bg,
  isInterfaceType as bh,
  isUnionType as bi,
  isEnumType as bj,
  print as bk,
  isPrintableAsBlockString as bl,
  Kind as bm,
  astFromValue as bn,
  DEFAULT_DEPRECATION_REASON as bo,
  isSpecifiedDirective as bp,
  isSpecifiedScalarType as bq,
  isIntrospectionType as br,
  z as bs,
  GraphQLScalarType as bt,
  parse as bu,
  visit as bv,
  buildASTSchema as bw,
  extendSchema as bx,
  getNullableType as by,
  isListType as bz,
  createAction as c,
  GraphQLDirective as c0,
  GraphQLUnionType as c1,
  isNonNullType as c2,
  GraphQLNonNull as c3,
  isNamedType as c4,
  isLeafType as c5,
  GraphQLSchema as c6,
  buildSchema as c7,
  sentenceCase as c8,
  appLoader as c9,
  ReorderModuleOperationsInputSchema as d,
  DeleteOperationInputSchema as e,
  SetOperationReducerInputSchema as f,
  SetOperationTemplateInputSchema as g,
  SetOperationDescriptionInputSchema as h,
  isDocumentAction as i,
  SetOperationSchemaInputSchema as j,
  SetOperationScopeInputSchema as k,
  SetOperationNameInputSchema as l,
  AddOperationInputSchema as m,
  ReorderOperationExamplesInputSchema as n,
  DeleteOperationExampleInputSchema as o,
  UpdateOperationExampleInputSchema as p,
  AddOperationExampleInputSchema as q,
  ReorderOperationErrorsInputSchema as r,
  DeleteOperationErrorInputSchema as s,
  SetOperationErrorTemplateInputSchema as t,
  SetOperationErrorDescriptionInputSchema as u,
  SetOperationErrorNameInputSchema as v,
  SetOperationErrorCodeInputSchema as w,
  AddOperationErrorInputSchema as x,
  ReorderModulesInputSchema as y,
  DeleteModuleInputSchema as z
};
